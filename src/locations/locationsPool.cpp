
#include "../includes.h"
const string CONST_locationsPoolB146 = ", NY";
const string CONST_locationsPoolB145 = ", CA";
const string CONST_locationsPoolB144 = ", VA";
const string CONST_locationsPool145 = "Temporary Squad";
const string CONST_locationsPool144 = "If you do not enter anything, their real name will be used.";
const string CONST_locationsPool143 = " in its presence?";
const string CONST_locationsPool142 = "What name will you use for this ";
const string CONST_locationsPool141 = "The Education of ";
const string CONST_locationsPool140 = "R - Stockpile 20 daily rations of food ($150)";
const string CONST_locationsPool139 = "F - Setup a Business Front to ward off suspicion ($3000)";
const string CONST_locationsPool138 = "P - Buy a Printing Press to start your own newspaper ($3000)";
const string CONST_locationsPool137 = "A - Install and conceal an illegal Anti-Aircraft gun on the roof ($200,000)";
const string CONST_locationsPool136 = "A - Install a perfectly legal Anti-Aircraft gun on the roof ($35,000)";
const string CONST_locationsPool135 = "G - Buy a Generator for emergency electricity ($3000)";
const string CONST_locationsPool134 = "T - Ring the Compound with Tank Traps ($3000)";
const string CONST_locationsPool133 = "B - Place Booby Traps throughout the Compound ($3000)";
const string CONST_locationsPool132 = "C - Place Security Cameras around the Compound ($2000)";
const string CONST_locationsPool131 = "W - Fortify the Compound for a Siege ($2000)";
const string CONST_locationsPool130 = "W - Fortify the Bomb Shelter Entrances ($2000)";
const string CONST_locationsPool129 = "W - Repair the Bunker Fortifications ($2000)";
const string CONST_locationsPool128 = "caseBUSINESSFRONT_MISCELLANEOUS.txt";
const string CONST_locationsPool127 = "caseBUSINESSFRONT_RESTAURANT.txt";
const string CONST_locationsPool126 = "caseBUSINESSFRONT_TEMPAGENCY.txt";
const string CONST_locationsPool125 = "caseBUSINESSFRONT_INSURANCE.txt";
const string CONST_locationsPool124 = "Enter - Back one step.";
const string CONST_locationsPool123 = "Enter - The squad is not yet Liberal enough.";
const string CONST_locationsPool122 = "Where will the Squad go?";
const string CONST_locationsPool121 = "Acting Individually";
const string CONST_locationsPool120 = "2) Press Z to Assemble a New Squad";
const string CONST_locationsPool119 = "1) R - Review Assets and Form Squads";
const string CONST_locationsPool118 = "To form a new squad:";
const string CONST_locationsPool117 = "No Squad Selected";
const string CONST_locationsPool116 = " Eating";
const string CONST_locationsPool115 = "s";
const string CONST_locationsPool114 = " Daily Ration";
const string CONST_locationsPool113 = "Not Enough Food";
const string CONST_locationsPool112 = " of Food Left";
const string CONST_locationsPool111 = " Day";
const string CONST_locationsPool110 = "GENERATOR";
const string CONST_locationsPool109 = "LIGHTS OUT";
const string CONST_locationsPool108 = "TANK TRAPS";
const string CONST_locationsPool107 = "AA GUN";
const string CONST_locationsPool106 = "BOOBY TRAPS";
const string CONST_locationsPool105 = "CAMERAS ON";
const string CONST_locationsPool104 = "CAMERAS OFF";
const string CONST_locationsPool103 = "BUSINESS FRONT";
const string CONST_locationsPool102 = "PRINTING PRESS";
const string CONST_locationsPool101 = "FORTIFIED COMPOUND";
const string CONST_locationsPool100 = "This location has insufficient food stores.";
const string CONST_locationsPool099 = "This location has food for only a few days.";
const string CONST_locationsPool098 = "You are not under siege...  yet.";
const string CONST_locationsPool097 = "Firemen are raiding this location!";
const string CONST_locationsPool096 = "The CCS is raiding this location!";
const string CONST_locationsPool095 = "The Corporations are raiding this location!";
const string CONST_locationsPool094 = "The masses are storming this location!";
const string CONST_locationsPool093 = "The CIA is raiding this location!";
const string CONST_locationsPool092 = "The police are raiding this location!";
const string CONST_locationsPool091 = "The police have surrounded this location.";
const string CONST_locationsPool089 = ",. to view other base pages.";
const string CONST_locationsPool088 = "  Shift and a Number will move ALL items!";
const string CONST_locationsPool087 = "T to sort by type.";
const string CONST_locationsPool086 = "T to sort by location.";
const string CONST_locationsPool085 = "Press a Letter to assign a base.  Press a Number to select a base.";
const string CONST_locationsPool084 = "NEW LOCATION";
const string CONST_locationsPool083 = "----ITEM----------------CURRENT LOCATION---------------------------------------";
const string CONST_locationsPool082 = "Moving Equipment";
const string CONST_locationsPool081 = "Press a letter to select an item.";
const string CONST_locationsPool080 = "x";
const string CONST_locationsPool079 = "/";
const string CONST_locationsPool078 = "Select Objects";
const string CONST_locationsPool077 = "strip down.";
const string CONST_locationsPool076 = "Can't carry any more ammo.";
const string CONST_locationsPool075 = "That ammo doesn't fit.";
const string CONST_locationsPool074 = "Can't carry ammo without a gun.";
const string CONST_locationsPool073 = "No ammo available!";
const string CONST_locationsPool072 = "No ammo required!";
const string CONST_locationsPool071 = "No spare clips!";
const string CONST_locationsPool070 = "No ammo to drop!";
const string CONST_locationsPool069 = "receive it.";
const string CONST_locationsPool068 = "drop a clip.";
const string CONST_locationsPool067 = "receive a clip.";
const string CONST_locationsPool066 = "You can't equip that.";
const string CONST_locationsPool065 = "Z - Stash things at ";
const string CONST_locationsPool064 = "Y - Get things from ";
const string CONST_locationsPool063 = "Cursors - Increase or decrease ammo allocation";
const string CONST_locationsPool062 = "S - Liberally Strip a Squad member";
const string CONST_locationsPool061 = "Press a number to drop that Squad member's Conservative weapon";
const string CONST_locationsPool060 = "Press a letter to equip a Liberal item";
const string CONST_locationsPool059 = " x";
const string CONST_locationsPool058 = "Equip the Squad";
const string CONST_locationsPool057 = "     How many?          ";
const string CONST_locationsPool056 = "Reporting Bugs to the Dev Team";
const string CONST_locationsPool055 = "Going to ";
const string CONST_locationsPool054 = "Making ";
const string CONST_locationsPool053 = "a bug";
const string CONST_locationsPool052 = "Tending to ";
const string CONST_locationsPool051 = ", New York";
const string CONST_locationsPool050 = ", California";
const string CONST_locationsPool049 = ", Virginia";
const string CONST_locationsPool048 = " Outskirts";
const string CONST_locationsPool047 = "Mall";
const string CONST_locationsPool046 = "sleeper agent";
const string CONST_locationsPool045 = " as a ";
const string CONST_locationsPool044 = "Stay at ";
const string CONST_locationsPool043 = "-> ";
const string CONST_locationsPool042 = "regular member";
const string CONST_locationsPool040 = "Come to ";
const string CONST_locationsPool039 = "   ";
const string CONST_locationsPool038 = " best serve the Liberal cause?";
const string CONST_locationsPool037 = "In what capacity will ";
const string CONST_locationsPool036 = ".  Possessions go to the shelter.";
const string CONST_locationsPool035 = "EVICTION NOTICE: ";

const string tag_LOOT = "LOOT";
const string tag_LOOT_SECRETDOCUMENTS = "LOOT_SECRETDOCUMENTS";
const string tag_LOOT_INTHQDISK = "LOOT_INTHQDISK";
const string tag_The_Bronx = "The Bronx";
const string tag_Long_Island = "Long Island";
const string tag_Brooklyn_ampersand_Queens = "Brooklyn & Queens";
const string tag_B = "B";
const string tag_Manhattan = "Manhattan";
const string tag_The = "The ";
const string tag_Manhattan_Island = "Manhattan Island";
const string tag_Greater_Hollywood = "Greater Hollywood";
const string tag_Hollywood = "Hollywood";
const string tag_Arlington = "Arlington";
const string tag_City_Outskirts = "City Outskirts";
const string tag_Seaport_Area = "Seaport Area";
const string tag_Shopping = "Shopping";
const string tag_Seaport = "Seaport";
const string tag_Outskirts_amp_Orange_County = "Outskirts & Orange County";
const string tag_Outskirts = "Outskirts";
const string tag_University_District = "University District";
const string tag_i_District = "I-District";
const string tag_Industrial_District = "Industrial District";
const string tag_u_District = "U-District";
const string tag_D = "D";
const string tag_Downtown = "Downtown";
const string tag_National_Mall = "National Mall";
const string tag_ARMOR = "ARMOR";
const string tag_ARMOR_CLOTHES = "ARMOR_CLOTHES";
const string tag_CLIP = "CLIP";
const string tag_CLIP_9 = "CLIP_9";
const string tag_WEAPON = "WEAPON";
const string tag_WEAPON_SEMIPISTOL_9MM = "WEAPON_SEMIPISTOL_9MM";
const string tag_WEAPON_SMG_MP5 = "WEAPON_SMG_MP5";
const string tag_WEAPON_AUTORIFLE_AK47 = "WEAPON_AUTORIFLE_AK47";
const string blankString = "";
#include "../creature/creature.h"
#include "../locations/locations.h"
#include "../items/armortype.h"
#include "../common/ledgerEnums.h"
#include "../common/ledger.h"
#include "../vehicle/vehicletype.h"
#include "../vehicle/vehicle.h"
#include "../common/commondisplay.h"
// for void printfunds(int,int,char*)
#include "../common/stringconversion.h"
//for string attribute_enum_to_string(int)
#include "../common/getnames.h"
// for cityname
#include "../common/translateid.h"
// for  getarmortype
#include "../cursesAlternative.h"
#include "../cursesAlternativeConstants.h"
#include "../set_color_support.h"
#include "locationsPool.h"
#include "../common/creaturePoolCreature.h"
#include "../items/money.h"
#include "../recruits.h"
vector<Location *> location;
extern class Ledger ledger;
void initiateNewgameLocations(char base, char recruits, Vehicle * startcar, bool makelawyer, bool gaylawyer, Creature * newcr) {
	squadst *newsq = new squadst;
	extern long cursquadid;
	newsq->id = 0; cursquadid++;
	newsq->squad[0] = newcr;
	newcr->squadid = 0;
	extern string theLCS;
	strcpy(newsq->name, theLCS);
	extern vector<ClipType *> cliptype;
	extern vector<WeaponType *> weapontype;
	extern vector<squadst *> squad;
	for (int l = 0; l < len(location); l++)
	{
		if (location[l]->type == base)
		{
			newcr->base = l;
			newcr->location = l;
			if (startcar) startcar->set_location(l);
			switch (base)
			{
			case SITE_RESIDENTIAL_APARTMENT_UPSCALE:location[l]->renting = 500; break;
			case SITE_RESIDENTIAL_APARTMENT:location[l]->renting = 200; break;
			case SITE_RESIDENTIAL_TENEMENT:location[l]->renting = 100; break;
			case SITE_BUSINESS_CRACKHOUSE:
				location[l]->renting = RENTING_PERMANENT;
				location[l]->compound_stores += 100;
				break;
			}
			location[l]->newrental = 1;
			switch (recruits)
			{
			case RECRUITS_GANG:
				for (int i = 0; i < 4; i++)
				{
					Creature* recruit = new Creature;
					makecreature(*recruit, CREATURE_GANGMEMBER);
					if (recruit->get_weapon().get_itemtypename() == tag_WEAPON_AUTORIFLE_AK47 ||
						recruit->get_weapon().get_itemtypename() == tag_WEAPON_SMG_MP5 ||
						!recruit->is_armed())
					{
						Weapon w(*weapontype[getweapontype(tag_WEAPON_SEMIPISTOL_9MM)]);
						recruit->give_weapon(w, NULL);
						Clip c(*cliptype[getcliptype(tag_CLIP_9)], 4);
						recruit->take_clips(c, 4);
						recruit->reload(false);
					}
					recruit->align = ALIGN_LIBERAL;
					recruit->set_attribute(ATTRIBUTE_HEART,
						recruit->get_attribute(ATTRIBUTE_HEART, false) +
						recruit->get_attribute(ATTRIBUTE_WISDOM, false) / 2);
					recruit->set_attribute(ATTRIBUTE_WISDOM,
						recruit->get_attribute(ATTRIBUTE_WISDOM, false) / 2);
					recruit->namecreature();
					strcpy(recruit->name, recruit->propername);
					recruit->location = l;
					recruit->base = l;
					recruit->hireid = newcr->id;
					newsq->squad[i + 1] = recruit;
					recruit->squadid = newsq->id;
					addCreature(recruit);
				}
				break;
			}
			if (GIVEBLOODYARMOR) {
				Armor *newa = new Armor(getarmortype(tag_ARMOR_CLOTHES));
				newa->set_bloody(true);
				location[l]->loot.push_back(newa);
			}
			if (HIGHFUNDS) {
				ledger.force_funds(100000);
			}
			break;
		}
	}
	extern squadst *activesquad;
	//newcr->juice=0;
	squad.push_back(newsq);
	activesquad = newsq;
	if (makelawyer)
	{
		Creature* lawyer = new Creature;
		makecreature(*lawyer, CREATURE_LAWYER);
		// Make sure lawyer is of the appropriate gender for dating the main character;
		// opposite sex by default, same sex if the option was chosen that mentions
		// homosexuality
		if (gaylawyer)
		{
			lawyer->gender_conservative = lawyer->gender_liberal = newcr->gender_conservative;
			// neutral founder gets neutral partner
		}
		else
		{
			if (newcr->gender_conservative == GENDER_MALE)
				lawyer->gender_liberal = lawyer->gender_conservative = GENDER_FEMALE;
			if (newcr->gender_conservative == GENDER_FEMALE)
				lawyer->gender_liberal = lawyer->gender_conservative = GENDER_MALE;
			// neutral founder gets random partner
		}
		// Ensure the lawyer has good heart/wisdom stats
		if (lawyer->get_attribute(ATTRIBUTE_HEART, false) < newcr->get_attribute(ATTRIBUTE_HEART, false) - 2)
			lawyer->adjust_attribute(ATTRIBUTE_HEART, -2);
		lawyer->set_attribute(ATTRIBUTE_WISDOM, 1);
		lawyer->namecreature();
		lawyer->flag |= CREATUREFLAG_SLEEPER;
		lawyer->flag |= CREATUREFLAG_LOVESLAVE;
		lawyer->align = ALIGN_LIBERAL;
		lawyer->infiltration = 0.3f;
		lawyer->age = 28;
		location[lawyer->worklocation]->mapped = 1;
		lawyer->hireid = newcr->id;
		addCreature(lawyer);
		lawyer->location = lawyer->base = lawyer->worklocation;
	}
}
bool LocationsPool::locationPoolInitiated = false;
LocationsPool lPool;
LocationsPool LocationsPool::getInstance()
{
	if (!locationPoolInitiated) {
		lPool = LocationsPool();
		locationPoolInitiated = true;
	}
	return lPool;
}
const int LocationsPool::lenpool()
{
	return len(location);
}
const int LocationsPool::getLocationCity(int cursite) {
	return location[cursite]->city;
}
void LocationsPool::hideCCSSafehouses()
{
	// hide ccs safehouses
	for (int l = 0; l < lenpool(); l++)
	{
		if (getRentingType(l) == RENTING_CCS)
		{
			location[l]->renting = RENTING_NOCONTROL;
			location[l]->hidden = true;
		}
	}
}
void LocationsPool::addHeat(int cursite, int heat)
{
	location[cursite]->heat += heat;
}
#include "../common/equipment.h"
const void LocationsPool::findAllLootTypes(vector<bool>& havetype, vector<int>& loottypeindex, const vector<string>& dox)
{
	//FIND ALL LOOT TYPES
	for (int loc = 0; loc < LocationsPool::getInstance().lenpool(); loc++)
	{
		if (LocationsPool::getInstance().getRentingType(loc) == RENTING_NOCONTROL) continue;
		consolidateloot(location[loc]->loot);
		for (int l = 0; l < len(location[loc]->loot); l++)
		{
			if (!(location[loc]->loot[l]->whatIsThis() == THIS_IS_LOOT)) continue;
			if (!binary_search(dox.begin(), dox.end(), location[loc]->loot[l]->get_itemtypename())) continue;
			if (!havetype[getloottype(location[loc]->loot[l]->get_itemtypename())])
			{
				loottypeindex.push_back(getloottype(location[loc]->loot[l]->get_itemtypename()));
				havetype[getloottype(location[loc]->loot[l]->get_itemtypename())] = true;
			}
		}
	}
}
const bool LocationsPool::isLocationMapped(int cursite)
{
	return location[cursite]->mapped;
}
const bool LocationsPool::isLocationHidden(int cursite)
{
	return location[cursite]->hidden;
}
void LocationsPool::setLocationMappedAndUnhidden(int cursite)
{
	location[cursite]->mapped = 1;
	location[cursite]->hidden = 0;
}
const string LocationsPool::getLocationNameWithGetnameMethod(int cursite, signed char a) {
	return getLocationNameWithGetnameMethod(cursite, a, false);
}
const string LocationsPool::getLocationNameWithGetnameMethod(int cursite, signed char a, bool b)
{
	return location[cursite]->getname(a, b);
}
const int LocationsPool::getCompoundWalls(int cursite)
{
	return location[cursite]->compound_walls;
}
// Redundant, carelessly, worry later TODO
void LocationsPool::setTimeUntilSiege(int cursite, int time)
{
	LocationsPool::getInstance().setSiegetimeuntillocated(cursite, time);
}
const bool LocationsPool::isNewRental(int cursite)
{
	return location[cursite]->newrental;
}
#include "../common/creaturePool.h"
void LocationsPool::evictLCSFrom(int l)
{
	set_color_easy(WHITE_ON_BLACK_BRIGHT);
	mvaddstrAlt(8, 1, CONST_locationsPool035);
	addstrAlt(LocationsPool::getInstance().getLocationName(l));
	addstrAlt(CONST_locationsPool036);
 	pressAnyKey();
	location[l]->renting = RENTING_NOCONTROL;
	CreaturePool::getInstance().moveAllSquadMembers(l);
	int hs = find_site_index_in_same_city(SITE_RESIDENTIAL_SHELTER, l);
	location[hs]->getloot(location[l]->loot);
	location[l]->compound_walls = 0;
	location[l]->compound_stores = 0;
	location[l]->front_business = -1;
}
const int LocationsPool::isThisSiteClosed(int cursite)
{
	return location[cursite]->closed;
}
const char LocationsPool::doesThisPlaceNeedACar(int cursite)
{
	return location[cursite]->needcar;
}
const int LocationsPool::findTravelLocation()
{
	int travelLocation = -1;
	for (int i = 0; i < len(location); i++) {
		if (location[i]->type == SITE_TRAVEL)
		{
			travelLocation = i;
			break;
		}
	}
	return travelLocation;
}
const int LocationsPool::getLocationParent(int cursite)
{
	return location[cursite]->parent;
}
int LocationsPool::deleteSpecialItem(int slot, vector<int> loottypeindex)
{
	//DELETE THE ITEM
	for (int loc = 0; loc < LocationsPool::getInstance().lenpool(); loc++)
	{
		if (LocationsPool::getInstance().getRentingType(loc) == RENTING_NOCONTROL) continue;
		for (int l = 0; l < len(location[loc]->loot); l++)
		{
			if (!(location[loc]->loot[l]->whatIsThis() == THIS_IS_LOOT)) continue;
			if (getloottype(location[loc]->loot[l]->get_itemtypename()) == loottypeindex[slot])
			{
				location[loc]->loot[l]->decrease_number(1);
				if (location[loc]->loot[l]->empty())
					delete_and_remove(location[loc]->loot, l);
				return loottypeindex[slot];
			}
		}
	}
	return -1;
}
void LocationsPool::getAssetValues(long & weaponValue, long & armorValue, long & clipValue, long & lootValue)
{
	for (int j = 0; j < LocationsPool::getInstance().lenpool(); j++)
		for (int i = 0; i < len(location[j]->loot); i++)
		{
			Item* item = location[j]->loot[i];
			if (item->whatIsThis() == THIS_IS_WEAPON) weaponValue += item->get_fencevalue()*item->get_number();
			if (item->whatIsThis() == THIS_IS_ARMOR) armorValue += item->get_fencevalue()*item->get_number();
			if (item->whatIsThis() == THIS_IS_CLIP) clipValue += item->get_fencevalue()*item->get_number();
			if (item->whatIsThis() == THIS_IS_LOOT) lootValue += item->get_fencevalue()*item->get_number();
		}
}
const bool LocationsPool::canBeFortified(int cursite)
{
	return location[cursite]->can_be_fortified();
}
/* daily - seeds and names a site (will re-seed and rename if used after start) */
void initlocation(Location &loc);
void LocationsPool::initLocation(int cursite)
{
	initlocation(*location[cursite]);
}
#include "../items/lootTypePoolItem.h"
void LocationsPool::stashThisLootHere(const string& tag, int homes) {
	location[homes]->loot.push_back(getNewLoot(tag));
}
extern vector<WeaponType *> weapontype;
void LocationsPool::stashThisWeaponHere(int itemindex, int shelter) {
	location[shelter]->loot.push_back(new Weapon(*weapontype[itemindex]));
}
void LocationsPool::stashThisArmorHere(int itemindex, int shelter) {
	location[shelter]->loot.push_back(new Armor(itemindex));
}
void LocationsPool::equipLoc(int loc, int y)
{
	equip(location[loc]->loot, y);
}
void LocationsPool::delete_and_clear_pool()
{
	delete_and_clear(location);
}
const char LocationsPool::isThereASiegeHere(int cursite)
{
	return location[cursite]->siege.siege;
}
const int LocationsPool::isThisPlaceHighSecurity(int cursite)
{
	return location[cursite]->highsecurity;
}
void LocationsPool::isThereASiegeHere(int cursite, char newCondition)
{
	location[cursite]->siege.siege = newCondition;
}
void LocationsPool::isThisPlaceHighSecurity(int cursite, int newCondition)
{
	location[cursite]->highsecurity = newCondition;
}
const char LocationsPool::getLocationType(int cursite)
{
	return location[cursite]->type;
}
const short LocationsPool::getSiegeType(int cursite)
{
	return location[cursite]->siege.siegetype;
}
const short LocationsPool::getSiegeEscalationState(int cursite)
{
	return location[cursite]->siege.escalationstate;
}
const int LocationsPool::getRentingType(int cursite)
{
	return location[cursite]->renting;
}
//#include "sitemode/sitemode.h"
void initsite(Location &loc);
void LocationsPool::initSite(int loc)
{
	initsite(*location[loc]);
}
void LocationsPool::eraseAndReplaceGraffiti(int cursite, int locx, int locy, int locz)
{
	// Erase any previous semi-permanent graffiti here
	for (int i = 0; i < len(location[cursite]->changes); i++)
	{
		if ((location[cursite]->changes[i].x == locx) &&
			(location[cursite]->changes[i].y == locy) &&
			(location[cursite]->changes[i].z == locz) &&
			((location[cursite]->changes[i].flag == SITEBLOCK_GRAFFITI) ||
				(location[cursite]->changes[i].flag == SITEBLOCK_GRAFFITI_CCS) ||
				(location[cursite]->changes[i].flag == SITEBLOCK_GRAFFITI_OTHER)))
		{
			location[cursite]->changes.erase(location[cursite]->changes.begin() + i);
			break;
		}
	}
	// Add new semi-permanent graffiti
	struct sitechangest change(locx, locy, locz, SITEBLOCK_GRAFFITI);
	location[cursite]->changes.push_back(change);
}

const string LocationsPool::getLocationName(int cursite)
{
	return location[cursite]->getname();
}
#include "../common/commonactionsCreature.h"
extern squadst *activesquad;
extern vector<squadst *> squad;
/* common - purges empty squads from existence */
void cleangonesquads()
{
	for (int sq = len(squad) - 1; sq >= 0; sq--)
	{  //NUKE SQUAD IF IT IS GONE
		bool hasmembers = false;
		for (int p = 0; p < 6; p++)
			if (squad[sq]->squad[p] != NULL)
			{  // Let's do a bit of housekeeping here
			   // And see if we can't gracefully eliminate that
			   // pesky dead liberal in my squad bug
				if (squad[sq]->squad[p]->alive == false)
				{
					removesquadinfo(*squad[sq]->squad[p]);
					p = -1; // restart this for loop
				}
				else hasmembers = true;
			}
		if (!hasmembers)
		{  //SQUAD LOOT WILL BE DESTROYED
			if (activesquad == squad[sq]) activesquad = NULL;
			delete_and_remove(squad, sq);
		}
		//OTHERWISE YOU CAN TAKE ITS MONEY (and other gear)
		else location[squad[sq]->squad[0]->base]->getloot(squad[sq]->loot);
	}
}
//#include "pdcurses/curses.h"
extern string singleDot;
extern short interface_pgup;
extern short interface_pgdn;
// Prompt to turn new recruit into a sleeper
void sleeperize_prompt(Creature &converted, Creature &recruiter, int y)
{
	bool selection = false;
	while (true)
	{
		set_color_easy(WHITE_ON_BLACK);
		mvaddstrAlt(y, 0, CONST_locationsPool037);
		addstrAlt(converted.name);
		addstrAlt(CONST_locationsPool038);
		set_color_easy(selection ? WHITE_ON_BLACK : WHITE_ON_BLACK_BRIGHT);
		mvaddstrAlt(y + 2, 0, selection ? CONST_locationsPool039 : CONST_locationsPool043);
		addstrAlt(CONST_locationsPool040);
		addstrAlt(location[recruiter.location]->getname(-1, true));
		addstrAlt(CONST_locationsPool045);
		set_color_easy(selection ? GREEN_ON_BLACK : GREEN_ON_BLACK_BRIGHT);
		addstrAlt(CONST_locationsPool042);
		set_color_easy(selection ? WHITE_ON_BLACK : WHITE_ON_BLACK_BRIGHT);
		addstrAlt(singleDot);
		set_color_easy(selection ? WHITE_ON_BLACK_BRIGHT : WHITE_ON_BLACK);
		mvaddstrAlt(y + 3, 0, selection ? CONST_locationsPool043 : CONST_locationsPool039);
		addstrAlt(CONST_locationsPool044);
		addstrAlt(location[converted.worklocation]->getname(-1, true));
		addstrAlt(CONST_locationsPool045);
		set_color_easy(selection ? CYAN_ON_BLACK_BRIGHT : CYAN_ON_BLACK);
		addstrAlt(CONST_locationsPool046);
		set_color_easy(selection ? WHITE_ON_BLACK_BRIGHT : WHITE_ON_BLACK);
		addstrAlt(singleDot);
		int c = getkeyAlt();
		if ((c == 'x' || c == ENTER || c == ESC || c == SPACEBAR) && selection)
		{
			converted.flag |= CREATUREFLAG_SLEEPER;
			converted.location = converted.worklocation;
			location[converted.worklocation]->mapped = 1;
			location[converted.worklocation]->hidden = 0;
			converted.base = converted.worklocation;
			liberalize(converted, false);
			break;
		}
		else if ((c == 'x' || c == ENTER || c == ESC || c == SPACEBAR) && !selection)
		{
			converted.location = recruiter.location;
			converted.base = recruiter.base;
			liberalize(converted, false);
			break;
		}
		else if (c == interface_pgup || c == KEY_UP || c == KEY_LEFT ||
			c == interface_pgdn || c == KEY_DOWN || c == KEY_RIGHT) selection = !selection;
	}
}
extern bool multipleCityMode;
Location* find_site_in_city(int site_type, int city)
{
	int i = find_site_index_in_city(site_type, city);
	if (i != -1) return location[i];
	else return NULL;
}
int find_site_index_in_city(int site_type, int city)
{
	for (int i = 0; i<len(location); i++)
		if (location[i]->type == site_type && (!multipleCityMode || city == -1 || location[i]->city == city))
			return i;
	return -1;
}
int find_site_index_in_same_city(int site_type, int site_index)
{
	int city = -1;
	if (site_index >= 0) city = location[site_index]->city;
	return find_site_index_in_city(site_type, city);
}
void make_classic_world(bool hasmaps)
{
	Location* district = NULL;
	location.push_back(district = new Location(SITE_DOWNTOWN));
	district->area = 0;
	district->mapped = hasmaps; // for some reason this property isn't inherited by downtown locations so it's manually added for each one, need to debug why this happens
	district->addchild(SITE_RESIDENTIAL_APARTMENT_UPSCALE)->mapped = hasmaps;
	district->addchild(SITE_GOVERNMENT_POLICESTATION)->mapped = hasmaps;
	district->addchild(SITE_GOVERNMENT_COURTHOUSE)->mapped = hasmaps;
	district->addchild(SITE_BUSINESS_BANK)->mapped = hasmaps;
	district->addchild(SITE_GOVERNMENT_FIRESTATION)->mapped = hasmaps;
	district->addchild(SITE_MEDIA_AMRADIO)->mapped = hasmaps;
	district->addchild(SITE_MEDIA_CABLENEWS)->mapped = hasmaps;
	district->addchild(SITE_BUSINESS_CIGARBAR)->mapped = hasmaps;
	district->addchild(SITE_BUSINESS_LATTESTAND)->mapped = hasmaps;
	{
		Location* site = district->addchild(SITE_BUSINESS_BARANDGRILL);
		site->renting = RENTING_CCS;
		site->hidden = true;
		site->mapped = false;
	}
	location.push_back(district = new Location(SITE_COMMERCIAL));
	district->area = 0;
	district->addchild(SITE_BUSINESS_DEPTSTORE);
	district->addchild(SITE_BUSINESS_PAWNSHOP);
	district->addchild(SITE_BUSINESS_HALLOWEEN);
	district->addchild(SITE_BUSINESS_CARDEALERSHIP);
	
	location.push_back(district = new Location(SITE_UDISTRICT));
	district->area = 0;
	district->addchild(SITE_RESIDENTIAL_APARTMENT);
	district->addchild(SITE_HOSPITAL_UNIVERSITY);
	district->addchild(SITE_HOSPITAL_CLINIC);
	district->addchild(SITE_LABORATORY_GENETIC);
	district->addchild(SITE_LABORATORY_COSMETICS);
	district->addchild(SITE_BUSINESS_VEGANCOOP);
	district->addchild(SITE_BUSINESS_JUICEBAR);
	district->addchild(SITE_BUSINESS_INTERNETCAFE);
	district->addchild(SITE_OUTDOOR_PUBLICPARK);
	
	location.push_back(district = new Location(SITE_INDUSTRIAL));
	district->area = 0;
	district->addchild(SITE_RESIDENTIAL_SHELTER)->renting = RENTING_PERMANENT;
	{
		Location* site = district->addchild(SITE_INDUSTRY_WAREHOUSE);
		site->renting = RENTING_PERMANENT;
		site->upgradable = true;
	}
	district->addchild(SITE_RESIDENTIAL_TENEMENT);
	district->addchild(SITE_INDUSTRY_POLLUTER);
	district->addchild(SITE_INDUSTRY_SWEATSHOP);
	district->addchild(SITE_BUSINESS_CRACKHOUSE)->upgradable = true;
	{
		Location* site = district->addchild(SITE_RESIDENTIAL_BOMBSHELTER);
		site->renting = RENTING_CCS;
		site->hidden = true;
	}
	location.push_back(district = new Location(SITE_OUTOFTOWN));
	district->area = 1;
	district->addchild(SITE_GOVERNMENT_PRISON);
	district->addchild(SITE_GOVERNMENT_INTELLIGENCEHQ);
	district->addchild(SITE_INDUSTRY_NUCLEAR);
	district->addchild(SITE_CORPORATE_HEADQUARTERS);
	district->addchild(SITE_CORPORATE_HOUSE);
	district->addchild(SITE_GOVERNMENT_ARMYBASE);
	{
		Location* site = district->addchild(SITE_OUTDOOR_BUNKER);
		site->renting = RENTING_CCS;
		site->hidden = true;
	}
	location.push_back(district = new Location(SITE_TRAVEL));
	district->area = 1;
	district->addchild(SITE_GOVERNMENT_WHITE_HOUSE);
}
void make_world(bool hasmaps)
{
	if (!multipleCityMode)
	{
		make_classic_world(hasmaps);
		return;
	}
	//MAKE LOCATIONS
	Location* city = NULL;
	Location* district = NULL;
	//Location* site = NULL;
	location.push_back(city = new Location(SITE_CITY_SEATTLE));
	district = city->addchild(SITE_DOWNTOWN);
	district->area = 0;
	district->mapped = hasmaps; // for some reason this property isn't inherited by downtown locations so it's manually added for each one, need to debug why this happens
	district->addchild(SITE_RESIDENTIAL_APARTMENT_UPSCALE)->mapped = hasmaps;
	district->addchild(SITE_GOVERNMENT_POLICESTATION)->mapped = hasmaps;
	district->addchild(SITE_GOVERNMENT_COURTHOUSE)->mapped = hasmaps;
	district->addchild(SITE_BUSINESS_BANK)->mapped = hasmaps;
	district->addchild(SITE_GOVERNMENT_FIRESTATION)->mapped = hasmaps;
	district->addchild(SITE_MEDIA_AMRADIO)->mapped = hasmaps;
	district->addchild(SITE_BUSINESS_CIGARBAR)->mapped = hasmaps;
	district->addchild(SITE_BUSINESS_LATTESTAND)->mapped = hasmaps;
	district->addchild(SITE_BUSINESS_DEPTSTORE)->mapped = hasmaps;
	{
		Location* site = district->addchild(SITE_BUSINESS_BARANDGRILL);
		site->renting = RENTING_CCS;
		site->hidden = true;
		site->mapped = false;
	}
	district = city->addchild(SITE_UDISTRICT);
	district->area = 0;
	district->addchild(SITE_RESIDENTIAL_APARTMENT);
	district->addchild(SITE_HOSPITAL_UNIVERSITY);
	district->addchild(SITE_HOSPITAL_CLINIC);
	district->addchild(SITE_LABORATORY_GENETIC);
	district->addchild(SITE_LABORATORY_COSMETICS);
	district->addchild(SITE_BUSINESS_VEGANCOOP);
	district->addchild(SITE_BUSINESS_JUICEBAR);
	district->addchild(SITE_BUSINESS_INTERNETCAFE);
	district->addchild(SITE_OUTDOOR_PUBLICPARK);
	district->addchild(SITE_BUSINESS_HALLOWEEN);
	district = city->addchild(SITE_INDUSTRIAL);
	district->area = 0;
	district->addchild(SITE_RESIDENTIAL_SHELTER)->renting = RENTING_PERMANENT;
	{
		Location* site = district->addchild(SITE_INDUSTRY_WAREHOUSE);
		site->renting = RENTING_PERMANENT;
		site->upgradable = true;
	}
	district->addchild(SITE_RESIDENTIAL_TENEMENT);
	district->addchild(SITE_INDUSTRY_POLLUTER);
	district->addchild(SITE_INDUSTRY_SWEATSHOP);
	district->addchild(SITE_BUSINESS_CRACKHOUSE)->upgradable = true;
	district->addchild(SITE_BUSINESS_PAWNSHOP);
	district->addchild(SITE_BUSINESS_CARDEALERSHIP);
	district = city->addchild(SITE_OUTOFTOWN);
	district->area = 1;
	district->addchild(SITE_GOVERNMENT_PRISON);
	district->addchild(SITE_GOVERNMENT_INTELLIGENCEHQ);
	district->addchild(SITE_CORPORATE_HEADQUARTERS);
	district->addchild(SITE_GOVERNMENT_ARMYBASE);
	location.push_back(city = new Location(SITE_CITY_NEW_YORK));
	district = city->addchild(SITE_DOWNTOWN);
	district->area = 0;
	strcpy(district->name, tag_Manhattan_Island);
	strcpy(district->shortname, tag_Manhattan);
	
	district->addchild(SITE_RESIDENTIAL_APARTMENT_UPSCALE);
	district->addchild(SITE_GOVERNMENT_POLICESTATION);
	district->addchild(SITE_GOVERNMENT_COURTHOUSE);
	district->addchild(SITE_BUSINESS_BANK);
	district->addchild(SITE_CORPORATE_HEADQUARTERS);
	district->addchild(SITE_MEDIA_AMRADIO);
	district->addchild(SITE_MEDIA_CABLENEWS);
	district->addchild(SITE_BUSINESS_CIGARBAR);
	district->addchild(SITE_OUTDOOR_PUBLICPARK);
	district->addchild(SITE_BUSINESS_DEPTSTORE);
	district->addchild(SITE_GOVERNMENT_PRISON);
	district = city->addchild(SITE_UDISTRICT);
	district->area = 0;
	strcpy(district->name, tag_Brooklyn_ampersand_Queens);
	strcpy(district->shortname, tag_Long_Island);
	{
		Location* site = district->addchild(SITE_INDUSTRY_WAREHOUSE);
		site->renting = RENTING_PERMANENT;
		site->upgradable = true;
	}
	district->addchild(SITE_RESIDENTIAL_APARTMENT);
	district->addchild(SITE_GOVERNMENT_FIRESTATION);
	district->addchild(SITE_HOSPITAL_UNIVERSITY);
	district->addchild(SITE_HOSPITAL_CLINIC);
	district->addchild(SITE_BUSINESS_JUICEBAR);
	district->addchild(SITE_BUSINESS_INTERNETCAFE);
	district->addchild(SITE_INDUSTRY_POLLUTER);
	district->addchild(SITE_LABORATORY_GENETIC);
	district->addchild(SITE_GOVERNMENT_ARMYBASE);
	{
		Location* site = district->addchild(SITE_RESIDENTIAL_BOMBSHELTER);
		site->renting = RENTING_CCS;
		site->hidden = true;
	}
	district = city->addchild(SITE_INDUSTRIAL);
	district->area = 0;
	strcpy(district->name, tag_The_Bronx);
	strcpy(district->shortname, tag_The_Bronx);
	district->addchild(SITE_RESIDENTIAL_SHELTER)->renting = RENTING_PERMANENT;
	district->addchild(SITE_RESIDENTIAL_TENEMENT);
	district->addchild(SITE_INDUSTRY_POLLUTER);
	district->addchild(SITE_INDUSTRY_SWEATSHOP);
	district->addchild(SITE_LABORATORY_COSMETICS);
	district->addchild(SITE_BUSINESS_VEGANCOOP);
	district->addchild(SITE_BUSINESS_PAWNSHOP);
	district->addchild(SITE_BUSINESS_CARDEALERSHIP);
	district->addchild(SITE_BUSINESS_CRACKHOUSE)->upgradable = true;
	district->addchild(SITE_OUTDOOR_PUBLICPARK);
	district = city->addchild(SITE_OUTOFTOWN);
	district->area = 1;
	district->addchild(SITE_INDUSTRY_NUCLEAR);
	location.push_back(city = new Location(SITE_CITY_LOS_ANGELES));
	district = city->addchild(SITE_DOWNTOWN);
	district->area = 0;
	district->addchild(SITE_RESIDENTIAL_SHELTER)->renting = RENTING_PERMANENT;
	
	district->addchild(SITE_RESIDENTIAL_APARTMENT);
	district->addchild(SITE_GOVERNMENT_POLICESTATION);
	district->addchild(SITE_GOVERNMENT_COURTHOUSE);
	district->addchild(SITE_BUSINESS_BANK);
	district->addchild(SITE_GOVERNMENT_FIRESTATION);
	district->addchild(SITE_CORPORATE_HEADQUARTERS);
	district->addchild(SITE_HOSPITAL_UNIVERSITY);
	district->addchild(SITE_BUSINESS_DEPTSTORE);
	
	district = city->addchild(SITE_UDISTRICT);
	district->area = 0;
	strcpy(district->name, tag_Greater_Hollywood);
	strcpy(district->shortname, tag_Hollywood);
	district->addchild(SITE_RESIDENTIAL_APARTMENT_UPSCALE);	
	district->addchild(SITE_BUSINESS_VEGANCOOP);
	district->addchild(SITE_BUSINESS_HALLOWEEN);
	district->addchild(SITE_BUSINESS_CIGARBAR);
	district->addchild(SITE_MEDIA_AMRADIO);
	district->addchild(SITE_OUTDOOR_PUBLICPARK);
	district->addchild(SITE_CORPORATE_HOUSE);
	
	district = city->addchild(SITE_INDUSTRIAL);
	district->area = 0;
	strcpy(district->name, tag_Seaport_Area);
	strcpy(district->shortname, tag_Seaport);
	{
		Location* site = district->addchild(SITE_INDUSTRY_WAREHOUSE);
		site->renting = RENTING_PERMANENT;
		site->upgradable = true;
	}
	district->addchild(SITE_RESIDENTIAL_TENEMENT);
	district->addchild(SITE_HOSPITAL_CLINIC);
	district->addchild(SITE_LABORATORY_GENETIC);
	district->addchild(SITE_LABORATORY_COSMETICS);
	district->addchild(SITE_INDUSTRY_POLLUTER);
	district->addchild(SITE_BUSINESS_PAWNSHOP);
	district->addchild(SITE_INDUSTRY_SWEATSHOP);
	district->addchild(SITE_BUSINESS_CARDEALERSHIP);
	district->addchild(SITE_BUSINESS_CRACKHOUSE)->upgradable = true;
	district = city->addchild(SITE_OUTOFTOWN);
	district->area = 1;
	strcpy(district->name, tag_Outskirts_amp_Orange_County);
	district->addchild(SITE_GOVERNMENT_PRISON);
	district->addchild(SITE_INDUSTRY_NUCLEAR);
	district->addchild(SITE_GOVERNMENT_ARMYBASE);
	{
		Location* site = district->addchild(SITE_OUTDOOR_BUNKER);
		site->renting = RENTING_CCS;
		site->hidden = true;
	}
	location.push_back(city = new Location(SITE_CITY_WASHINGTON_DC));
	district = city->addchild(SITE_DOWNTOWN);
	district->area = 0;
	strcpy(district->name, tag_Downtown);
	district->addchild(SITE_GOVERNMENT_POLICESTATION);
	district->addchild(SITE_GOVERNMENT_FIRESTATION);
	district->addchild(SITE_GOVERNMENT_COURTHOUSE);
	district->addchild(SITE_BUSINESS_BANK);
	district->addchild(SITE_BUSINESS_CARDEALERSHIP);
	district->addchild(SITE_HOSPITAL_CLINIC);
	district->addchild(SITE_HOSPITAL_UNIVERSITY);
	district->addchild(SITE_BUSINESS_DEPTSTORE);
	district->addchild(SITE_RESIDENTIAL_SHELTER)->renting = RENTING_PERMANENT;
	district = city->addchild(SITE_UDISTRICT);
	district->area = 0;
	strcpy(district->name, tag_National_Mall);
	strcpy(district->shortname, CONST_locationsPool047);
	district->addchild(SITE_OUTDOOR_PUBLICPARK);
	district->addchild(SITE_GOVERNMENT_WHITE_HOUSE);
	district = city->addchild(SITE_OUTOFTOWN);
	district->area = 1;
	strcpy(district->name, tag_Arlington);
	district->addchild(SITE_GOVERNMENT_PRISON);
	district->addchild(SITE_GOVERNMENT_INTELLIGENCEHQ);
	district->addchild(SITE_GOVERNMENT_ARMYBASE);
}
// Finds a location with the corresponding type and returns
// its index in the location array
int findlocation(int type, int city = -1)
{
	if (!multipleCityMode) city = -1;
	for (int i = 0; i < len(location); i++)
		if (location[i]->type == type && (location[i]->city == city || city == -1)) return i;
	return -1;
}
// Locations - Construct a new location with the specified parameters
#include "../daily/daily.h"
Location::Location(char type_, int parent_)
	: type(type_), city(-1), parent(parent_), renting(RENTING_NOCONTROL), needcar(false), hidden(false), upgradable(false)
{
	if (this->parent != -1)
	{
		this->needcar = location[this->parent]->needcar;
		this->mapped = location[this->parent]->mapped;
		this->area = location[this->parent]->area;
		this->city = location[this->parent]->city;
	}
	if (this->city < 0 && multipleCityMode)
		this->city = this->type;
	initlocation(*this);
}
Location* Location::addchild(char type_)
{
	Location *newloc = new Location(type_, findlocation(this->type, this->city));
	location.push_back(newloc);
	return newloc;
}
/* Settings for shortname_ (true is 1 and false is 0, by the way):
* -1: entire name is long, no matter what
*  0: first part of place name is long, and if there's a city at the end it's short
*  1: first part of the name is short unless the place itself is a city in which case it's long, and if there's a city at the end it's short
*  2: entire name is short, no matter what */
extern string singleSpace;
extern string commaSpace;
string Location::getname(signed char shortname_, bool include_city)
{
	string str;
	if (!multipleCityMode) include_city = false;
	if ((shortname_ >= 1 && type != city) || shortname_ >= 2) {
		if (this->front_business != -1)
			str = this->front_shortname;
		else
			str = this->shortname;
	}
	else {
		if (this->front_business != -1)
			str = this->front_name;
		else
			str = this->name;
	}
	if (include_city&&type != city) {
		string cityname = location[findlocation(city, city)]->getname(shortname_ + 2);
		if (str == tag_Downtown)
			return str + singleSpace + cityname;
		if (str == tag_University_District || str == tag_u_District || str == tag_Industrial_District || str == tag_i_District ||
			str == tag_Shopping || str == tag_Outskirts || str == tag_Seaport_Area || str == tag_Seaport || str == tag_Outskirts_amp_Orange_County)
			return cityname + singleSpace + str;
		if (str == tag_City_Outskirts)
			return cityname + CONST_locationsPool048;
		if (str == tag_Arlington)
			return str + (shortname_ < 0 ? CONST_locationsPool049 : CONST_locationsPoolB144);
		if (str == tag_Hollywood || str == tag_Greater_Hollywood)
			return str + (shortname_ < 0 ? CONST_locationsPool050 : CONST_locationsPoolB145);
		if (str == tag_Manhattan || str == tag_Manhattan_Island || str == tag_Brooklyn_ampersand_Queens || str == tag_Long_Island || str == tag_The_Bronx)
			return str + (shortname_ < 0 ? CONST_locationsPool051 : CONST_locationsPoolB146);
		str += commaSpace + cityname;
	}
	return str;
}
bool Location::duplicatelocation()
{
	for (int l = 0; l < len(location); l++)
	{
		if (location[l] == this)
			continue;
		if (type != SITE_RESIDENTIAL_SHELTER&&!strcmp(location[l]->name, this->name))
			return true;
		if (location[l]->front_business != -1 && this->front_business != -1 &&
			!strcmp(location[l]->front_shortname, this->front_shortname))
			return true;
	}
	return 0;
}
extern short lawList[LAWNUM];
void Location::update_heat_protection()
{
	int l;
	for (l = 0; l < len(location); l++)
	{
		if (location[l] == this)
			break;
	}
	if (l == len(location))
	{
		heat_protection = 0;
		return;
	}
	int numpres = CreaturePool::getInstance().howManyLivingPeopleAreHere(l);
	heat_protection = 0;
	// Determine how effective your current safehouse
	// is at keeping the police confused
	switch (location[l]->type)
	{
	case SITE_INDUSTRY_WAREHOUSE:
		if (location[l]->front_business != -1)
			heat_protection += 12; // Business front -- high protection
		else
			heat_protection += 0; // Abandoned warehouse -- no protection
		break;
	case SITE_RESIDENTIAL_SHELTER:
		heat_protection += 0; // Homeless shelter -- no protection
		break;
	case SITE_RESIDENTIAL_TENEMENT:
		heat_protection += 4; // Lower class housing -- low protection
		break;
	case SITE_RESIDENTIAL_APARTMENT:
		heat_protection += 8; // Middle class housing -- medium protection
		break;
	case SITE_RESIDENTIAL_BOMBSHELTER:
	case SITE_OUTDOOR_BUNKER:
	case SITE_BUSINESS_BARANDGRILL:
	case SITE_RESIDENTIAL_APARTMENT_UPSCALE:
		heat_protection += 12; // Upper class housing -- high protection
		break;
	}
	if (lawList[LAW_FLAGBURNING] == -2 && location[l]->haveflag) heat_protection += 6; // More protection if the flag is sacred
	else if (lawList[LAW_FLAGBURNING] != -2 && location[l]->haveflag) heat_protection += 2; // Some if the flag isn't
	else if (lawList[LAW_FLAGBURNING] == -2 && !(location[l]->haveflag)) heat_protection -= 2; // Lose some if it is and you have no flag
	else {} // None if it isn't and you have no flag
	if (heat_protection < 0) heat_protection = 0;
	heat_protection *= 5;
	if (heat_protection > 95) heat_protection = 95;
}
map<short, string> getActivityString;
std::string getactivity(ActivityST &act)
{
	extern vector<ArmorType *> armortype;
	if (getActivityString.count(act.type)) {
		return getActivityString[act.type];
	}
	else
		switch (act.type)
		{
		case ACTIVITY_HOSTAGETENDING:
		{
			std::string str = CONST_locationsPool052;
			int pl = getpoolcreature(act.arg);
			if (pl != -1) return str + CreaturePool::getInstance().getName(pl);
			else return str + CONST_locationsPool053;
		}
		case ACTIVITY_MAKE_ARMOR:
			return CONST_locationsPool054 + armortype[act.arg]->get_shortname();
		case ACTIVITY_VISIT:
			return CONST_locationsPool055 + location[act.arg]->getname(!location[act.arg]->is_city());
		default:
			return CONST_locationsPool056;
		}
}
/* daily - manages too hot timer and when a site map should be re-seeded and renamed */
void advancelocations()
{
	//ADVANCE LOCATIONS
	for (int l = 0; l < len(location); l++)
	{
		if (location[l]->closed > 0)
		{
			location[l]->closed--;
			if (location[l]->closed == 0)
			{  //Clean up graffiti, patch up walls, restore fire damage
				location[l]->changes.clear();
				//If high security is supported, chance to throw guards everywhere
				if (securityable(location[l]->type) && LCSrandom(2))
					location[l]->highsecurity = 60;
				//Else remodel the location, invalidate maps
				else initlocation(*location[l]);
			}
		}
		else if (location[l]->highsecurity > 0)
		{  // Bank will remain on high security much longer
			if (location[l]->type != SITE_BUSINESS_BANK)
				location[l]->highsecurity--;
			else if (!LCSrandom(5))
				location[l]->highsecurity--;
		}
	}
}
bool Creature::is_imprisoned() const
{
	return(alive && clinic == 0 && dating == 0 && hiding == 0 &&
		!(flag & CREATUREFLAG_SLEEPER) &&
		::location[this->location]->part_of_justice_system());
}
bool Creature::is_active_liberal() const
{
	return(alive && align == ALIGN_LIBERAL && clinic == 0 && dating == 0 &&
		hiding == 0 && !(flag & CREATUREFLAG_SLEEPER) &&
		!::location[this->location]->part_of_justice_system());
}
/* prompt user to enter an amount of items to equip, move, or sell */
long prompt_amount(long min, long max)
{
	printparty();
	set_color_easy(WHITE_ON_BLACK_BRIGHT);
	mvaddstrAlt(8, 15, CONST_locationsPool057);
	char str[100];
	enter_name(8, 30, str, 100, toCstring(max));
	int amount = atoi(str);
	amount = std::max((long)amount, min);
	amount = std::min((long)amount, max);
	return amount;
}
extern string spaceDashSpace;
extern string enter_done;
extern string chooseALiberalTo;
/* review squad equipment */
void equip(vector<Item *> &loot, int loc)
{
	if (activesquad == NULL) return;
	consolidateloot(loot);
	if (loc != -1) consolidateloot(location[loc]->loot);
	int page = 0;
	const char *errmsg = NULL;
	while (true)
	{
		eraseAlt();
		set_color_easy(WHITE_ON_BLACK);
		mvaddstrAlt(0, 0, CONST_locationsPool058);
		printparty();
		if (errmsg) {
			set_color_easy(CYAN_ON_BLACK_BRIGHT);
			mvaddstrAlt(8, 20, errmsg);
			set_color_easy(WHITE_ON_BLACK);
			errmsg = NULL;
		}
		int x = 1, y = 10;
		char str[200];
		//char str2[200];
		for (int l = page * 18; l < len(loot) && l < page * 18 + 18; l++)
		{
			string s = loot[l]->equip_title();
			if (loot[l]->get_number() > 1)
				s += CONST_locationsPool059 + tostring(loot[l]->get_number());
			str[0] = l - page * 18 + 'A';
			str[1] = '\x0';
			strcat(str, spaceDashSpace);
			strcat(str, s);
			mvaddstrAlt(y, x, str);
			x += 26;
			if (x > 53) x = 1, y++;
		}
		//PAGE UP
		if (page > 0)
		{
			mvaddstrAlt(17, 1, addprevpagestr());
		}
		//PAGE DOWN
		if ((page + 1) * 18 < len(loot))
		{
			mvaddstrAlt(17, 53, addnextpagestr());
		}
		set_color_easy(WHITE_ON_BLACK);
		mvaddstrAlt(19, 1, CONST_locationsPool060);
		mvaddstrAlt(20, 1, CONST_locationsPool061);
		mvaddstrAlt(21, 1, CONST_locationsPool062);
		mvaddstrAlt(22, 1, CONST_locationsPool063);
		if (loc != -1)
		{
			if (len(location[loc]->loot)) set_color_easy(WHITE_ON_BLACK);
			else set_color_easy(BLACK_ON_BLACK_BRIGHT);
			mvaddstrAlt(23, 1, CONST_locationsPool064);
			addstrAlt(location[loc]->getname(true));
			if (len(loot)) set_color_easy(WHITE_ON_BLACK);
			else set_color_easy(BLACK_ON_BLACK_BRIGHT);
			mvaddstrAlt(23, 40, CONST_locationsPool065);
			addstrAlt(location[loc]->getname(true));
		}
		set_color_easy(WHITE_ON_BLACK);
		mvaddstrAlt(24, 1, enter_done);
		int c = getkeyAlt();
		bool increaseammo = (c == KEY_UP), decreaseammo = (c == KEY_DOWN);
		if ((c >= 'a'&&c <= 'r') || increaseammo || decreaseammo)
		{
			int slot = c - 'a' + page * 18;
			if (increaseammo || decreaseammo) slot = -999;
			else
			{
				if (slot < 0 || slot >= len(loot)) continue; // Out of range.
				else if (!(loot[slot]->whatIsThis() == THIS_IS_WEAPON)
					&& !(loot[slot]->whatIsThis() == THIS_IS_ARMOR)
					&& !(loot[slot]->whatIsThis() == THIS_IS_CLIP))
				{
					errmsg = CONST_locationsPool066.c_str();
					continue;
				}
			}
			bool choice = true;
			if (activesquad->squad[0])
			{
				choice = false;
				for (int c = 1; c < 6; c++)
					if (activesquad->squad[c]) //are these slots always filled in order?
					{
						choice = true;
						break;
					}
			}
			int c = '1';
			if (choice)
			{
				set_color_easy(WHITE_ON_BLACK_BRIGHT);
				moveAlt(8, 20);
				if (increaseammo)
					addstrAlt(chooseALiberalTo + CONST_locationsPool067);
				else if (decreaseammo)
					addstrAlt(chooseALiberalTo + CONST_locationsPool068);
				else addstrAlt(chooseALiberalTo + CONST_locationsPool069);
				c = getkeyAlt();
			}
			if (c >= '1'&&c <= '6')
			{
				// TODO Relocate this to a new file
				// to allow removal of creature.h
				Creature *squaddie = activesquad->squad[c - '1'];
				if (squaddie)
				{
					if (decreaseammo)
					{
						if (len(squaddie->clips))
						{
							loot.push_back(squaddie->clips.back()->split(1));
							if (squaddie->clips.back()->empty())
								squaddie->clips.pop_back();
						}
						else if (!squaddie->get_weapon().uses_ammo())
						{
							errmsg = CONST_locationsPool070.c_str();
							continue;
						}
						else
						{
							errmsg = CONST_locationsPool071.c_str();
							continue;
						}
						consolidateloot(loot);
						continue;
					}
					if (increaseammo)
					{
						if (!squaddie->get_weapon().uses_ammo())
						{
							errmsg = CONST_locationsPool072.c_str();
							continue;
						}
						slot = -1;
						for (int sl = 0; sl < len(loot); sl++)
						{
							if (loot[sl]->whatIsThis() == THIS_IS_CLIP && squaddie->get_weapon().acceptable_ammo(*loot[sl]))
							{
								slot = sl;
								break;
							}
							else if (loot[sl]->whatIsThis() == THIS_IS_WEAPON && loot[sl]->is_same_type(squaddie->get_weapon())) //For throwing weapons. -XML
							{
								Weapon* w = static_cast<Weapon*>(loot[sl]); //cast -XML
								if (w->is_throwable())
								{
									slot = sl;
									break;
								}
							}
						}
						if (slot == -1)
						{
							errmsg = CONST_locationsPool073.c_str();
							continue;
						}
					}
					int armok = 2;
					if ((squaddie->wound[BODYPART_ARM_RIGHT] & WOUND_NASTYOFF) ||
						(squaddie->wound[BODYPART_ARM_RIGHT] & WOUND_CLEANOFF)) armok--;
					if ((squaddie->wound[BODYPART_ARM_LEFT] & WOUND_NASTYOFF) ||
						(squaddie->wound[BODYPART_ARM_LEFT] & WOUND_CLEANOFF)) armok--;
					if (squaddie->special[SPECIALWOUND_NECK] != 1) armok = 0;
					if (squaddie->special[SPECIALWOUND_UPPERSPINE] != 1) armok = 0;
					if (loot[slot]->whatIsThis() == THIS_IS_WEAPON && armok)
					{
						Weapon* w = static_cast<Weapon*>(loot[slot]); //cast -XML
						squaddie->give_weapon(*w, &loot);
						if (loot[slot]->empty()) delete_and_remove(loot, slot);
						if (page * 18 >= len(loot) && page != 0) page--;
					}
					else if (loot[slot]->whatIsThis() == THIS_IS_ARMOR)
					{
						Armor* a = static_cast<Armor*>(loot[slot]); //cast -XML
						squaddie->give_armor(*a, &loot);
						if (loot[slot]->empty()) delete_and_remove(loot, slot);
						if (page * 18 >= len(loot) && page != 0) page--;
					}
					else if (loot[slot]->whatIsThis() == THIS_IS_CLIP && armok)
					{
						int space = 9 - squaddie->count_clips();
						if (!squaddie->get_weapon().uses_ammo())
						{
							errmsg = CONST_locationsPool074.c_str(); continue;
						}
						else if (!squaddie->get_weapon().acceptable_ammo(*loot[slot]))
						{
							errmsg = CONST_locationsPool075.c_str(); continue;
						}
						else if (space < 1)
						{
							errmsg = CONST_locationsPool076.c_str(); continue;
						}
						else
						{
							int amount = 1;
							if (loot[slot]->get_number()>1 && !increaseammo)
								amount = prompt_amount(0, min((int)loot[slot]->get_number(), space));
							squaddie->take_clips(*loot[slot], amount);
							if (loot[slot]->empty()) delete_and_remove(loot, slot);
							if (page * 18 >= len(loot) && page != 0) page--;
						}
					}
					consolidateloot(loot);
				}
			}
		}
		if (c == 's')
		{
			bool choice = true;
			if (activesquad->squad[0])
			{
				choice = false;
				for (int c = 1; c < 6; c++)
					if (activesquad->squad[c])
					{
						choice = true; break;
					}
			}
			int c = '1';
			if (choice)
			{
				set_color_easy(WHITE_ON_BLACK_BRIGHT);
				mvaddstrAlt(8, 20, chooseALiberalTo + CONST_locationsPool077);
				c = getkeyAlt();
			}
			if (c >= '1'&&c <= '6')
				if (activesquad->squad[c - '1'])
				{
					activesquad->squad[c - '1']->strip(&loot);
					consolidateloot(loot);
				}
		}
		if (c == 'x' || c == ENTER || c == ESC || c == SPACEBAR) return;
		if (loc != -1)
		{
			if (c == 'y'&&len(location[loc]->loot)) moveloot(loot, location[loc]->loot);
			if (c == 'z'&&len(loot)) moveloot(location[loc]->loot, loot);
		}
		if (c >= '1'&&c <= '6')
		{
			int p = c - '1';
			if (activesquad->squad[p] != NULL)
			{
				activesquad->squad[p]->drop_weapons_and_clips(&loot);
				consolidateloot(loot);
			}
		}
		//PAGE UP
		if ((c == interface_pgup || c == KEY_UP || c == KEY_LEFT) && page>0) page--;
		//PAGE DOWN
		if ((c == interface_pgdn || c == KEY_DOWN || c == KEY_RIGHT) && (page + 1) * 18<len(loot)) page++;
	}
}
/* lets you pick stuff to stash/retrieve from one location to another */
void moveloot(vector<Item *> &dest, vector<Item *> &source)
{
	int page = 0;
	vector<int> selected(len(source), 0);
	while (true)
	{
		eraseAlt();
		set_color_easy(WHITE_ON_BLACK);
		mvaddstrAlt(0, 0, CONST_locationsPool078);
		printparty();
		int x = 1, y = 10;
		char str[200];
		for (int l = page * 18; l < len(source) && l < page * 18 + 18; l++)
		{
			if (selected[l]) set_color_easy(GREEN_ON_BLACK_BRIGHT);
			else set_color_easy(WHITE_ON_BLACK);
			string s = source[l]->equip_title();
			if (source[l]->get_number() > 1)
			{
				s += singleSpace;
				if (selected[l] > 0) s += tostring(selected[l]) + CONST_locationsPool079;
				else s += CONST_locationsPool080;
				s += tostring(source[l]->get_number());
			}
			str[0] = l - page * 18 + 'A';
			str[1] = '\x0';
			strcat(str, spaceDashSpace);
			strcat(str, s);
			mvaddstrAlt(y, x, str);
			x += 26;
			if (x > 53) x = 1, y++;
		}
		//PAGE UP
		set_color_easy(WHITE_ON_BLACK);
		if (page > 0)
		{
			mvaddstrAlt(17, 1, addprevpagestr());
		}
		//PAGE DOWN
		if ((page + 1) * 18 < len(source))
		{
			mvaddstrAlt(17, 53, addnextpagestr());
		}
		set_color_easy(WHITE_ON_BLACK);
		mvaddstrAlt(23, 1, CONST_locationsPool081);
		mvaddstrAlt(24, 1, enter_done);
		int c = getkeyAlt();
		if (c >= 'a'&&c <= 'r')
		{
			int slot = c - 'a' + page * 18;
			if (slot >= 0 && slot < len(source))
			{
				if (selected[slot]) selected[slot] = 0;
				else if (source[slot]->get_number()>1)
					selected[slot] = prompt_amount(0, source[slot]->get_number());
				else selected[slot] = 1;
			}
		}
		if (c == 'x' || c == ENTER || c == ESC || c == SPACEBAR) break;
		//PAGE UP
		if ((c == interface_pgup || c == KEY_UP || c == KEY_LEFT) && page>0) page--;
		//PAGE DOWN
		if ((c == interface_pgdn || c == KEY_DOWN || c == KEY_RIGHT) && (page + 1) * 18<len(source)) page++;
	}
	for (int l = len(source) - 1; l >= 0; l--) if (selected[l] > 0)
	{
		if (source[l]->get_number() <= selected[l])
		{
			dest.push_back(source[l]);
			source.erase(source.begin() + l);
		}
		else
		{
			Item* newit = source[l]->split(selected[l]);
			dest.push_back(newit);
		}
	}
	// Avoid stuff jumping around the next time you equip.
	consolidateloot(dest);
}
/* equipment - assign new bases to the equipment */
void equipmentbaseassign()
{
	int page_loot = 0, page_loc = 0, selectedbase = 0;
	bool sortbytype = false;
	vector<Item *> temploot;
	map<Item *, Location *> temploot2;
	for (int l = 0; l < len(location); l++) for (int l2 = 0; l2 < len(location[l]->loot); l2++)
		if (!location[l]->siege.siege)
		{
			temploot.push_back(location[l]->loot[l2]);
			temploot2[location[l]->loot[l2]] = location[l];
		}
	if (!len(temploot)) return;
	vector<int> temploc;
	for (int l = 0; l < len(location); l++) if (location[l]->renting >= 0 && !location[l]->siege.siege)
		temploc.push_back(l);
	if (!len(temploc)) return;
	while (true)
	{
		eraseAlt();
		set_color_easy(WHITE_ON_BLACK);
		printfunds();
		mvaddstrAlt(0, 0, CONST_locationsPool082);
		mvaddstrAlt(1, 0, CONST_locationsPool083);
		mvaddstrAlt(1, 51, CONST_locationsPool084);
		for (int p = page_loot * 19, y = 2; p < len(temploot) && p < page_loot * 19 + 19; p++, y++)
		{
			set_color_easy(WHITE_ON_BLACK);
			moveAlt(y, 0);
			addcharAlt(y + 'A' - 2); addstrAlt(spaceDashSpace);
			addstrAlt(temploot[p]->equip_title());
			mvaddstrAlt(y, 25, temploot2[temploot[p]]->getname(true, true));
		}
		for (int p = page_loc * 9, y = 2; p < len(temploc) && p < page_loc * 9 + 9; p++, y++)
		{
			if (p == selectedbase)set_color_easy(WHITE_ON_BLACK_BRIGHT);
			else set_color_easy(WHITE_ON_BLACK);
			moveAlt(y, 51);
			addcharAlt(y + '1' - 2); addstrAlt(spaceDashSpace);
			addstrAlt(location[temploc[p]]->getname(true, true));
		}
		set_color_easy(WHITE_ON_BLACK);
		mvaddstrAlt(22, 0, CONST_locationsPool085);
		moveAlt(23, 0);
		if (sortbytype) addstrAlt(CONST_locationsPool086);
		else addstrAlt(CONST_locationsPool087);
		addstrAlt(CONST_locationsPool088);
		moveAlt(24, 0); // location for either viewing other base pages or loot pages
		if (len(temploc) > 9)
		{
			addstrAlt(CONST_locationsPool089);
			moveAlt(24, 34); // we have base pages, so different location for viewing other loot pages
		}
		if (len(temploot) > 19)
			addstrAlt(addpagestr());
		int c = getkeyAlt();
		//PAGE UP (items)
		if ((c == interface_pgup || c == KEY_UP || c == KEY_LEFT) && page_loot>0) page_loot--;
		//PAGE DOWN (items)
		if ((c == interface_pgdn || c == KEY_DOWN || c == KEY_RIGHT) && (page_loot + 1) * 19<len(temploot)) page_loot++;
		//PAGE UP (locations)
		if (c == ','&&page_loc > 0) page_loc--;
		//PAGE DOWN (locations)
		if (c == '.' && (page_loc + 1) * 9 < len(temploc)) page_loc++;
		//Toggle sorting method
		if (c == 't')
		{
			sortbytype = !sortbytype;
			if (sortbytype) sort(temploot.begin(), temploot.end(), Item::sort_compare);
			else
			{  //Sort by location
				temploot.clear();
				for (int l = 0; l < len(location); l++) for (int l2 = 0; l2 < len(location[l]->loot); l2++)
					if (!location[l]->siege.siege) temploot.push_back(location[l]->loot[l2]);
			}
		}
		if (c >= 'a'&&c <= 's')
		{
			int p = page_loot * 19 + c - 'a';
			if (p < len(temploot))
				// Search through the old base's stuff for this item
				for (int l2 = 0; l2 < len(temploot2[temploot[p]]->loot); l2++)
					// Remove it from that inventory and move it to the new one
					if (temploot2[temploot[p]]->loot[l2] == temploot[p])
					{
						temploot2[temploot[p]]->loot.erase(temploot2[temploot[p]]->loot.begin() + l2);
						location[temploc[selectedbase]]->loot.push_back(temploot[p]);
						temploot2[temploot[p]] = location[temploc[selectedbase]];
					}
		}
		if (c >= '1'&&c <= '9')
		{
			int p = page_loc * 9 + c - '1';
			if (p < len(temploc)) selectedbase = p;
		}
		// Check if the player wants to move all items to a new location,
		// using Shift + a number key.
		const char upnums[] = "!@#$%^&*(";
		for (int upnumi = 0; upnumi < len(upnums); upnumi++)
		{
			if (c == upnums[upnumi])
			{
				// Set base location
				int basechoice = page_loc * 9 + upnumi;
				if (basechoice < len(temploc))
				{
					selectedbase = basechoice;
					// Search through the old base's stuff for this item
					for (int p = 0; p < len(temploot); p++)
						// Search through the old base's stuff for this item
						for (int l2 = 0; l2 < len(temploot2[temploot[p]]->loot); l2++)
							// Remove it from that inventory and move it to the new one
							if (temploot2[temploot[p]]->loot[l2] == temploot[p])
							{
								temploot2[temploot[p]]->loot.erase(temploot2[temploot[p]]->loot.begin() + l2);
								location[temploc[selectedbase]]->loot.push_back(temploot[p]);
								temploot2[temploot[p]] = location[temploc[selectedbase]];
							}
				}
			}
		}
		if (c == 'x' || c == ENTER || c == ESC || c == SPACEBAR) break;
	}
}
/* combines multiple items of the same type into stacks */
void consolidateloot(vector<Item *> &loot)
{
	//PUT THINGS TOGETHER
	for (int l = len(loot) - 1; l >= 1; l--) for (int l2 = l - 1; l2 >= 0; l2--)
	{
		loot[l2]->merge(*loot[l]);
		if (loot[l]->empty())
		{
			delete_and_remove(loot, l); break;
		}
	}
	sort(loot.begin(), loot.end(), Item::sort_compare);
}
/* check if the squad has a certain weapon */
char squadhasitem(squadst &sq, const string& type)
{
	if (getweapontype(type) == -1) return 0;
	for (int p = 0; p < 6; p++) if (sq.squad[p])
		if (sq.squad[p]->get_weapon().get_itemtypename() == type) return 1;
	for (int l = 0; l < len(sq.loot); l++)
	{
		if (sq.loot[l]->get_itemtypename() != type) continue;
		if (sq.loot[l]->whatIsThis() == THIS_IS_WEAPON && sq.loot[l]->get_itemtypename() == type) return 1;
	}
	return 0;
}
#include "../daily/siege.h"
/* location info at top of screen */
void printlocation(long loc)
{
	if (location[loc]->siege.siege)
	{
		if (!location[loc]->siege.underattack)
		{
			set_color_easy(YELLOW_ON_BLACK_BRIGHT);
			mvaddstrAlt(2, 1, CONST_locationsPool091);
		}
		else
		{
			set_color_easy(RED_ON_BLACK_BRIGHT);
			switch (location[loc]->siege.siegetype)
			{
			case SIEGE_POLICE:
				mvaddstrAlt(2, 1, CONST_locationsPool092); break;
			case SIEGE_CIA:
				mvaddstrAlt(2, 1, CONST_locationsPool093); break;
			case SIEGE_HICKS:
				mvaddstrAlt(2, 1, CONST_locationsPool094); break;
			case SIEGE_CORPORATE:
				mvaddstrAlt(2, 1, CONST_locationsPool095); break;
			case SIEGE_CCS:
				mvaddstrAlt(2, 1, CONST_locationsPool096); break;
			case SIEGE_FIREMEN:
				mvaddstrAlt(2, 1, CONST_locationsPool097); break;
			}
		}
	}
	else
	{
		set_color_easy(WHITE_ON_BLACK);
		mvaddstrAlt(2, 1, CONST_locationsPool098);
	}
	if (location[loc]->can_be_upgraded())
	{
		if (numbereating(loc)>0)
		{
			if (fooddaysleft(loc))
			{
				if (fooddaysleft(loc)<4)
				{
					if (!location[loc]->siege.siege)set_color_easy(WHITE_ON_BLACK);
					else set_color_easy(YELLOW_ON_BLACK_BRIGHT);
					mvaddstrAlt(3, 1, CONST_locationsPool099);
				}
			}
			else
			{
				if (!location[loc]->siege.siege)set_color_easy(WHITE_ON_BLACK);
				else set_color_easy(RED_ON_BLACK_BRIGHT);
				mvaddstrAlt(3, 1, CONST_locationsPool100);
			}
		}
		if (location[loc]->compound_walls & COMPOUND_BASIC)
		{
			set_color_easy(WHITE_ON_BLACK_BRIGHT);
			mvaddstrAlt(4, 1, CONST_locationsPool101);
		}
		if (location[loc]->compound_walls & COMPOUND_PRINTINGPRESS)
		{
			set_color_easy(BLUE_ON_BLACK_BRIGHT);
			mvaddstrAlt(4, 31, CONST_locationsPool102);
		}
		if (location[loc]->front_business != -1)
		{
			set_color_easy(MAGENTA_ON_BLACK_BRIGHT);
			mvaddstrAlt(4, 54, CONST_locationsPool103);
		}
		if (location[loc]->compound_walls & COMPOUND_CAMERAS)
		{
			if (location[loc]->siege.siege&&location[loc]->siege.cameras_off)
			{
				set_color_easy(RED_ON_BLACK);
				mvaddstrAlt(5, 1, CONST_locationsPool104);
			}
			else
			{
				set_color_easy(GREEN_ON_BLACK_BRIGHT);
				mvaddstrAlt(5, 1, CONST_locationsPool105);
			}
		}
		if (location[loc]->compound_walls & COMPOUND_TRAPS)
		{
			set_color_easy(RED_ON_BLACK_BRIGHT);
			mvaddstrAlt(5, 16, CONST_locationsPool106);
		}
		if (location[loc]->compound_walls & COMPOUND_AAGUN)
		{
			set_color_easy(CYAN_ON_BLACK_BRIGHT);
			mvaddstrAlt(5, 33, CONST_locationsPool107);
		}
		if (location[loc]->compound_walls & COMPOUND_TANKTRAPS)
		{
			set_color_easy(YELLOW_ON_BLACK_BRIGHT);
			mvaddstrAlt(5, 46, CONST_locationsPool108);
		}
		if (location[loc]->siege.siege&&location[loc]->siege.lights_off)
		{
			set_color_easy(WHITE_ON_BLACK);
			mvaddstrAlt(5, 60, CONST_locationsPool109);
		}
		else if (location[loc]->compound_walls & COMPOUND_GENERATOR)
		{
			set_color_easy(WHITE_ON_BLACK_BRIGHT);
			mvaddstrAlt(5, 61, CONST_locationsPool110);
		}
		int eaters = numbereating(loc), days = fooddaysleft(loc);
		if (eaters>0)
		{
			if (days >= 1)
			{
				set_color_easy(WHITE_ON_BLACK);
				mvaddstrAlt(6, 50, days);
				addstrAlt(CONST_locationsPool111);
				if (days != 1)addcharAlt('s');
				addstrAlt(CONST_locationsPool112);
			}
			else if (days == 0)
			{
				set_color_easy(RED_ON_BLACK);
				mvaddstrAlt(6, 50, CONST_locationsPool113);
			}
		}
		set_color_easy(WHITE_ON_BLACK);
		mvaddstrAlt(6, 1, location[loc]->compound_stores);
		addstrAlt(CONST_locationsPool114);
		if (location[loc]->compound_stores != 1)addstrAlt(CONST_locationsPool115);
		set_color_easy(WHITE_ON_BLACK);
		mvaddstrAlt(6, 30, eaters);
		addstrAlt(CONST_locationsPool116);
	}
}
extern int selectedsiege;
extern int day;
extern int month;
extern int year;
/* location and squad header */
void locheader()
{
	if (activesquad != NULL && activesquad->squad[0]->location != -1)
	{
		if (location[activesquad->squad[0]->location]->siege.siege)
		{
			if (location[activesquad->squad[0]->location]->siege.underattack)set_color_easy(RED_ON_BLACK_BRIGHT);
			else set_color_easy(YELLOW_ON_BLACK_BRIGHT);
		}
		else set_color_easy(WHITE_ON_BLACK);
	}
	else if (selectedsiege != -1)
	{
		if (location[selectedsiege]->siege.siege)
		{
			if (location[selectedsiege]->siege.underattack)set_color_easy(RED_ON_BLACK_BRIGHT);
			else set_color_easy(YELLOW_ON_BLACK_BRIGHT);
		}
		else set_color_easy(WHITE_ON_BLACK);
	}
	else set_color_easy(WHITE_ON_BLACK);
	moveAlt(0, 0);
	if (activesquad != NULL && activesquad->squad[0]->location != -1)
	{
		addstrAlt(location[activesquad->squad[0]->location]->getname(false, true));
		addstrAlt(commaSpace);
	}
	else
	{
		if (selectedsiege == -1)
		{
			addstrAlt(CONST_locationsPool117);
			addstrAlt(commaSpace);
		}
		else
		{
			addstrAlt(location[selectedsiege]->getname(false, true));
			addstrAlt(commaSpace);
		}
	}
	addstrAlt(getmonth(month, true));
	addstrAlt(singleSpace);
	addstrAlt(day);
	addstrAlt(commaSpace);
	addstrAlt(year);
	if (activesquad == NULL && selectedsiege == -1)
	{
		set_color_easy(BLACK_ON_BLACK_BRIGHT);
		mvaddstrAlt(3, 6, CONST_locationsPool118);
		mvaddstrAlt(4, 6, CONST_locationsPool119);
		mvaddstrAlt(5, 6, CONST_locationsPool120);
		set_color_easy(WHITE_ON_BLACK);
	}
	printfunds();
	if (activesquad != NULL)
	{
		string str = getactivity(activesquad->activity);
		set_activity_color(activesquad->activity.type);
		if (activesquad->activity.type == ACTIVITY_NONE)
		{
			bool haveact = false, multipleact = false;
			for (int p = 0; p<6; p++)
			{
				if (activesquad->squad[p] == NULL) continue;
				const string str2 = getactivity(activesquad->squad[p]->activity);
				set_activity_color(activesquad->squad[p]->activity.type);
				if (haveact&&str != str2) multipleact = true;
				str = str2, haveact = true;
			}
			if (multipleact)
			{
				str = CONST_locationsPool121;
				set_color_easy(WHITE_ON_BLACK_BRIGHT);
			}
		}
		mvaddstrAlt(0, 41, str);
	}
}
#include "../common/commonactions.h"
#include "../common/musicClass.h"
extern MusicClass music;
string closeParenthesis;
string spaceParanthesisDollar;
string needCar;
string travelDifCity;
string secrecyLevel;
string percentSign;
string heatLevel;
string underSiege;
string currentLocation;
string highSecurity;
string closedDown;
string enemySafeHouse;
string safeHouse;
/* base - go forth to stop evil */
void stopevil()
{
	//int l = 0, p = 0;
	if (!activesquad) return;
	bool havecar = false;
	for (int p = 0; p < 6; p++) if (activesquad->squad[p]) if (activesquad->squad[p]->pref_carid != -1)
	{
		havecar = true;
		break;
	}
	Location* squad_location = location[activesquad->squad[0]->location];
	int page = 0, loc = -1;
	// Start at the city level, rather than the absolute top
	if (multipleCityMode) {
		for (int l = 0; l < len(location); l++) {
			if (location[l]->type == squad_location->city) {
				loc = l;
				break;
			}
		}
	}
	vector<long> temploc;
	// 1. LCS safe houses
	for (int l = 0; l < len(location); l++)
		if (location[l]->parent == loc && location[l]->renting >= 0 && !location[l]->hidden)
			temploc.push_back(l);
	// 2. CCS safe houses
	for (int l = 0; l < len(location); l++)
		if (location[l]->parent == loc && location[l]->renting == RENTING_CCS && !location[l]->hidden)
			temploc.push_back(l);
	// 3. Other sites
	for (int l = 0; l < len(location); l++)
		if (location[l]->parent == loc && location[l]->renting == RENTING_NOCONTROL && !location[l]->hidden)
			temploc.push_back(l);
	// Determine cost of tickets for travel
	int ticketprice = 100 * squadsize(activesquad);
	while (true)
	{
		music.play(MUSIC_STOPEVIL);
		eraseAlt();
		set_color_easy(WHITE_ON_BLACK);
		mvaddstrAlt(0, 0, CONST_locationsPool122);
		printparty();
		if (loc != -1)
		{
			set_color_easy(WHITE_ON_BLACK);
			mvaddstrAlt(8, 0, location[loc]->getname(-1, true));
		}
		temploc.clear();
		for (int l = 0; l < len(location); l++)
			if (location[l]->parent == loc&&location[l]->renting >= 0 && !location[l]->hidden)temploc.push_back(l);
		for (int l = 0; l < len(location); l++)
			if (location[l]->parent == loc&&location[l]->renting == RENTING_CCS&&!location[l]->hidden)temploc.push_back(l);
		for (int l = 0; l < len(location); l++)
			if (location[l]->parent == loc&&location[l]->renting == RENTING_NOCONTROL&&!location[l]->hidden)temploc.push_back(l);
		int y = 10;
		for (int p = page * 11; p < len(temploc) && p < page * 11 + 11; p++)
		{
			if (p == -1) break;
			Location* this_location = location[temploc[p]];
			set_color_easy(WHITE_ON_BLACK);
			mvaddcharAlt(y, 0, y - 10 + 'A');
			addstrAlt(spaceDashSpace);
			addstrAlt(location[temploc[p]]->getname());
			bool show_safehouse_info = false;
			if (this_location == squad_location) {
				set_color_easy(WHITE_ON_BLACK_BRIGHT);
				addstrAlt(currentLocation);
				show_safehouse_info = true;
			}
			else if (this_location->renting >= 0) {
				set_color_easy(GREEN_ON_BLACK_BRIGHT);
				addstrAlt(safeHouse);
				show_safehouse_info = true;
			}
			else if (this_location->renting == RENTING_CCS) {
				set_color_easy(RED_ON_BLACK_BRIGHT);
				addstrAlt(enemySafeHouse);
			}
			else if (this_location->closed) {
				set_color_easy(RED_ON_BLACK_BRIGHT);
				addstrAlt(closedDown);
			}
			else if (this_location->highsecurity) {
				set_color_easy(MAGENTA_ON_BLACK_BRIGHT);
				addstrAlt(highSecurity);
			}
			else if (multipleCityMode && this_location->type == squad_location->city) {
				set_color_easy(WHITE_ON_BLACK_BRIGHT);
				addstrAlt(currentLocation);
			}
			else if (this_location->area != squad_location->area && !havecar) {
				set_color_easy(YELLOW_ON_BLACK_BRIGHT);
				addstrAlt(needCar);
			}
			else if (this_location->type == SITE_TRAVEL) {
				if (ledger.get_funds() < ticketprice)
					set_color_easy(RED_ON_BLACK_BRIGHT);
				else
					set_color_easy(GREEN_ON_BLACK_BRIGHT);
				addstrAlt(spaceParanthesisDollar + tostring(ticketprice) + closeParenthesis);
			}
			if (this_location->siege.siege > 0) {
				set_color_easy(RED_ON_BLACK);
				addstrAlt(underSiege);
			}
			if (show_safehouse_info)
			{
				this_location->update_heat_protection();
				set_color_easy(WHITE_ON_BLACK);
				mvaddstrAlt(y, 54, heatLevel);
				if (this_location->heat > this_location->heat_protection)
					set_color_easy(YELLOW_ON_BLACK_BRIGHT);
				else set_color_easy(BLACK_ON_BLACK_BRIGHT);
				addstrAlt(this_location->heat);
				addstrAlt(percentSign);
				set_color_easy(WHITE_ON_BLACK);
				mvaddstrAlt(y, 66, secrecyLevel);
				if (this_location->heat > this_location->heat_protection)
					set_color_easy(YELLOW_ON_BLACK_BRIGHT);
				else set_color_easy(BLACK_ON_BLACK_BRIGHT);
				addstrAlt(this_location->heat_protection);
				addstrAlt(percentSign);
			}
			if (multipleCityMode && this_location->city == this_location->type)
			{
				set_color_easy(BLACK_ON_BLACK_BRIGHT);
				mvaddstrAlt(y, 50, this_location->city_description());
			}
			y++;
		}
		if (multipleCityMode && loc != -1 && LocationsPool::getInstance().getLocationType(loc) == location[loc]->city)
		{
			set_color_easy(WHITE_ON_BLACK);
			mvaddcharAlt(y + 1, 0, y - 10 + 'A');
			addstrAlt(travelDifCity);
			if (!havecar) {
				set_color_easy(YELLOW_ON_BLACK_BRIGHT);
				addstrAlt(needCar);
			}
			else {
				if (ledger.get_funds() < ticketprice)
					set_color_easy(RED_ON_BLACK_BRIGHT);
				else set_color_easy(GREEN_ON_BLACK_BRIGHT);
				addstrAlt(spaceParanthesisDollar + tostring(ticketprice) + closeParenthesis);
			}
			temploc.push_back(-1);
		}
		set_color_easy(WHITE_ON_BLACK);
		//PAGE UP
		if (page > 0)
		{
			mvaddstrAlt(10, 60, addprevpagestr());
		}
		//PAGE DOWN
		if ((page + 1) * 11 < len(temploc))
		{
			mvaddstrAlt(20, 60, addnextpagestr());
		}
		set_color_easy(WHITE_ON_BLACK);
		if ((loc == -1) || (multipleCityMode && LocationsPool::getInstance().getLocationType(loc) == squad_location->city)) mvaddstrAlt(24, 1, CONST_locationsPool123);
		else mvaddstrAlt(24, 1, CONST_locationsPool124);
		int c = getkeyAlt();
		//PAGE UP
		if ((c == interface_pgup || c == KEY_UP || c == KEY_LEFT) && page>0) page--;
		//PAGE DOWN
		if ((c == interface_pgdn || c == KEY_DOWN || c == KEY_RIGHT) && (page + 1) * 11<len(temploc)) page++;
		if (c >= 'a'&&c <= 'k')
		{
			int sq = page * 11 + c - 'a';
			if (sq < len(temploc) && sq >= 0)
			{
				int oldloc = loc;
				loc = temploc[sq];
				if ((loc == -1 || (multipleCityMode && location[loc]->city != squad_location->city)) && !havecar)
					loc = oldloc;
				int subcount = 0;
				for (int l = 0; l < len(location); l++)
					if (location[l]->parent == loc)
						subcount++;
				if (subcount == 0 || (multipleCityMode && loc >= 0 && location[loc]->city != squad_location->city))
				{
					if (!location[loc]->closed &&
						((location[loc]->area == squad_location->area&&location[loc]->city == squad_location->city) || havecar))
					{
						activesquad->activity.type = ACTIVITY_VISIT;
						activesquad->activity.arg = loc;
						return;
					}
					else loc = oldloc;
				}
			}
		}
		/*if(c=='z')
		{
		activesquad->stance++;
		if(activesquad->stance>SQUADSTANCE_STANDARD)
		activesquad->stance=0;
		}*/
		if (c == 'x' || c == ENTER || c == ESC || c == SPACEBAR)
		{
			if (loc != -1 && (location[loc]->city != LocationsPool::getInstance().getLocationType(loc) || location[loc]->city != squad_location->city))
				loc = location[loc]->parent;
			else
			{
				activesquad->activity.type = ACTIVITY_NONE; // Clear squad activity
				break;
			}
		}
	}
}
vector<string> caseBUSINESSFRONT_INSURANCE;
vector<string> caseBUSINESSFRONT_TEMPAGENCY;
vector<string> caseBUSINESSFRONT_RESTAURANT;
vector<string> caseBUSINESSFRONT_MISCELLANEOUS;
const string mostlyendings = "mostlyendings\\";
#include "../customMaps.h"
vector<file_and_text_collection> locationspool_text_file_collection = {
	customText(&caseBUSINESSFRONT_INSURANCE, mostlyendings + CONST_locationsPool125),
	customText(&caseBUSINESSFRONT_TEMPAGENCY, mostlyendings + CONST_locationsPool126),
	customText(&caseBUSINESSFRONT_RESTAURANT, mostlyendings + CONST_locationsPool127),
	customText(&caseBUSINESSFRONT_MISCELLANEOUS, mostlyendings + CONST_locationsPool128),
};
enum BusinessFronts
{
	BUSINESSFRONT_INSURANCE,
	BUSINESSFRONT_TEMPAGENCY,
	BUSINESSFRONT_RESTAURANT,
	BUSINESSFRONT_MISCELLANEOUS,
	BUSINESSFRONTNUM
};
/* base - invest in this location */
void investlocation()
{
	int loc = selectedsiege;
	while (true)
	{
		eraseAlt();
		locheader();
		printlocation(loc);
		if (LocationsPool::getInstance().canBeFortified(loc))
		{
			if (ledger.get_funds() >= 2000) set_color_easy(WHITE_ON_BLACK);
			else set_color_easy(BLACK_ON_BLACK_BRIGHT);
			if (LocationsPool::getInstance().getLocationType(loc) == SITE_OUTDOOR_BUNKER)
				mvaddstrAlt(8, 1, CONST_locationsPool129);
			else if (LocationsPool::getInstance().getLocationType(loc) == SITE_RESIDENTIAL_BOMBSHELTER)
				mvaddstrAlt(8, 1, CONST_locationsPool130);
			else
				mvaddstrAlt(8, 1, CONST_locationsPool131);
		}
		if (!(LocationsPool::getInstance().getCompoundWalls(loc) & COMPOUND_CAMERAS))
		{
			if (ledger.get_funds() >= 2000) set_color_easy(WHITE_ON_BLACK);
			else set_color_easy(BLACK_ON_BLACK_BRIGHT);
			mvaddstrAlt(9, 1, CONST_locationsPool132);
		}
		if (location[loc]->can_be_trapped())
		{
			if (ledger.get_funds() >= 3000) set_color_easy(WHITE_ON_BLACK);
			else set_color_easy(BLACK_ON_BLACK_BRIGHT);
			mvaddstrAlt(10, 1, CONST_locationsPool133);
		}
		if (location[loc]->can_install_tanktraps())
		{
			if (ledger.get_funds() >= 3000) set_color_easy(WHITE_ON_BLACK);
			else set_color_easy(BLACK_ON_BLACK_BRIGHT);
			mvaddstrAlt(11, 1, CONST_locationsPool134);
		}
		if (!(location[loc]->compound_walls & COMPOUND_GENERATOR))
		{
			if (ledger.get_funds() >= 3000) set_color_easy(WHITE_ON_BLACK);
			else set_color_easy(BLACK_ON_BLACK_BRIGHT);
			mvaddstrAlt(12, 1, CONST_locationsPool135);
		}
		if (!(location[loc]->compound_walls & COMPOUND_AAGUN))
		{
			if (lawList[LAW_GUNCONTROL] == ALIGN_ARCHCONSERVATIVE)
			{
				if (ledger.get_funds() >= 35000) set_color_easy(WHITE_ON_BLACK);
				mvaddstrAlt(13, 1, CONST_locationsPool136);
			}
			else
			{
				if (ledger.get_funds() >= 200000) set_color_easy(WHITE_ON_BLACK);
				else set_color_easy(BLACK_ON_BLACK_BRIGHT);
				mvaddstrAlt(13, 1, CONST_locationsPool137);
			}
		}
		if (!(location[loc]->compound_walls & COMPOUND_PRINTINGPRESS))
		{
			if (ledger.get_funds() >= 3000) set_color_easy(WHITE_ON_BLACK);
			else set_color_easy(BLACK_ON_BLACK_BRIGHT);
			mvaddstrAlt(14, 1, CONST_locationsPool138);
		}
		if (location[loc]->can_have_businessfront())
		{
			if (ledger.get_funds() >= 3000) set_color_easy(WHITE_ON_BLACK);
			else set_color_easy(BLACK_ON_BLACK_BRIGHT);
			mvaddstrAlt(15, 1, CONST_locationsPool139);
		}
		if (ledger.get_funds() >= 150) set_color_easy(WHITE_ON_BLACK);
		else set_color_easy(BLACK_ON_BLACK_BRIGHT);
		mvaddstrAlt(16, 1, CONST_locationsPool140);
		mvaddstrAlt(17, 1, enter_done);
		int c = getkeyAlt();
		if (c == 'x' || c == ENTER || c == ESC || c == SPACEBAR) break;
		if (c == 'w')
		{
			if (location[loc]->can_be_fortified() && ledger.get_funds() >= 2000)
			{
				ledger.subtract_funds(2000, EXPENSE_COMPOUND);
				location[loc]->compound_walls |= COMPOUND_BASIC;
			}
		}
		if (c == 'c')
		{
			if (!(LocationsPool::getInstance().getCompoundWalls(loc) & COMPOUND_CAMERAS) && ledger.get_funds() >= 2000)
			{
				ledger.subtract_funds(2000, EXPENSE_COMPOUND);
				location[loc]->compound_walls |= COMPOUND_CAMERAS;
			}
		}
		if (c == 'b')
		{
			if (location[loc]->can_be_trapped() && ledger.get_funds() >= 3000)
			{
				ledger.subtract_funds(3000, EXPENSE_COMPOUND);
				location[loc]->compound_walls |= COMPOUND_TRAPS;
			}
		}
		if (c == 't')
		{
			if (location[loc]->can_install_tanktraps() && ledger.get_funds() >= 3000)
			{
				ledger.subtract_funds(3000, EXPENSE_COMPOUND);
				location[loc]->compound_walls |= COMPOUND_TANKTRAPS;
			}
		}
		if (c == 'g')
		{
			if (!(LocationsPool::getInstance().getCompoundWalls(loc) & COMPOUND_GENERATOR) && ledger.get_funds() >= 3000)
			{
				ledger.subtract_funds(3000, EXPENSE_COMPOUND);
				location[loc]->compound_walls |= COMPOUND_GENERATOR;
			}
		}
		if (c == 'a')
		{
			int aagunPrice = 200000;
			if (lawList[LAW_GUNCONTROL] == ALIGN_ARCHCONSERVATIVE)
				aagunPrice = 35000;
			if (!(location[loc]->compound_walls & COMPOUND_AAGUN) && ledger.get_funds() >= aagunPrice)
			{
				ledger.subtract_funds(aagunPrice, EXPENSE_COMPOUND);
				location[loc]->compound_walls |= COMPOUND_AAGUN;
			}
		}
		if (c == 'p')
		{
			if (!(LocationsPool::getInstance().getCompoundWalls(loc) & COMPOUND_PRINTINGPRESS) && ledger.get_funds() >= 3000)
			{
				ledger.subtract_funds(3000, EXPENSE_COMPOUND);
				location[loc]->compound_walls |= COMPOUND_PRINTINGPRESS;
			}
		}
		if (c == 'r')
		{
			if (ledger.get_funds() >= 150)
			{
				ledger.subtract_funds(150, EXPENSE_COMPOUND);
				location[loc]->compound_stores += 20;
			}
		}
		if (c == 'f')
		{
			if (location[loc]->can_have_businessfront() && ledger.get_funds() >= 3000)
			{
				ledger.subtract_funds(3000, EXPENSE_COMPOUND);
				do
				{
					location[loc]->front_business = LCSrandom(BUSINESSFRONTNUM);
					strcpy(location[loc]->front_name, lastname(true));
					strcat(location[loc]->front_name, singleSpace);
					int selection;
					switch (location[loc]->front_business)
					{
					case BUSINESSFRONT_INSURANCE:
						selection = LCSrandom(len(caseBUSINESSFRONT_INSURANCE) / 2);
						strcat(location[loc]->front_name, caseBUSINESSFRONT_INSURANCE[selection * 2]);
						strcpy(location[loc]->front_shortname, caseBUSINESSFRONT_INSURANCE[selection * 2 + 1]);
						break;
					case BUSINESSFRONT_TEMPAGENCY:
						selection = LCSrandom(len(caseBUSINESSFRONT_TEMPAGENCY) / 2);
						strcat(location[loc]->front_name, caseBUSINESSFRONT_TEMPAGENCY[selection * 2]);
						strcpy(location[loc]->front_shortname, caseBUSINESSFRONT_TEMPAGENCY[selection * 2 + 1]);
						break;
					case BUSINESSFRONT_RESTAURANT:
						selection = LCSrandom(len(caseBUSINESSFRONT_RESTAURANT) / 2);
						strcat(location[loc]->front_name, caseBUSINESSFRONT_RESTAURANT[selection * 2]);
						strcpy(location[loc]->front_shortname, caseBUSINESSFRONT_RESTAURANT[selection * 2 + 1]);
						break;
					case BUSINESSFRONT_MISCELLANEOUS:
						selection = LCSrandom(len(caseBUSINESSFRONT_MISCELLANEOUS) / 2);
						strcat(location[loc]->front_name, caseBUSINESSFRONT_MISCELLANEOUS[selection * 2]);
						strcpy(location[loc]->front_shortname, caseBUSINESSFRONT_MISCELLANEOUS[selection * 2 + 1]);
						break;
					}
				} while (location[loc]->duplicatelocation());
			}
		}
	}
}
extern int stat_kidnappings;
/* names the new hostage and stashes them in your base */
void kidnaptransfer(Creature &cr)
{
	Creature *newcr = new Creature;
	*newcr = cr;
	newcr->namecreature();
	newcr->location = activesquad->squad[0]->base;
	newcr->base = activesquad->squad[0]->base;
	newcr->flag |= CREATUREFLAG_MISSING;
	//disarm them and stash their weapon back at the base
	newcr->drop_weapons_and_clips(&(location[newcr->location]->loot));
	//Create InterrogationST data
	newcr->activity.intr() = new InterrogationST;
	eraseAlt();
	set_color_easy(WHITE_ON_BLACK_BRIGHT);
	mvaddstrAlt(0, 0, CONST_locationsPool141);
	addstrAlt(newcr->propername);
	set_color_easy(WHITE_ON_BLACK);
	mvaddstrAlt(2, 0, CONST_locationsPool142);
	addstrAlt(newcr->get_type_name());
	addstrAlt(CONST_locationsPool143);
	mvaddstrAlt(3, 0, CONST_locationsPool144);
	enter_name(4, 0, newcr->name, CREATURE_NAMELEN, newcr->propername);
	addCreature(newcr);
	stat_kidnappings++;
}
/* transfer all loot from some source (such as a squad or another location) to a location, and deal with money properly */
void Location::getloot(vector<Item *>& loot)
{
	for (int l = len(loot) - 1; l >= 0; l--)
		if (loot[l]->whatIsThis() == THIS_IS_MONEY)
		{
			Money* m = static_cast<Money*>(loot[l]); //cast -XML
			ledger.add_funds(m->get_amount(), INCOME_THIEVERY);
			delete loot[l];
		}
		else
		{  // Empty squad inventory into base inventory
			this->loot.push_back(loot[l]);
		}
	loot.clear();
}
void clearRentExemptions() {
	for (int l = 0; l < LocationsPool::getInstance().lenpool(); l++) location[l]->newrental = 0;
}
/* monthly - lets the player choose a special edition for the guardian */
int choosespecialedition(char &clearformess);
/* monthly - guardian - prints liberal guardian special editions */
void printnews(short l, short newspaper);
#include "../items/itemPool.h"
#include "../items/lootTypePool.h"
void publishSpecialEditions(char &clearformess) {
	//YOUR PAPER AND PUBLIC OPINION AND STUFF
	vector<int> nploc;
	for (int l = 0; l < LocationsPool::getInstance().lenpool(); l++)
	{
		if ((location[l]->compound_walls & COMPOUND_PRINTINGPRESS) &&
			!location[l]->siege.siege&&
			location[l]->renting != RENTING_CCS) nploc.push_back(l);
	}
	if (len(nploc))
	{
		//DO SPECIAL EDITIONS
		int loottypeindex = choosespecialedition(clearformess);
		if (loottypeindex != -1)
		{
			printnews(loottypeindex, len(nploc));
			if (LootTypePool::getInstance().getIdName(loottypeindex) == tag_LOOT_INTHQDISK || //For special edition xml file? -XML
				LootTypePool::getInstance().getIdName(loottypeindex) == tag_LOOT_SECRETDOCUMENTS)
			{
				for (int l = 0; l < len(nploc); l++)
					criminalizepool(LAWFLAG_TREASON, -1, nploc[l]);
			}
		}
	}
}
extern char endgamestate;
extern short background_liberal_influence[VIEWNUM];
void manageGrafiti() {
	//Manage graffiti
	for (int l = 0; l < LocationsPool::getInstance().lenpool(); l++) // Check each location
	{
		for (int c = len(location[l]->changes) - 1; c >= 0; c--) // Each change to the map
		{
			if (location[l]->changes[c].flag == SITEBLOCK_GRAFFITI ||
				location[l]->changes[c].flag == SITEBLOCK_GRAFFITI_CCS ||
				location[l]->changes[c].flag == SITEBLOCK_GRAFFITI_OTHER) // Find changes that refer specifically to graffiti
			{
				int power = 0, align = 0;
				if (location[l]->changes[c].flag == SITEBLOCK_GRAFFITI) align = 1;
				if (location[l]->changes[c].flag == SITEBLOCK_GRAFFITI_CCS) align = -1;
				//Purge graffiti from more secure sites (or from non-secure
				//sites about once every five years), but these will
				//influence people more for the current month
				if (securityable(LocationsPool::getInstance().getLocationType(l)))
				{
					location[l]->changes.erase(location[l]->changes.begin() + c);
					power = 5;
				}
				else
				{
					if (location[l]->renting == RENTING_CCS)
						location[l]->changes[c].flag = SITEBLOCK_GRAFFITI_CCS; // Convert to CCS tags
					else if (location[l]->renting == RENTING_PERMANENT)
						location[l]->changes[c].flag = SITEBLOCK_GRAFFITI; // Convert to LCS tags
					else
					{
						power = 1;
						if (!LCSrandom(10))
							location[l]->changes[c].flag = SITEBLOCK_GRAFFITI_OTHER; // Convert to other tags
						if (!LCSrandom(10) && endgamestate < ENDGAME_CCS_DEFEATED&&endgamestate>0)
							location[l]->changes[c].flag = SITEBLOCK_GRAFFITI_CCS; // Convert to CCS tags
						if (!LCSrandom(30))
							location[l]->changes.erase(location[l]->changes.begin() + c); // Clean up
					}
				}
				if (align == 1)
				{
					background_liberal_influence[VIEW_LIBERALCRIMESQUAD] += power;
					background_liberal_influence[VIEW_CONSERVATIVECRIMESQUAD] += power;
				}
				else if (align == -1)
				{
					background_liberal_influence[VIEW_LIBERALCRIMESQUAD] -= power;
					background_liberal_influence[VIEW_CONSERVATIVECRIMESQUAD] -= power;
				}
			}
		}
	}
}
siegest* getseigestFromLocation(int secondaryLocation) {
	siegest* siege = NULL;
	int primaryLocation = activesquad ? activesquad->squad[0]->location : -1;
	if (primaryLocation != -1) {
		siege = &location[primaryLocation]->siege;
	}
	else if (secondaryLocation != -1) {
		siege = &location[secondaryLocation]->siege;
	}
	return siege;
}
void gotoEquipmentScreen(int loc) {
	equip(location[loc]->loot, -1);
}
void createTempSquadWithJustThisLiberal(Creature *cr, int cursquadid) {
	//create a temp squad containing just this liberal
	int oldsquadid = cr->squadid;
	squadst *oldactivesquad = activesquad;
	activesquad = new squadst;
	strcpy(activesquad->name, CONST_locationsPool145);
	activesquad->id = cursquadid;
	activesquad->squad[0] = cr;
	cr->squadid = activesquad->id;
	//go to equipment screen
	gotoEquipmentScreen(activesquad->squad[0]->location);
	//once you're done, restore original squad status.
	delete activesquad;
	activesquad = oldactivesquad;
	cr->squadid = oldsquadid;
}

void moveEverythingAwayFromSite(int cursite) {
	location[cursite]->renting = RENTING_NOCONTROL;
	//MOVE ALL ITEMS AND SQUAD MEMBERS
	const int hs = find_site_index_in_same_city(SITE_RESIDENTIAL_SHELTER, cursite);
	CreaturePool::getInstance().moveEverythingFrom(cursite, hs);
	location[hs]->getloot(location[cursite]->loot);
	location[cursite]->compound_walls = 0;
	location[cursite]->compound_stores = 0;
	location[cursite]->front_business = -1;
}
void LocationsPool::addSiegeKill(int cursite) {
	location[cursite]->siege.kills++;
}
void LocationsPool::removeTank(int cursite) {
	location[cursite]->siege.tanks--;
}
void addLocationChange(int cursite, sitechangest change) {
	location[cursite]->changes.push_back(change);
}
const int LocationsPool::getHeat(int cursite) {
	return location[cursite]->heat;
}
void LocationsPool::setSiegetimeuntillocated(int cursite, int timer) {
	location[cursite]->siege.timeuntillocated = timer;
}

void LocationsPool::clearHeat(int cursite) {
	location[cursite]->heat = 0;
}
void setColorBasedOnSiege(const int cursite, const int y, const bool p) {
	Location *loc = location[cursite];
	siegest *siege = &loc->siege;
	if (siege ? siege->siege : false) set_color_easy(siege->underattack ? p ? RED_ON_BLACK_BRIGHT : RED_ON_BLACK : p ? YELLOW_ON_BLACK_BRIGHT : YELLOW_ON_BLACK);
	mvaddstrAlt(y, 31, location[cursite]->getname(true, true));
}

int consolidateSiegeLoot() {
	int k = 0;
	for (int l = 0; l < len(location); l++)
	{
		consolidateloot(location[l]->loot);
		if (!location[l]->siege.siege)
			k += len(location[l]->loot); // Review and Move Equipment
	}
	return k;
}

void nukeAllEmptySquads(const vector<int> squadloc, const int mode) {
	//NUKE ALL EMPTY SQUADS
	for (int sq = len(squad) - 1; sq >= 0; sq--)
	{
		bool hasmembers = false;
		for (int p = 0; p < 6; p++)
			if (squad[sq]->squad[p] != NULL)
			{
				hasmembers = true; break;
			}
		// in the event a new squad is created squadloc[] will be one shorter than squad[]
		// But since a new squad cannot be created without members, this should
		// not ever break
		if (!hasmembers && mode == GAMEMODE_BASE)
		{
			if (squadloc[sq] != -1)
				location[squadloc[sq]]->getloot(squad[sq]->loot);
			if (activesquad == squad[sq])activesquad = NULL;
			delete_and_remove(squad, sq);
		}
	}
}

void consolidateLoot(const int l) {
	consolidateloot(location[l]->loot);
}
int LocationsPool::lenloot(const int l) {
	return len(location[l]->loot);
}
string getLootTitle(const int base, const int l) {
	return location[base]->loot[l]->equip_title();
}

int getLootNumber(const int base, const int l) {
	return location[base]->loot[l]->get_number();
}

void LocationsPool::captureSite(int cursite) {
	location[cursite]->renting = RENTING_PERMANENT; // Capture safehouse for the glory of the LCS!
	location[cursite]->closed = 0;
	location[cursite]->heat = 100;
}

void LocationsPool::closeSite(int cursite, int sitecrime) {
	location[cursite]->closed = sitecrime / 10; // Close down site
}
bool LocationsPool::siteHasCameras(int cursite) {
	return (location[cursite]->compound_walls & COMPOUND_CAMERAS) && !location[cursite]->siege.cameras_off;
}

void getRandomLoot(int cursite) {
	int b = LCSrandom(len(location[cursite]->loot));
	Item *it = location[cursite]->loot[b];
	activesquad->loot.push_back(it);
	location[cursite]->loot.erase(location[cursite]->loot.begin() + b);
}
// Redundancy.  TODO Candidate for culling
int lenloot(int cursite) {
	return LocationsPool::getInstance().lenloot(cursite);
}

char LocationsPool::isThisUnderAttack(int cursite) {
	return location[cursite]->siege.underattack;
}

void LocationsPool::setRenting(int cursite, int renting) {
	location[cursite]->renting = renting;
}

char LocationsPool::isThisAFront(int cursite) {
	return location[cursite]->front_business;
}
string LocationsPool::getFrontName(int cursite) {
	return location[cursite]->front_name;
}

void LocationsPool::tickAttackTime(int cursite) {
	location[cursite]->siege.attacktime++;
}
int LocationsPool::getAttackTime(int cursite) {
	return location[cursite]->siege.attacktime;
}
void LocationsPool::resetAttackTime(int cursite) {
	location[cursite]->siege.attacktime = 0;
}
int LocationsPool::doWeHaveTankTraps(int cursite) {
	return (location[cursite]->compound_walls&COMPOUND_TANKTRAPS);
}
void LocationsPool::deleteTankTraps(int l) {
	location[l]->compound_walls &= ~COMPOUND_TANKTRAPS;
}
void LocationsPool::spawnATank(int cursite) {
	location[cursite]->siege.tanks++;
}

void LocationsPool::spawnATank(int cursite, int num) {
	location[cursite]->siege.tanks = num;
}

int LocationsPool::getSiegeKills(int cursite) {
	return location[cursite]->siege.kills;
}
int LocationsPool::getSiegeTanks(int cursite) {
	return location[cursite]->siege.tanks;
}

void LocationsPool::turnOffSiege(int loc) {
	location[loc]->siege.attacktime = 0;
	location[loc]->siege.kills = 0;
	location[loc]->siege.tanks = 0;
}

bool LocationsPool::hasTraps(int loc) {
	return location[loc]->compound_walls&COMPOUND_TRAPS;
}

bool LocationsPool::lightsOff(int loc) {
	return location[loc]->siege.lights_off;
}
int armor_makedifficulty(Armor& type, Creature *cr);
void findArmorToRepair(Armor* armor, Item* pile, int &pileindex, vector<Item* > *pilelist, Creature cr) {
	for (int passnum = 0; passnum < 3 && armor == NULL; passnum++) {

		for (int l = 0; l < lenloot(cr.location); l++) {

			if (location[cr.location]->loot[l]->whatIsThis() == THIS_IS_ARMOR)
			{
				bool dothis = false;
				Armor* a = static_cast<Armor*>(location[cr.location]->loot[l]);//cast -XML
				bool blood = a->is_bloody();
				bool damage = a->is_damaged();
				bool hard = armor_makedifficulty(*a, &cr) > 4;
				bool easy = armor_makedifficulty(*a, &cr) <= 4;

				switch (passnum)
				{
				case 0: // Guaranteed to accomplish something
					dothis = (blood && damage);
					break;
				case 1: // Find something to clean if low skill, repair if high
					dothis = (blood && hard)
						|| (damage && easy);
					break;
				case 2: // Anything that needs work
					dothis = (blood || damage);
					break;
				}
				if (dothis)
				{
					armor = a;
					pile = location[cr.location]->loot[l];
					pileindex = l;
					pilelist = &location[cr.location]->loot;
					break;
				}
			}

		}

	}
}
char tryFindCloth(int cursite) {
	for (int l = 0; l < len(location[cursite]->loot); l++) {
		if (location[cursite]->loot[l]->whatIsThis() == THIS_IS_LOOT &&
			(location[cursite]->loot[l])->is_cloth()) //cast -XML
		{
			if (location[cursite]->loot[l]->get_number() == 1)
				delete_and_remove(location[cursite]->loot, l);
			else location[cursite]->loot[l]->decrease_number(1);
			return 1;
		}
	}
	return 0;
}
void addLootToLoc(int loc, Item* it) {
	location[loc]->loot.push_back(it);
}
string gimmeASprayCan(Creature* graffiti) {
	for (int i = 0; i < lenloot(graffiti->base); i++)
	{
		if (location[graffiti->base]->loot[i]->whatIsThis() == THIS_IS_WEAPON)
		{
			Weapon *w = static_cast<Weapon*>(location[graffiti->base]->loot[i]); //cast -XML
			if (w->can_graffiti())
			{
				graffiti->give_weapon(*w, &(location[graffiti->base]->loot));
				if (location[graffiti->base]->loot[i]->empty())
					delete_and_remove(location[graffiti->base]->loot, i);
				return w->get_name();
			}
		}
	}
	return "";
}
const string tag_WEAPON_SPRAYCAN = "WEAPON_SPRAYCAN";
void buyMeASprayCan(Creature* graffiti) {

	Weapon spray(*weapontype[getweapontype(tag_WEAPON_SPRAYCAN)]);
	graffiti->give_weapon(spray, &location[graffiti->base]->loot);
}
void makeloot(Creature &cr, vector<Item *> &loot);
void lootTheBody(Creature &cr, int base) {
	//MAKE BASE LOOT
	makeloot(cr, location[base]->loot);
}
int countSafeHouses() {
	int safenumber = 0;
	for (int l = 0; l < len(location); l++) if (location[l]->is_lcs_safehouse()) safenumber++;
	return safenumber;
}
Location* getLocation() {
	Location* loc = NULL;
	if (selectedsiege != -1) loc = location[selectedsiege];
	if (activesquad) if (activesquad->squad[0]->location != -1)
		loc = location[activesquad->squad[0]->location];
	return loc;
}

bool isPartOfJusticeSystem(int cursite) {
	return location[cursite]->part_of_justice_system();
}
bool LocationsPool::canBeUpgraded(int cursite) {
	return location[cursite]->can_be_upgraded();
}

void LocationsPool::clearunderattack(int cursite) {
	location[cursite]->siege.underattack = 0;
}
bool isThisSafehouse(int loc) {
	return location[loc]->is_lcs_safehouse();
}
void equipLoot(int l, int loc) {
	equip(location[l]->loot, loc);
}
void burnFlagAtLocation(int l) {
	location[l]->haveflag = 0;
}
void locationIsNowRented(int l, int rent) {
	location[l]->renting = rent;
	location[l]->newrental = 1;
}

int getCity(int l) {
	return location[l]->city;
}

int getFenceValueLocation(int l, int slot) {
	return location[l]->loot[slot]->get_fencevalue();
}

bool getCanBeSoldLocation(int l, int slot) {
	return location[l]->loot[slot]->is_good_for_sale();
}

int getLocationLootNumber(int l, int slot) {
	return location[l]->loot[slot]->get_number();
}

void decreateLocationLoot(int loc, int loot, int num) {
	location[loc]->loot[loot]->decrease_number(num);
	if (location[loc]->loot[loot]->empty())
		delete_and_remove(location[loc]->loot, loot);
}

int whatIsThisItemInLocation(int loc, int l) {
	return location[loc]->loot[l]->whatIsThis();
}

void deleteLocationLoot(int loc, int loot) {
	delete_and_remove(location[loc]->loot, loot);
}
void deleteLocationLoot(int loc) {
	delete_and_clear(location[loc]->loot);
}

bool noQuickFenceLocation(int loc, int l) {
	return location[loc]->loot[l]->no_quick_fencing();
}

void CCSCapturesSite(int loc) {
	location[loc]->renting = RENTING_CCS;
}

int LocationsPool::getStoresAmount(int l) {
	return location[l]->compound_stores;
}

void endLocationSiege(int l) {
	location[l]->siege.siege = 0;
}

void reduceCompoundStores(int loc, int amount) {
	location[loc]->compound_stores -= amount;
}
void emptyCompoundStores(int l) {
	location[l]->compound_stores = 0;
}

bool hasPrintingPress(int l) {
	return location[l]->compound_walls&COMPOUND_PRINTINGPRESS;
}

void deletePrintingPress(int loc) {

	location[loc]->compound_walls &= ~COMPOUND_PRINTINGPRESS;
}

siegest getWholeSiege(int l) {
	return location[l]->siege;
}

void deleteBusinessFront(int l) {

	location[l]->front_business = -1;
}

void deleteCompoundWalls(int loc) {

	location[loc]->compound_walls = 0;
}

void dropHeatByFivePercent(int l) {
	location[l]->heat = static_cast<int>(location[l]->heat * 0.95);
}

int getTimeUntilSiege(int l) {
	return location[l]->siege.timeuntillocated;
}

void huntFasterIfSiteIncrediblyHot(int l) {
	if (location[l]->heat > 100)
	{
		int hunt_speed;
		hunt_speed = location[l]->heat / 50;
		while (hunt_speed&&location[l]->siege.timeuntillocated > 1)
		{
			location[l]->siege.timeuntillocated--;
			hunt_speed--;
		}
	}
}

void updateLocationHeatProtection(int l) {
	location[l]->update_heat_protection();
}

void letPlaceCoolOffUnlessCrime(int crimes, int l) {
	if (crimes < location[l]->heat)
	{
		location[l]->heat -= 1;
		if (location[l]->heat < 0)
			location[l]->heat = 0;
	}
	else
	{
		// Update location heat
		if (crimes > location[l]->heat) location[l]->heat += (crimes - location[l]->heat) / 10 + 1;
		// Begin planning siege if high heat on location
		if (location[l]->heat > location[l]->heat_protection &&
			LCSrandom(500) < location[l]->heat &&
			!(location[l]->siege.timeuntillocated >= 0)) //Do not re-plan siege.
		{
			// Set time until siege is carried out
			location[l]->siege.timeuntillocated += 2 + LCSrandom(6);
		}
	}
}

void policeSiege(int l) {

	location[l]->siege.siege = 1;
	location[l]->siege.siegetype = SIEGE_POLICE;
	location[l]->siege.lights_off = 0;
	location[l]->siege.cameras_off = 0;
}
void corporateSiege(int l) {
	location[l]->siege.siege = 1;
	location[l]->siege.siegetype = SIEGE_CORPORATE;
	location[l]->siege.underattack = 1;
	location[l]->siege.lights_off = 0;
	location[l]->siege.cameras_off = 0;
}

void CCSSiege(int l) {
	location[l]->siege.siege = 1;
	location[l]->siege.siegetype = SIEGE_CCS;
	location[l]->siege.underattack = 1;
	location[l]->siege.lights_off = 0;
	location[l]->siege.cameras_off = 0;
}

void CIASiege(int l) {
	location[l]->siege.siege = 1;
	location[l]->siege.siegetype = SIEGE_CIA;
	location[l]->siege.underattack = 1;
	location[l]->siege.lights_off = 1;
	location[l]->siege.cameras_off = 1;
}

void hicksSiege(int l) {
	location[l]->siege.siege = 1;
	location[l]->siege.siegetype = SIEGE_HICKS;
	location[l]->siege.underattack = 1;
	location[l]->siege.lights_off = 0;
	location[l]->siege.cameras_off = 0;
}

void firemanSiege(int l) {
	location[l]->siege.siege = 1;
	location[l]->siege.siegetype = SIEGE_FIREMEN;
	location[l]->siege.underattack = 1;
	location[l]->siege.lights_off = 0;
	location[l]->siege.cameras_off = 0;

}

void escalateSite(int l) {
	location[l]->siege.timeuntillocated = LCSrandom(4) + 4;
	location[l]->siege.escalationstate++;
}

void dumpLootAtLocation(int homes, vector<Item *>& loot) {
	location[homes]->getloot(loot);
}

void deleteGeneratorLightsOff(int l) {

	location[l]->compound_walls &= ~COMPOUND_GENERATOR;
	location[l]->siege.lights_off = 1;
}

int LocationsPool::getTimeUntilSiege(int loc, int type) {
	switch (type) {
	case SIEGE_POLICE:
		return location[loc]->siege.timeuntillocated;
		break;
	case SIEGE_CIA:
		return location[loc]->siege.timeuntilcia;
		break;
	case SIEGE_CORPORATE:
		return location[loc]->siege.timeuntilcorps;
		break;
	case SIEGE_CCS:
		return location[loc]->siege.timeuntilccs;
		break;
	case SIEGE_FIREMEN:
		return location[loc]->siege.timeuntilfiremen;
		break;
	default:
	case SIEGE_ORG:
	case SIEGE_HICKS:
	case SIEGENUM:
		return 0;
		break;

	}
}

void LocationsPool::setTimeUntilSiege(int loc, int type, int time) {
	switch (type) {
	case SIEGE_POLICE:
		location[loc]->siege.timeuntillocated = time;
		break;
	case SIEGE_CIA:
		location[loc]->siege.timeuntilcia = time;
		break;
	case SIEGE_CORPORATE:
		location[loc]->siege.timeuntilcorps = time;
		break;
	case SIEGE_CCS:
		location[loc]->siege.timeuntilccs = time;
		break;
	case SIEGE_FIREMEN:
		location[loc]->siege.timeuntilfiremen = time;
		break;
	default:
	case SIEGE_ORG:
	case SIEGE_HICKS:
	case SIEGENUM:
		;
		break;
	}
}

bool hasBusinessFront(int l) {
	return location[l]->front_business != -1;
}

bool hasAGenerator(int l) {
	return location[l]->compound_walls & COMPOUND_GENERATOR;
}

bool hasCameras(int l) {
	return location[l]->compound_walls & COMPOUND_CAMERAS;
}

void deleteAAGun(int l) {
	location[l]->compound_walls &= ~COMPOUND_AAGUN;
}

bool siteHasAAGun(int l) {
	return location[l]->compound_walls & COMPOUND_AAGUN;
}

void setUnderAttack(int l) {

	location[l]->siege.underattack = 1;
}

bool getLightsOff(int l) {
	return location[l]->siege.lights_off;
}

void setLightsOff(int l) {

	location[l]->siege.lights_off = 1;
}

bool hasBasicCompoundWalls(int l) {
	return location[l]->compound_walls & COMPOUND_BASIC;
}