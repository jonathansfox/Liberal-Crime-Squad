
#include "../includes.h"
const string CONST_reviewmodeB103 = "C++ Source Code Editor (with encoding)";
const string CONST_reviewmode134 = "Press Z to Assemble a New Squad.  Press T to Assign New Bases to the Squadless.";
const string CONST_reviewmode133 = "  Press U to Promote Liberals.";
const string CONST_reviewmode132 = "Press a Letter to select a squad.  1-7 to view Liberal groups.";
const string CONST_reviewmode131 = "Press Y to turn on some Music.";
const string CONST_reviewmode130 = "Press Y to turn off the Music.";
const string CONST_reviewmode129 = "Press V to Inspect Liberal finances.";
const string CONST_reviewmode128 = "8 - Review and Move Equipment (";
const string CONST_reviewmode127 = "7 - Away (";
const string CONST_reviewmode126 = "6 - The Dead (";
const string CONST_reviewmode125 = "5 - Sleepers (";
const string CONST_reviewmode124 = "4 - Justice System (";
const string CONST_reviewmode123 = "3 - Hospital (";
const string CONST_reviewmode122 = "2 - Hostages (";
const string CONST_reviewmode121 = "1 - Active Liberals (";
const string CONST_reviewmode120 = "Acting Individually";
const string CONST_reviewmode119 = "ÄÄÄÄSQUAD NAMEÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄLOCATIONÄÄÄÄÄÄÄÄÄÄÄÄACTIVITYÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ";
const string CONST_reviewmode118 = "Review your Liberals and Assemble Squads";
const string CONST_reviewmode117 = "Enlightened Liberals follow anyone. Seduced Liberals follow only their lover.";
const string CONST_reviewmode116 = "Press a letter to promote a Liberal. You cannot promote Liberals in hiding.";
const string CONST_reviewmode115 = "<LCS Leader>";
const string CONST_reviewmode114 = "<Can't Lead More>";
const string CONST_reviewmode113 = "<Refuses Promotion>";
const string CONST_reviewmode112 = "CONTACT AFTER PROMOTION";
const string CONST_reviewmode111 = "ÄÄÄÄCODE NAMEÄÄÄÄÄÄÄÄÄÄÄÄÄÄCURRENT CONTACTÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ";
const string CONST_reviewmode110 = "Promote the Elite Liberals";
const string CONST_reviewmode109 = "T to sort people.";
const string CONST_reviewmode108 = ",. to view other Base pages.";
const string CONST_reviewmode107 = "Liberals must be moved in squads to transfer between cities.";
const string CONST_reviewmode106 = "Press a Letter to assign a Base.  Press a Number to select a Base.";
const string CONST_reviewmode105 = " <Under Siege>";
const string CONST_reviewmode104 = "NEW BASE";
const string CONST_reviewmode103 = "ÄÄÄÄCODE NAMEÄÄÄÄÄÄÄÄÄÄÄÄCURRENT BASEÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ";
const string CONST_reviewmode102 = "New Bases for Squadless Liberals";
const string CONST_reviewmode101 = " with";
const string CONST_reviewmode100 = "Choose squad member to replace ";
const string CONST_reviewmode099 = "                                                                                ";
const string CONST_reviewmode097 = " has gained wisdom.                                                             ";
const string CONST_reviewmode096 = " grows colder.                                                                  ";
const string CONST_reviewmode095 = " has lost heart.                                                                ";
const string CONST_reviewmode094 = " feels sick to the stomach afterward and                                        ";
const string CONST_reviewmode091 = " by ";
const string CONST_reviewmode090 = " executes ";
const string CONST_reviewmode089 = "  C - Confirm       Any other key to continue                                   ";
const string CONST_reviewmode088 = "Killing your squad members is Not a Liberal Act.                                ";
const string CONST_reviewmode087 = " kill this squad member?                               ";
const string CONST_reviewmode086 = "Confirm you want to have ";
const string CONST_reviewmode085 = " in court.";
const string CONST_reviewmode084 = "to testify against ";
const string CONST_reviewmode083 = "The Conservative traitor has ratted you out to the police, and sworn";
const string CONST_reviewmode082 = "'s whereabouts.";
const string CONST_reviewmode081 = "A Liberal friend tips you off on ";
const string CONST_reviewmode078 = " has been released.                                                             ";
const string CONST_reviewmode076 = "If the member has low heart they may go to the police.                          ";
const string CONST_reviewmode075 = "Do you want to permanently release this squad member from the LCS?              ";
const string CONST_reviewmode073 = "What is the new code name?                                                      ";
const string CONST_reviewmode072 = "    UP/DOWN  - More Info";
const string CONST_reviewmode071 = "Press any other key to continue the Struggle";
const string CONST_reviewmode070 = "    LEFT/RIGHT - View Others";
const string CONST_reviewmode069 = "N - Change Code Name      G - Fix Gender Label";
const string CONST_reviewmode068 = "Press N to change this Automaton's Code Name";
const string CONST_reviewmode067 = "         K - Kill member";
const string CONST_reviewmode066 = "R - Remove member";
const string CONST_reviewmode065 = "Profile of a Liberal";
const string CONST_reviewmode064 = "Profile of an Automaton";
const string CONST_reviewmode063 = " T to sort people.";
const string CONST_reviewmode062 = "Reorder Liberals";
const string CONST_reviewmode061 = "Place ";
const string CONST_reviewmode060 = "Press a Letter to View Status.        Z - ";
const string CONST_reviewmode059 = "<No Contact>";
const string CONST_reviewmode058 = "Day";
const string CONST_reviewmode057 = "Days";
const string CONST_reviewmode054 = "Month";
const string CONST_reviewmode053 = "Months";
const string CONST_reviewmode052 = "Out in ";
const string CONST_reviewmode051 = "ÄÄÄÄÄÄÄ";
const string CONST_reviewmode048 = "Life Sentence";
const string CONST_reviewmode047 = " Life Sentences";
const string CONST_reviewmode044 = "DEATH ROW: ";
const string CONST_reviewmode041 = "SQUAD";
const string CONST_reviewmode040 = "Away";
const string CONST_reviewmode039 = "ÄÄÄÄCODE NAMEÄÄÄÄÄÄÄÄÄÄÄÄSKILLÄÄÄHEALTHÄÄÄLOCATIONÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ";
const string CONST_reviewmode038 = "The Liberal Crime Squad";
const string CONST_reviewmode036 = "What shall we designate this Liberal squad?                                     ";
const string CONST_reviewmode033 = "You cannot form a Squad with only Conservatives!                                ";
const string CONST_reviewmode031 = "Temporary Squad";
const string CONST_reviewmode028 = "Press a Letter to view Liberal details.                                         ";
const string CONST_reviewmode026 = "                Squad Liberals must be able to move around.                     ";
const string CONST_reviewmode023 = "           Liberals must be in the same location to form a Squad.               ";
const string CONST_reviewmode021 = "9 - Dissolve the squad.";
const string CONST_reviewmode020 = "Enter - I need no squad!";
const string CONST_reviewmode019 = "Enter - The squad is ready.";
const string CONST_reviewmode018 = "V - View a Liberal";
const string CONST_reviewmode016 = "Press a Letter to add or remove a Liberal from the squad.";
const string CONST_reviewmode015 = "AWAY";
const string CONST_reviewmode012 = "ÄÄÄÄCODE NAMEÄÄÄÄÄÄÄÄÄÄÄÄSKILLÄÄÄHEALTHÄÄÄÄÄÄÄÄÄÄÄPROFESSIONÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ";
const string CONST_reviewmode011 = "Squad: ";
const string CONST_reviewmode010 = "New Squad";
const string CONST_reviewmode009 = "The squad is full.";
const string CONST_reviewmode008 = "Assemble the squad!";
const string CONST_reviewmode007 = "getsSick.txt";
const string CONST_reviewmode006 = "methodOfExecution.txt";
const string CONST_reviewmode001 = "OEM United States - Codepage 437";
const string CONST_reviewmode000 = "Open With...";
/*
Copyright (c) 2002,2003,2004 by Tarn Adams                                            //
//
This file is part of Liberal Crime Squad.                                             //
//
Liberal Crime Squad is free software; you can redistribute it and/or modify     //
it under the terms of the GNU General Public License as published by            //
the Free Software Foundation; either version 2 of the License, or               //
(at your option) any later version.                                             //
//
Liberal Crime Squad is distributed in the hope that it will be useful,          //
but WITHOUT ANY WARRANTY; without even the implied warranty of                  //
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.   See the                  //
GNU General Public License for more details.                                    //
//
You should have received a copy of the GNU General Public License               //
along with Liberal Crime Squad; if not, write to the Free Software              //
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA   02111-1307   USA     //
*/
/*
This file was created by Chris Johnson (grundee@users.sourceforge.net)
by copying code from game.cpp.
To see descriptions of files and functions, see the list at
the bottom of includes.h in the top src folder.
*/
// Note: this file is encoded in the PC-8 / Code Page 437 / OEM-US character set
// (The same character set used by Liberal Crime Squad when it is running)
// Certain special characters won't display correctly unless your text editor is
// set to use that character set, such as this e with an accent: ‚
// In Windows Notepad with the Terminal font, OEM/DOS encoding it should work fine.
// You can set this in Notepad by going to Format->Font and choosing the Terminal font,
// then choosing OEM/DOS in the Script dropdown box.
// In Notepad++ go to the Encoding menu, Character sets, Western European, OEM-US... easy!
// In Code::Blocks's editor go to Settings->Editor->the Other Settings tab and
// then pick WINDOWS-437 from the dropdown box and then choose the radio button
// to make this the default encoding and disable auto-detection of the encoding.
// Then close the file and reopen it (since Code::Blocks detects the encoding
// when it opens the file and it can't be changed after that; what we changed was
// how it detects encoding for files it opens in the future, not files already open).
// In Microsoft Visual C++, right-click the file in the Solution Explorer,
// select CONST_reviewmode000, choose CONST_reviewmodeB103,
// then choose CONST_reviewmode001.
// In MS-DOS Editor (included with Windows as EDIT.COM in your system32 directory),
// the codepage will be correct already since it's running in a console window just
// like Liberal Crime Squad. Well OK, the encoding might be wrong, but then it's wrong
// in Liberal Crime Squad TOO, and to fix it, go to Control Panel, Regional and Language Settings,
// Advanced tab, and choose English (United States) from the dropdown box as the encoding
// for non-Unicode applications, then press OK.
// If you have a Linux or other UNIX-based system you are obviously smart enough
// to figure out for yourself how to open a file in OEM-US PC-8 codepage 437 in
// your favorite text editor. If you're on Mac OS X, well that's UNIX-based, figure
// it out for yourself.

const string blankString = "";
const string tag_value = "value";
const string tag_attribute = "attribute";
const string tag_skill = "skill";
#include "../creature/creature.h"
#include "../locations/locationsEnums.h"
#include "../log/log.h"
// for commondisplay.h
#include "../common/commondisplay.h"
#include "../common/commondisplayCreature.h"

#include "../common/getnames.h"
// for std::string getactivity(ActivityST)
//#include "../common/equipment.h"
void consolidateloot(vector<Item *>&);
void equipmentbaseassign();
#include "../common/commonactions.h"
#include "../common/commonactionsCreature.h"
// for short reviewmodeenum_to_sortingchoiceenum(short)
//#include "../common/translateid.h"
int getsquad(int);
int getpoolcreature(int);
//#include "../monthly/lcsmonthly.h"
void fundreport(char &clearformess);
void printname(Creature &cr);
#include "../cursesAlternative.h"
#include "../cursesAlternativeConstants.h"
#include "../customMaps.h"
#include "../set_color_support.h"
#include "../locations/locationsPool.h"
#include "../common/musicClass.h"
#include "../common/creaturePool.h"
const int PAGELENGTH = 19;
extern string spaceDashSpace;
extern string singleSpace;
vector<string> methodOfExecution;
vector<string> getsSick;
const string mostlyendings = "mostlyendings\\";
vector<file_and_text_collection> reviewmode_text_file_collection = {
	/*transferred via algorithm*/
	customText(&methodOfExecution, mostlyendings + CONST_reviewmode006),
	customText(&getsSick, mostlyendings + CONST_reviewmode007),
};
struct stringAndColor
{
	string str;
	ColorSetup type;
	stringAndColor(const string& str_, const ColorSetup type_) : str(str_), type(type_) { }
	stringAndColor(const ColorSetup type_, const string& str_) : str(str_), type(type_) { }
};
map<short, string> reviewStrings;
map<short, string> reviewStringsSecondLine;
vector<stringAndColor> liberalListAndColor;
void nukeAllEmptySquads(const vector<int> squadloc, const int mode);
/* base - review - assemble a squad */
void assemblesquad(squadst *cursquad)
{
	extern short mode;
	extern squadst *activesquad;
	extern long cursquadid;
	extern short interface_pgup;
	extern short interface_pgdn;
	extern short activesortingchoice[SORTINGCHOICENUM];
	extern vector<Creature *> pool;
	extern vector<squadst *> squad;
	int culloc = -1;
	if (cursquad != NULL) culloc = cursquad->squad[0]->location;
	char newsquad = 0;
	if (cursquad == NULL)
	{
		cursquad = new squadst;
		cursquad->id = cursquadid;
		cursquadid++;
		newsquad = 1;
	}
	vector<Creature *> temppool;
	for (int p = 0; p < CreaturePool::getInstance().lenpool(); p++)
		if (pool[p]->is_active_liberal() &&
			(pool[p]->location == culloc || culloc == -1))
		{
			temppool.push_back(pool[p]);
		}
	sortliberals(temppool, activesortingchoice[SORTINGCHOICE_ASSEMBLESQUAD]);
	//BUILD LIST OF BASES FOR EACH SQUAD IN CASE IT ENDS UP EMPTY
	//THEN WILL DROP ITS LOOT THERE
	// Must be declared before new squads are formed
	// In order to assure squadloc contains the locations of all current squads
	vector<int> squadloc;
	squadloc.resize(len(squad));
	for (int sl = 0; sl < len(squad); sl++)
	{
		squadloc[sl] = squad[sl]->squad[0]->location;
		if (squadloc[sl] != -1) if (LocationsPool::getInstance().getRentingType(squadloc[sl]) == RENTING_NOCONTROL)
			squadloc[sl] = -1;
	}
	int page = 0;
	while (true)
	{
		int partysize = squadsize(cursquad);
		eraseAlt();
		set_color_easy(WHITE_ON_BLACK);
		moveAlt(0, 0);
		if (partysize < 6)addstrAlt(CONST_reviewmode008);
		else addstrAlt(CONST_reviewmode009);
		if (newsquad)
		{
			mvaddstrAlt(0, 71, CONST_reviewmode010);
		}
		else
		{
			mvaddstrAlt(0, 73 - len(cursquad->name), CONST_reviewmode011);
			addstrAlt(cursquad->name);
		}
		mvaddstrAlt(1, 0, CONST_reviewmode012); // 80 characters
		int y = 2;
		for (int p = page * 19; p < len(temppool) && p < page * 19 + 19; p++)
		{
			set_color_easy(WHITE_ON_BLACK);
			mvaddcharAlt(y, 0, y + 'A' - 2); addstrAlt(spaceDashSpace);
			addstrAlt(temppool[p]->name);
			char bright = 0;
			int skill = 0;
			for (int sk = 0; sk < SKILLNUM; sk++)
			{
				skill += (int)temppool[p]->get_skill(sk);
				if (temppool[p]->get_skill_ip(sk) >= 100 + (10 * temppool[p]->get_skill(sk)) &&
					temppool[p]->get_skill(sk) < temppool[p]->skill_cap(sk, true)) bright = 1;
			}
			set_color_easy(bright ? WHITE_ON_BLACK_BRIGHT : WHITE_ON_BLACK);
			mvaddstrAlt(y, 25, skill);
			printhealthstat(*temppool[p], y, 33, FALSE);
			if (temppool[p]->squadid == cursquad->id)
			{
				set_color_easy(GREEN_ON_BLACK_BRIGHT);
				mvaddstrAlt(y, 75, CONST_reviewmode041);
			}
			else if (temppool[p]->squadid != -1)
			{
				set_color_easy(YELLOW_ON_BLACK);
				mvaddstrAlt(y, 75, CONST_reviewmode041);
			}
			else if (cursquad->squad[0] != NULL)
			{
				if (cursquad->squad[0]->location != temppool[p]->location)
				{
					set_color_easy(BLACK_ON_BLACK_BRIGHT);
					mvaddstrAlt(y, 75, CONST_reviewmode015);
				}
			}
			if (temppool[p]->align == -1) set_color_easy(RED_ON_BLACK_BRIGHT);
			else if (temppool[p]->align == 0) set_color_easy(WHITE_ON_BLACK_BRIGHT);
			else set_color_easy(GREEN_ON_BLACK_BRIGHT);
			mvaddstrAlt(y, 50, temppool[p]->get_type_name());
			y++;
		}
		set_color_easy(WHITE_ON_BLACK);
		mvaddstrAlt(22, 0, CONST_reviewmode016);
		mvaddstrAlt(23, 0, addpagestr() + CONST_reviewmode063);
		mvaddstrAlt(23, 50, CONST_reviewmode018);
		moveAlt(24, 0);
		if (partysize > 0) addstrAlt(CONST_reviewmode019);
		else addstrAlt(CONST_reviewmode020);
		if (partysize > 0) set_color_easy(WHITE_ON_BLACK);
		else set_color_easy(BLACK_ON_BLACK_BRIGHT);
		mvaddstrAlt(24, 40, CONST_reviewmode021);
		int c = getkeyAlt();
		//PAGE UP
		if ((c == interface_pgup || c == KEY_UP || c == KEY_LEFT) && page > 0) page--;
		//PAGE DOWN
		if ((c == interface_pgdn || c == KEY_DOWN || c == KEY_RIGHT) && (page + 1) * 19 < len(temppool)) page++;
		if (c >= 'a'&&c <= 's')
		{
			int p = page * 19 + c - 'a';
			if (p < len(temppool))
			{
				char conf = 1;
				if (cursquad->squad[0] != NULL)
				{
					if (cursquad->squad[0]->location != temppool[p]->location)
					{
						set_color_easy(RED_ON_BLACK_BRIGHT);
						mvaddstrAlt(22, 0, CONST_reviewmode099); // 80 spaces
						mvaddstrAlt(23, 0, CONST_reviewmode023); // 80 characters
						mvaddstrAlt(24, 0, CONST_reviewmode099); // 80 spaces
						pressAnyKey();
						conf = 0;
					}
				}
				if (!temppool[p]->canwalk() &&
					!(temppool[p]->flag & CREATUREFLAG_WHEELCHAIR))
				{
					set_color_easy(RED_ON_BLACK_BRIGHT);
					mvaddstrAlt(22, 0, CONST_reviewmode099); // 80 spaces
					mvaddstrAlt(23, 0, CONST_reviewmode026); // 80 characters
					mvaddstrAlt(24, 0, CONST_reviewmode099); // 80 spaces
					pressAnyKey();
					conf = 0;
				}
				if (conf)
				{
					if (temppool[p]->squadid == cursquad->id)
					{
						bool flipstart = 0;
						for (int pt = 0; pt < 6; pt++)
						{
							if (cursquad->squad[pt] == temppool[p])
							{
								flipstart = 1;
								cursquad->squad[pt]->squadid = -1;
							}
							if (flipstart&&pt < 5)cursquad->squad[pt] = cursquad->squad[pt + 1];
						}
						if (flipstart)cursquad->squad[5] = NULL;
					}
					else if (partysize < 6)
					{
						for (int pt = 0; pt < 6; pt++)
						{
							if (cursquad->squad[pt] == NULL)
							{
								removesquadinfo(*temppool[p]);
								cursquad->squad[pt] = temppool[p];
								temppool[p]->squadid = cursquad->id;
								break;
							}
						}
					}
				}
			}
		}
		if (c == 't')
		{
			sorting_prompt(SORTINGCHOICE_ASSEMBLESQUAD);
			sortliberals(temppool, activesortingchoice[SORTINGCHOICE_ASSEMBLESQUAD], true);
		}
		if (c == 'v')
		{
			set_color_easy(WHITE_ON_BLACK_BRIGHT);
			mvaddstrAlt(22, 0, CONST_reviewmode028); // 80 characters
			mvaddstrAlt(23, 0, CONST_reviewmode099); // 80 spaces
			mvaddstrAlt(24, 0, CONST_reviewmode099); // 80 spaces
			int c2 = getkeyAlt();
			if (c2 >= 'a'&&c2 <= 's')
			{
				int p = page * 19 + c2 - 'a';
				if (p < len(temppool))
				{
					//Create a temporary squad from which to view this character - even if they already have a squad.
					squadst *oldactivesquad = activesquad;
					int oldSquadID = temppool[p]->squadid;
					//create a temp squad containing just this liberal
					activesquad = new squadst;
					strcpy(activesquad->name, CONST_reviewmode031.c_str());
					activesquad->id = cursquadid;
					activesquad->squad[0] = temppool[p];
					temppool[p]->squadid = activesquad->id;
					fullstatus(0);
					delete_and_nullify(activesquad);
					temppool[p]->squadid = oldSquadID;
					activesquad = oldactivesquad;
				}
			}
		}
		if (c == 'x' || c == ENTER || c == ESC || c == SPACEBAR)
		{
			//CHECK IF GOOD (either has at least one Liberal or is empty)
			bool good = true; // Start off at true for empty squads
			for (int p = 0; p < 6; p++)
				if (cursquad->squad[p])
				{  // It is good if either there is at least one Liberal, or if the squad is completely empty
					if (cursquad->squad[p]->align == 1)
					{
						good = true; break;
					} // We found a Liberal, it's good
					else good = false; // We found a non-Liberal, this is bad unless we can find a Liberal too
				}
			if (good) break;
			else
			{  // At this point we have a non-empty squad, none of whose members are Liberal
				set_color_easy(RED_ON_BLACK_BRIGHT);
				mvaddstrAlt(22, 0, CONST_reviewmode099); // 80 spaces
				mvaddstrAlt(23, 0, CONST_reviewmode033); // 80 characters
				mvaddstrAlt(24, 0, CONST_reviewmode099); // 80 spaces
				pressAnyKey();
			}
		}
		if (c == '9')
		{
			for (int p = 0; p < 6; p++)
			{
				if (cursquad->squad[p] != NULL)
				{
					cursquad->squad[p]->squadid = -1;
					cursquad->squad[p] = NULL;
				}
			}
		}
	}
	//FINALIZE NEW SQUADS
	if (newsquad)
	{
		bool hasmembers = squadsize(cursquad) > 0;
		if (hasmembers)
		{
			mvaddstrAlt(22, 0, CONST_reviewmode099); // 80 spaces
			mvaddstrAlt(23, 0, CONST_reviewmode036); // 80 characters
			mvaddstrAlt(24, 0, CONST_reviewmode099); // 80 spaces
			enter_name(24, 0, cursquad->name, SQUAD_NAMELEN, CONST_reviewmode038.c_str());
			squad.push_back(cursquad);
		}
		else delete cursquad;
	}

	nukeAllEmptySquads(squadloc, mode);
}
void review_mode(short mode)
{
	extern Log gamelog;
	extern int stat_kills;
	extern short interface_pgup;
	extern short interface_pgdn;
	extern short activesortingchoice[SORTINGCHOICENUM];
	extern vector<Creature *> pool;
	extern vector<squadst *> squad;
	vector<Creature *> temppool;
	Creature *swap = NULL;
	int swapPos = 0;
	for (int p = 0; p < CreaturePool::getInstance().lenpool(); p++)
	{
		switch (mode)
		{
		case REVIEWMODE_LIBERALS:
			if (pool[p]->is_active_liberal())
				temppool.push_back(pool[p]);
			break;
		case REVIEWMODE_HOSTAGES:
			if (pool[p]->align != ALIGN_LIBERAL && pool[p]->alive)
				temppool.push_back(pool[p]);
			break;
		case REVIEWMODE_CLINIC:
			if (pool[p]->clinic && pool[p]->alive)
				temppool.push_back(pool[p]);
			break;
		case REVIEWMODE_JUSTICE:
			if (pool[p]->is_imprisoned())
				temppool.push_back(pool[p]);
			break;
		case REVIEWMODE_SLEEPERS:
			if (pool[p]->is_lcs_sleeper())
				temppool.push_back(pool[p]);
			break;
		case REVIEWMODE_DEAD:
			if (!pool[p]->alive)
				temppool.push_back(pool[p]);
			break;
		case REVIEWMODE_AWAY:
			if ((pool[p]->dating || pool[p]->hiding) && pool[p]->alive)
				temppool.push_back(pool[p]);
			break;
		}
	}
	if (!len(temppool)) return;
	sortliberals(temppool, activesortingchoice[reviewmodeenum_to_sortingchoiceenum(mode)]);
	int page = 0;
	while (true)
	{
		eraseAlt();
		set_color_easy(WHITE_ON_BLACK);
		mvaddstrAlt(0, 0, reviewStrings[mode]);
		mvaddstrAlt(1, 0, CONST_reviewmode039); // 80 characters
		mvaddstrAlt(1, 57, reviewStringsSecondLine[mode]);
		int y = 2;
		for (int p = page * 19; p < len(temppool) && p < page * 19 + 19; p++)
		{
			set_color_easy(WHITE_ON_BLACK);
			mvaddcharAlt(y, 0, y + 'A' - 2); addstrAlt(spaceDashSpace);
			addstrAlt(temppool[p]->name);
			char bright = 0;
			int skill = 0;
			for (int sk = 0; sk < SKILLNUM; sk++)
			{
				skill += (int)temppool[p]->get_skill(sk);
				if (temppool[p]->get_skill_ip(sk) >= 100 + (10 * temppool[p]->get_skill(sk)) &&
					temppool[p]->get_skill(sk) < temppool[p]->skill_cap(sk, true))bright = 1;
			}
			set_color_easy(bright ? WHITE_ON_BLACK_BRIGHT : WHITE_ON_BLACK);
			mvaddstrAlt(y, 25, skill);
			printhealthstat(*temppool[p], y, 33, TRUE);
			if (mode == REVIEWMODE_JUSTICE)set_color_easy(YELLOW_ON_BLACK_BRIGHT);
			else set_color_easy(WHITE_ON_BLACK);
			moveAlt(y, 42);
			if (temppool[p]->location == -1) addstrAlt(CONST_reviewmode040);
			else addstrAlt(LocationsPool::getInstance().getLocationNameWithGetnameMethod(temppool[p]->location, true, true));
			moveAlt(y, 57);
			switch (mode)
			{
			case REVIEWMODE_LIBERALS:
			{
				char usepers = 1;
				if (temppool[p]->squadid != -1)
				{
					int sq = getsquad(temppool[p]->squadid);
					if (sq != -1)
					{
						if (squad[sq]->activity.type != ACTIVITY_NONE)
						{
							set_color_easy(GREEN_ON_BLACK_BRIGHT);
							addstrAlt(CONST_reviewmode041);
							usepers = 0;
						}
					}
				}
				if (usepers)
				{  // Let's add some color here...
					set_activity_color(temppool[p]->activity.type);
					addstrAlt(getactivity(temppool[p]->activity));
				}
				break;
			}
			case REVIEWMODE_HOSTAGES:
			{
				set_color_easy(MAGENTA_ON_BLACK_BRIGHT);
				addstrAlt(temppool[p]->joindays);
				addstrAlt(singleSpace);
				if (temppool[p]->joindays > 1)addstrAlt(CONST_reviewmode057);
				else addstrAlt(CONST_reviewmode058);
				break;
			}
			case REVIEWMODE_JUSTICE:
			{
				if (temppool[p]->deathpenalty&&temppool[p]->sentence != 0 &&
					LocationsPool::getInstance().getLocationType(temppool[p]->location) == SITE_GOVERNMENT_PRISON)
				{
					set_color_easy(RED_ON_BLACK_BRIGHT);
					addstrAlt(CONST_reviewmode044);
					addstrAlt(temppool[p]->sentence);
					addstrAlt(singleSpace);
					if (temppool[p]->sentence > 1)addstrAlt(CONST_reviewmode053);
					else addstrAlt(CONST_reviewmode054);
				}
				else if (temppool[p]->sentence <= -1 &&
					LocationsPool::getInstance().getLocationType(temppool[p]->location) == SITE_GOVERNMENT_PRISON)
				{
					set_color_easy(WHITE_ON_BLACK);
					if (temppool[p]->sentence < -1)
					{
						addstrAlt(-(temppool[p]->sentence));
						addstrAlt(CONST_reviewmode047);
					}
					else
						addstrAlt(CONST_reviewmode048);
				}
				else if (temppool[p]->sentence != 0 &&
					LocationsPool::getInstance().getLocationType(temppool[p]->location) == SITE_GOVERNMENT_PRISON)
				{
					set_color_easy(YELLOW_ON_BLACK_BRIGHT);
					addstrAlt(temppool[p]->sentence);
					addstrAlt(singleSpace);
					if (temppool[p]->sentence > 1)addstrAlt(CONST_reviewmode053);
					else addstrAlt(CONST_reviewmode054);
				}
				else
				{
					set_color_easy(BLACK_ON_BLACK_BRIGHT);
					addstrAlt(CONST_reviewmode051); // 7 characters
				}
				break;
			}
			case REVIEWMODE_CLINIC:
			{
				set_color_easy(CYAN_ON_BLACK_BRIGHT);
				addstrAlt(CONST_reviewmode052);
				addstrAlt(temppool[p]->clinic);
				addstrAlt(singleSpace);
				if (temppool[p]->clinic > 1)addstrAlt(CONST_reviewmode053);
				else addstrAlt(CONST_reviewmode054);
				break;
			}
			case REVIEWMODE_SLEEPERS:
			{
				if (temppool[p]->align == -1)set_color_easy(RED_ON_BLACK_BRIGHT);
				else if (temppool[p]->align == 0)set_color_easy(WHITE_ON_BLACK_BRIGHT);
				else set_color_easy(GREEN_ON_BLACK_BRIGHT);
				addstrAlt(temppool[p]->get_type_name());
				break;
			}
			case REVIEWMODE_DEAD:
			{
				set_color_easy(MAGENTA_ON_BLACK_BRIGHT);
				addstrAlt(temppool[p]->deathdays);
				addstrAlt(singleSpace);
				if (temppool[p]->deathdays > 1)addstrAlt(CONST_reviewmode057);
				else addstrAlt(CONST_reviewmode058);
				break;
			}
			case REVIEWMODE_AWAY:
			{
				set_color_easy(CYAN_ON_BLACK_BRIGHT);
				if (temppool[p]->hiding != -1)
				{
					addstrAlt(temppool[p]->dating + temppool[p]->hiding);
					addstrAlt(singleSpace);
					if (temppool[p]->dating + temppool[p]->hiding > 1)
						addstrAlt(CONST_reviewmode057);
					else addstrAlt(CONST_reviewmode058);
				}
				else addstrAlt(CONST_reviewmode059);
				break;
			}
			}
			y++;
		}
		set_color_easy(WHITE_ON_BLACK);
		mvaddstrAlt(22, 0, CONST_reviewmode060);
		if (swap) { addstrAlt(CONST_reviewmode061); addstrAlt(swap->name); }
		else addstrAlt(CONST_reviewmode062);
		mvaddstrAlt(23, 0, addpagestr() + CONST_reviewmode063);
		int c = getkeyAlt();
		//PAGE UP
		if ((c == interface_pgup || c == KEY_UP || c == KEY_LEFT) && page > 0) page--;
		//PAGE DOWN
		if ((c == interface_pgdn || c == KEY_DOWN || c == KEY_RIGHT) && (page + 1) * 19 < len(temppool)) page++;
		if (c >= 'a'&&c <= 's')
		{
			int p = page * 19 + (int)(c - 'a');
			if (p < len(temppool))
			{
				int page = 0;
				//const int pagenum=2;
				while (true)
				{
					eraseAlt();
					moveAlt(0, 0);
					if (temppool[p]->align != 1)
					{
						set_color_easy(RED_ON_BLACK_BRIGHT);
						addstrAlt(CONST_reviewmode064);
					}
					else
					{
						set_color_easy(GREEN_ON_BLACK_BRIGHT);
						addstrAlt(CONST_reviewmode065);
					}
					if (page == 0) printliberalstats(*temppool[p]);
					else if (page == 1) printliberalskills(*temppool[p]);
					else if (page == 2) printliberalcrimes(*temppool[p]);
					// Add removal of squad members member
					moveAlt(22, 0);
					if (temppool[p]->is_active_liberal() &&
						temppool[p]->hireid != -1)  // If alive and not own boss? (suicide?)
					{
						addstrAlt(CONST_reviewmode066);
						int boss = getpoolcreature(temppool[p]->hireid);
						if (pool[boss]->location == temppool[p]->location)
							addstrAlt(CONST_reviewmode067);
					}
					moveAlt(23, 0);
					if (temppool[p]->align != 1) addstrAlt(CONST_reviewmode068);
					else addstrAlt(CONST_reviewmode069);
					if (len(temppool) > 1) addstrAlt(CONST_reviewmode070);
					mvaddstrAlt(24, 0, CONST_reviewmode071);
					addstrAlt(CONST_reviewmode072);
					int c = getkeyAlt();
					if (len(temppool) > 1 && ((c == KEY_LEFT) || (c == KEY_RIGHT)))
					{
						int sx = 1;
						if (c == KEY_LEFT) sx = -1;
						p = (p + len(temppool) + sx) % len(temppool);
						continue;
					}
					if (c == KEY_DOWN)
					{
						page++;
						if (page > 2) page = 0;
						continue;
					}
					if (c == KEY_UP)
					{
						page--;
						if (page < 0) page = 2;
						continue;
					}
					if (c == 'n')
					{
						set_color_easy(WHITE_ON_BLACK);
						mvaddstrAlt(23, 0, CONST_reviewmode073); // 80 characters
						mvaddstrAlt(24, 0, CONST_reviewmode099); // 80 spaces
						enter_name(24, 0, temppool[p]->name, CREATURE_NAMELEN, temppool[p]->propername);
					}
					else if (c == 'g' && temppool[p]->align == 1)
					{
						temppool[p]->gender_liberal++;
						if (temppool[p]->gender_liberal > 2)
							temppool[p]->gender_liberal = 0;
					}
					else if (c == 'r' && temppool[p]->is_active_liberal() &&
						temppool[p]->hireid != -1)  // If alive and not own boss? (suicide?)
					{
						int boss = getpoolcreature(temppool[p]->hireid);
						set_color_easy(WHITE_ON_BLACK);
						mvaddstrAlt(22, 0, CONST_reviewmode075); // 80 characters
						mvaddstrAlt(23, 0, CONST_reviewmode076); // 80 characters
						mvaddstrAlt(24, 0, CONST_reviewmode089); // 80 characters
						int c = getkeyAlt();
						if (c == 'c')
						{
							// Release squad member
							mvaddstrAlt(22, 0, temppool[p]->name, gamelog);
							addstrAlt(CONST_reviewmode078, gamelog); // 80 characters
							gamelog.newline(); //New line.
							mvaddstrAlt(23, 0, CONST_reviewmode099); // 80 spaces
							mvaddstrAlt(24, 0, CONST_reviewmode099); // 80 spaces
							pressAnyKey();
							// Chance of member going to police if boss has criminal record and
							// if they have low heart
							// TODO: Do law check against other members?
							if (temppool[p]->get_attribute(ATTRIBUTE_HEART, true) < temppool[p]->get_attribute(ATTRIBUTE_WISDOM, true) + LCSrandom(5)
								&& iscriminal(*pool[boss]))
							{
								set_color_easy(CYAN_ON_BLACK_BRIGHT);
								mvaddstrAlt(22, 0, CONST_reviewmode081, gamelog);
								addstrAlt(temppool[p]->name, gamelog);
								addstrAlt(CONST_reviewmode082, gamelog);
								gamelog.newline(); //New line.
								mvaddstrAlt(24, 0, CONST_reviewmode083, gamelog);
								gamelog.newline(); //New line.
								mvaddstrAlt(25, 0, CONST_reviewmode084, gamelog);
								addstrAlt(pool[boss]->name, gamelog);
								addstrAlt(CONST_reviewmode085, gamelog);
								criminalize(*pool[boss], LAWFLAG_RACKETEERING);
								pool[boss]->confessions++;
								// TODO: Depending on the crime increase heat or make seige
								if (LocationsPool::getInstance().getHeat(pool[boss]->base) > 20)
									LocationsPool::getInstance().setSiegetimeuntillocated(pool[boss]->base, 3);
								else
									LocationsPool::getInstance().addHeat(pool[boss]->base, 20);
							}
							gamelog.nextMessage(); //Write out buffer to prepare for next message.
												   // Remove squad member
							removesquadinfo(*temppool[p]);
							cleangonesquads();
							delete_and_remove(temppool, p, pool, getpoolcreature(temppool[p]->id));
							break;
						}
					}
					else if (c == 'k' && temppool[p]->is_active_liberal() &&
						temppool[p]->hireid != -1)  // If alive and not own boss? (suicide?)
					{
						// Kill squad member
						int boss = getpoolcreature(temppool[p]->hireid);
						if (pool[boss]->location != temppool[p]->location) break;
						set_color_easy(WHITE_ON_BLACK);
						mvaddstrAlt(22, 0, CONST_reviewmode086); // 25 characters (25+55=80)
						addstrAlt(pool[boss]->name);
						addstrAlt(CONST_reviewmode087); // 55 characters (25+55=80)
						mvaddstrAlt(23, 0, CONST_reviewmode088); // 80 characters
						mvaddstrAlt(24, 0, CONST_reviewmode089); // 80 characters
						int c = getkeyAlt();
						if (c == 'c')
						{
							temppool[p]->die();
							cleangonesquads();
							stat_kills++;
							mvaddstrAlt(22, 0, pool[boss]->name, gamelog);
							addstrAlt(CONST_reviewmode090, gamelog); // 10 characters (10+4+66=80)
							addstrAlt(temppool[p]->name, gamelog);
							addstrAlt(CONST_reviewmode091, gamelog); // 4 characters (10+4+66=80)
							addstrAlt(pickrandom(methodOfExecution), gamelog);
							mvaddstrAlt(23, 0, CONST_reviewmode099); // 80 spaces
							mvaddstrAlt(24, 0, CONST_reviewmode099); // 80 spaces
							pressAnyKey();
							if (boss != -1)
							{
								if (LCSrandom(pool[boss]->get_attribute(ATTRIBUTE_HEART, false)) > LCSrandom(3))
								{
									set_color_easy(GREEN_ON_BLACK_BRIGHT);
									gamelog.newline(); //New line.
									mvaddstrAlt(22, 0, pool[boss]->name, gamelog);
									addstrAlt(CONST_reviewmode094, gamelog); // 80 characters
									pool[boss]->adjust_attribute(ATTRIBUTE_HEART, -1);
									// this sentence probably takes more than 80 characters so use 2 lines and break it here
									gamelog.newline(); //New line.
									mvaddstrAlt(23, 0, pickrandom(getsSick), gamelog);
									gamelog.newline(); //New line.
									mvaddstrAlt(24, 0, pool[boss]->name, gamelog);
									addstrAlt(CONST_reviewmode095, gamelog); // 80 characters
									pressAnyKey();
								}
								else if (!LCSrandom(3))
								{
									gamelog.newline(); //New line here too.
									set_color_easy(CYAN_ON_BLACK_BRIGHT);
									mvaddstrAlt(22, 0, pool[boss]->name, gamelog);
									addstrAlt(CONST_reviewmode096, gamelog); // 80 characters
									pool[boss]->adjust_attribute(ATTRIBUTE_WISDOM, +1);
									gamelog.newline(); //New line.
									mvaddstrAlt(24, 0, pool[boss]->name, gamelog);
									addstrAlt(CONST_reviewmode097, gamelog); // 80 characters
									pressAnyKey();
								}
							}
							gamelog.nextMessage(); //Write buffer out to prepare for next message.
							break;
						}
					}
					else break;
				}
			}
		}
		if (c == 't')
		{
			sorting_prompt(reviewmodeenum_to_sortingchoiceenum(mode));
			sortliberals(temppool, activesortingchoice[reviewmodeenum_to_sortingchoiceenum(mode)], true);
		}
		// Reorder squad
		if (c == 'z')
		{
			if (len(temppool) <= 1) continue;
			mvaddstrAlt(22, 0, CONST_reviewmode099); // 80 spaces
			mvaddstrAlt(23, 0, CONST_reviewmode099); // 80 spaces
			set_color_easy(WHITE_ON_BLACK_BRIGHT);
			mvaddstrAlt(22, 8, CONST_reviewmode100);
			if (!swap) {
				int c = getkeyAlt();
				if (c == 'x' || c == ENTER || c == ESC || c == SPACEBAR) break;
				if (c<'a' || c>'s') continue; // Not within correct range
											  // Get first member to swap
				int p = page * 19 + c - 'a';
				if (p < len(temppool)) swap = temppool[swapPos = p];
			}
			else { // non-null swap
				addstrAlt(swap->name);
				addstrAlt(CONST_reviewmode101);
				int c = getkeyAlt();
				if (c == 'x' || c == ENTER || c == ESC || c == SPACEBAR) break;
				if (c<'a' || c>'s') continue; // Not within correct range
				int p = page * 19 + c - 'a';
				if (p < len(temppool) && temppool[p] != swap)
				{
					Creature* swap2 = temppool[p];
					for (int i = 0; i < CreaturePool::getInstance().lenpool(); i++)
						if (pool[i]->id == swap->id)
						{
							pool.erase(pool.begin() + i);
							break;
						}
					for (int i = 0; i < CreaturePool::getInstance().lenpool(); i++)
						if (pool[i]->id == swap2->id)
						{
							pool.insert(pool.begin() + i + (swapPos < p), swap);
							break;
						}
					temppool.erase(temppool.begin() + swapPos);
					temppool.insert(temppool.begin() + p, swap);
					swap = NULL;
				}
			}
		}
		if (c == 'x' || c == ENTER || c == ESC || c == SPACEBAR) break;
	}
}
/* base - review - assign new bases to the squadless */
void squadlessbaseassign()
{
	extern bool multipleCityMode;
	extern short interface_pgup;
	extern short interface_pgdn;
	extern short activesortingchoice[SORTINGCHOICENUM];
	extern vector<Creature *> pool;
	int page_lib = 0, page_loc = 0, selectedbase = 0;
	vector<Creature *> temppool;
	for (int p = 0; p < CreaturePool::getInstance().lenpool(); p++) if (pool[p]->is_active_liberal() && pool[p]->squadid == -1) temppool.push_back(pool[p]);
	if (!len(temppool)) return;
	sortliberals(temppool, activesortingchoice[SORTINGCHOICE_BASEASSIGN]);
	vector<int> temploc;
	for (int l = 0; l < LocationsPool::getInstance().lenpool(); l++) if (LocationsPool::getInstance().getRentingType(l) >= 0 && !LocationsPool::getInstance().isThereASiegeHere(l)) temploc.push_back(l);
	if (!len(temploc)) return;
	while (true)
	{
		eraseAlt();
		set_color_easy(WHITE_ON_BLACK);
		printfunds();
		mvaddstrAlt(0, 0, CONST_reviewmode102);
		mvaddstrAlt(1, 0, CONST_reviewmode103); // 80 characters
		mvaddstrAlt(1, 51, CONST_reviewmode104);
		for (int p = page_lib * 19, y = 2; p < len(temppool) && p < page_lib * 19 + 19; p++, y++)
		{
			// Red name if location under siege
			if (temppool[p]->base == temppool[p]->location &&
				LocationsPool::getInstance().isThereASiegeHere(temppool[p]->base))
				set_color_easy(RED_ON_BLACK_BRIGHT);
			else if (multipleCityMode && LocationsPool::getInstance().getLocationCity(temppool[p]->base) != LocationsPool::getInstance().getLocationCity(temploc[selectedbase]))
				set_color_easy(BLACK_ON_BLACK_BRIGHT);
			else set_color_easy(WHITE_ON_BLACK);
			mvaddcharAlt(y, 0, y + 'A' - 2); addstrAlt(spaceDashSpace);
			addstrAlt(temppool[p]->name);
			mvaddstrAlt(y, 25, LocationsPool::getInstance().getLocationNameWithGetnameMethod(temppool[p]->base, true, true));
			if (LocationsPool::getInstance().isThereASiegeHere(temppool[p]->base))
				addstrAlt(CONST_reviewmode105);
		}
		for (int p = page_loc * 9, y = 2; p < len(temploc) && p < page_loc * 9 + 9; p++, y++)
		{
			if (p == selectedbase)set_color_easy(WHITE_ON_BLACK_BRIGHT);
			else set_color_easy(WHITE_ON_BLACK);
			mvaddcharAlt(y, 51, y + '1' - 2); addstrAlt(spaceDashSpace);
			addstrAlt(LocationsPool::getInstance().getLocationNameWithGetnameMethod(temploc[p], true, true));
		}
		set_color_easy(WHITE_ON_BLACK);
		mvaddstrAlt(21, 0, CONST_reviewmode106);
		mvaddstrAlt(22, 0, CONST_reviewmode107);
		if (len(temppool) > 19)
		{
			mvaddstrAlt(23, 0, addpagestr());
		}
		if (len(temploc) > 9)
		{
			mvaddstrAlt(24, 0, CONST_reviewmode108);
		}
		mvaddstrAlt(23, 35, CONST_reviewmode109);
		int c = getkeyAlt();
		//PAGE UP (people)
		if ((c == interface_pgup || c == KEY_UP || c == KEY_LEFT) && page_lib > 0) page_lib--;
		//PAGE DOWN (people)
		if ((c == interface_pgdn || c == KEY_DOWN || c == KEY_RIGHT) && (page_lib + 1) * 19 < len(temppool)) page_lib++;
		//PAGE UP (locations)
		if (c == ','&&page_loc > 0) page_loc--;
		//PAGE DOWN (locations)
		if (c == '.' && (page_loc + 1) * 9 < len(temploc)) page_loc++;
		if (c >= 'a'&&c <= 's')
		{
			int p = page_lib * 19 + c - 'a';
			// Assign new base, IF the selected letter is a liberal, AND the Liberal is not under siege or in a different city
			if (p < len(temppool)
				&& !(temppool[p]->base == temppool[p]->location && LocationsPool::getInstance().isThereASiegeHere(temppool[p]->base))
				&& !(multipleCityMode && LocationsPool::getInstance().getLocationCity(temppool[p]->base) != LocationsPool::getInstance().getLocationCity(temploc[selectedbase])))
			{
				temppool[p]->base = temploc[selectedbase];
			}
		}
		if (c >= '1'&&c <= '9')
		{
			int p = page_loc * 9 + c - '1';
			if (p < len(temploc)) selectedbase = p;
		}
		if (c == 't')
		{
			sorting_prompt(SORTINGCHOICE_BASEASSIGN);
			sortliberals(temppool, activesortingchoice[SORTINGCHOICE_BASEASSIGN], true);
		}
		if (c == 'x' || c == ENTER || c == ESC || c == SPACEBAR) break;
	}
}
void sortbyhire(vector<Creature *> &temppool, vector<int> &level)
{
	vector<Creature *> newpool;
	level.clear();
	for (int i = len(temppool) - 1; i >= 0; i--)
		if (temppool[i]->hireid == -1)
		{
			newpool.insert(newpool.begin(), temppool[i]);
			level.insert(level.begin(), 0);
			temppool.erase(temppool.begin() + i);
		}
	bool changed;
	do
	{
		changed = false;
		for (int i = 0; i < len(newpool); i++)
			for (int j = len(temppool) - 1; j >= 0; j--)
				if (temppool[j]->hireid == newpool[i]->id)
				{
					newpool.insert(newpool.begin() + i + 1, temppool[j]);
					level.insert(level.begin() + i + 1, level[i] + 1);
					temppool.erase(temppool.begin() + j);
					changed = true;
				}
	} while (changed);
	temppool.clear();
	for (int p = 0; p < len(newpool); p++)
		temppool.push_back(newpool[p]);
}
/* base - review - promote liberals */
void promoteliberals()
{
	extern short interface_pgup;
	extern short interface_pgdn;
	extern vector<Creature *> pool;
	vector<Creature *> temppool;
	vector<int> level;
	for (int p = 0; p < CreaturePool::getInstance().lenpool(); p++)
		if (pool[p]->alive&&pool[p]->align == 1)
			temppool.push_back(pool[p]);
	if (!len(temppool)) return;
	//SORT
	sortbyhire(temppool, level);
	//PROMOTE
	int page = 0;
	while (true)
	{
		eraseAlt();
		set_color_easy(WHITE_ON_BLACK);
		printfunds();
		mvaddstrAlt(0, 0, CONST_reviewmode110);
		mvaddstrAlt(1, 0, CONST_reviewmode111); // 80 characters
		mvaddstrAlt(1, 54, CONST_reviewmode112);
		int y = 2;
		for (int p = page * PAGELENGTH; p < len(temppool) && p < page*PAGELENGTH + PAGELENGTH; p++)
		{
			set_color_easy(WHITE_ON_BLACK);
			mvaddcharAlt(y, 0, y + 'A' - 2); addstrAlt(spaceDashSpace);
			moveAlt(y, 27);
			bool iAmTheLeader = true;
			for (int p2 = 0; p2 < CreaturePool::getInstance().lenpool() && iAmTheLeader; p2++)
			{
				if (pool[p2]->alive == 1 && pool[p2]->id == temppool[p]->hireid)
				{
					printname(*pool[p2]);
					moveAlt(y, 54);
					for (int p3 = 0; p3 < CreaturePool::getInstance().lenpool(); p3++)
					{
						if (pool[p3]->alive == 1 && pool[p3]->id == pool[p2]->hireid)
						{
							if (temppool[p]->flag&CREATUREFLAG_LOVESLAVE)
								addstrAlt(CONST_reviewmode113);
							else if (!subordinatesleft(*pool[p3]) && !(temppool[p]->flag&CREATUREFLAG_BRAINWASHED))
								addstrAlt(CONST_reviewmode114);
							else
								printname(*pool[p3]);
							break;
						}
					}
					iAmTheLeader = false;
				}
			}
			if (iAmTheLeader) addstrAlt(CONST_reviewmode115);
			moveAlt(y++, 4 + level[p]);
			printname(*temppool[p]);
		}
		moveAlt(21, 0);
		for (stringAndColor s : liberalListAndColor) {
			set_color_easy(s.type);
			addstrAlt(s.str);
		}
		set_color_easy(WHITE_ON_BLACK);
		mvaddstrAlt(22, 0, CONST_reviewmode116);
		mvaddstrAlt(23, 0, CONST_reviewmode117);
		if (len(temppool) > PAGELENGTH)
		{
			mvaddstrAlt(24, 0, addpagestr());
		}
		int c = getkeyAlt();
		//PAGE UP
		if ((c == interface_pgup || c == KEY_UP || c == KEY_LEFT) && page > 0) page--;
		//PAGE DOWN
		if ((c == interface_pgdn || c == KEY_DOWN || c == KEY_RIGHT) && (page + 1)*PAGELENGTH < len(temppool)) page++;
		if (c >= 'a'&&c <= 'a' + PAGELENGTH)
		{
			int p = page * PAGELENGTH + (int)(c - 'a');
			// *JDS* can't promote liberals in hiding OR loveslaves
			if (p < len(temppool) && !temppool[p]->hiding && !(temppool[p]->flag&CREATUREFLAG_LOVESLAVE))
			{
				for (int p2 = 0; p2 < CreaturePool::getInstance().lenpool(); p2++)
				{
					if (pool[p2]->alive == 1 && pool[p2]->id == temppool[p]->hireid)
					{
						addstrAlt(pool[p2]->name);
						for (int p3 = 0; p3 < CreaturePool::getInstance().lenpool(); p3++)
						{
							// Can't promote if new boss can't accept more subordinates
							if (pool[p3]->alive == 1 && pool[p3]->id == pool[p2]->hireid &&
								(temppool[p]->flag&CREATUREFLAG_BRAINWASHED || subordinatesleft(*pool[p3])))
							{
								temppool[p]->hireid = pool[p2]->hireid;
								sortbyhire(temppool, level);
								break;
							}
						}
						break;
					}
				}
			}
		}
		if (c == 'x' || c == ENTER || c == ESC || c == SPACEBAR) break;
	}
}
void setColorBasedOnSiege(const int cursite, const int y, const bool p);
int consolidateSiegeLoot();
/* base - review and reorganize liberals */
void review()
{
	extern MusicClass music;
	extern squadst *activesquad;
	extern short interface_pgup;
	extern short interface_pgdn;
	extern vector<Creature *> pool;
	extern vector<squadst *> squad;
	int page = 0;
	while (true)
	{
		music.play(MUSIC_REVIEWMODE);
		eraseAlt();
		set_color_easy(WHITE_ON_BLACK);
		mvaddstrAlt(0, 0, CONST_reviewmode118);
		mvaddstrAlt(1, 0, CONST_reviewmode119); // 80 characters
		int n[8] = { 0,0,0,0,0,0,0,0 }, y = 2;
		for (int p = 0; p < CreaturePool::getInstance().lenpool(); p++)
		{
			if (pool[p]->is_active_liberal()) n[0]++; // Active Liberals
			if (pool[p]->align != ALIGN_LIBERAL && pool[p]->alive) n[1]++; // Hostages
			if (pool[p]->clinic && pool[p]->alive) n[2]++; // Hospital
			if (pool[p]->is_imprisoned()) n[3]++; // Justice System
			if (pool[p]->is_lcs_sleeper()) n[4]++; // Sleepers
			if (!pool[p]->alive) n[5]++; // The Dead
			if ((pool[p]->dating || pool[p]->hiding) && pool[p]->alive) n[6]++; // Away
		}
		n[7] += consolidateSiegeLoot();

		for (int p = page * 19; p < len(squad) + REVIEWMODENUM + 1 && p < page * 19 + 19; p++, y++)
		{
			if (p < len(squad))
			{
				set_color_easy(activesquad == squad[p] ? WHITE_ON_BLACK_BRIGHT : WHITE_ON_BLACK);
				mvaddcharAlt(y, 0, y + 'A' - 2); addstrAlt(spaceDashSpace);
				addstrAlt(squad[p]->name);
				if (squad[p]->squad[0] != NULL && squad[p]->squad[0]->location != -1)
				{
					setColorBasedOnSiege(squad[p]->squad[0]->location, y, activesquad == squad[p]);
					set_color_easy(activesquad == squad[p] ? WHITE_ON_BLACK_BRIGHT : WHITE_ON_BLACK);
				}
				if (squad[p]->squad[0] != NULL)
				{
					std::string str = getactivity(squad[p]->activity);
					set_activity_color(squad[p]->activity.type);
					if (squad[p]->activity.type == ACTIVITY_NONE)
					{
						bool haveact = false, multipleact = false;
						for (int p2 = 0; p2 < 6; p2++)
						{
							if (squad[p]->squad[p2] == NULL) continue;
							const std::string str2 = getactivity(squad[p]->squad[p2]->activity);
							set_activity_color(squad[p]->squad[p2]->activity.type);
							if (haveact&&str != str2) multipleact = true;
							str = str2, haveact = true;
						}
						if (multipleact)
						{
							str = CONST_reviewmode120;
							set_color_easy(WHITE_ON_BLACK_BRIGHT);
						}
					}
					mvaddstrAlt(y, 51, str);
				}
			}
			else if (p == len(squad))
			{
				set_color_easy(GREEN_ON_BLACK_BRIGHT);
				mvaddstrAlt(y, 0, CONST_reviewmode121 + tostring(n[0]) + ')');
			}
			else if (p == len(squad) + 1)
			{
				set_color_easy(RED_ON_BLACK_BRIGHT);
				mvaddstrAlt(y, 0, CONST_reviewmode122 + tostring(n[1]) + ')');
			}
			else if (p == len(squad) + 2)
			{
				set_color_easy(WHITE_ON_BLACK_BRIGHT);
				mvaddstrAlt(y, 0, CONST_reviewmode123 + tostring(n[2]) + ')');
			}
			else if (p == len(squad) + 3)
			{
				set_color_easy(YELLOW_ON_BLACK_BRIGHT);
				mvaddstrAlt(y, 0, CONST_reviewmode124 + tostring(n[3]) + ')');
			}
			else if (p == len(squad) + 4)
			{
				set_color_easy(MAGENTA_ON_BLACK_BRIGHT);
				mvaddstrAlt(y, 0, CONST_reviewmode125 + tostring(n[4]) + ')');
			}
			else if (p == len(squad) + 5)
			{
				set_color_easy(BLACK_ON_BLACK_BRIGHT);
				mvaddstrAlt(y, 0, CONST_reviewmode126 + tostring(n[5]) + ')');
			}
			else if (p == len(squad) + 6)
			{
				set_color_easy(BLUE_ON_BLACK_BRIGHT);
				mvaddstrAlt(y, 0, CONST_reviewmode127 + tostring(n[6]) + ')');
			}
			else if (p == len(squad) + 7)
			{
				set_color_easy(CYAN_ON_BLACK_BRIGHT);
				mvaddstrAlt(y, 0, CONST_reviewmode128 + tostring(n[7]) + ')');
			}
		}
		set_color_easy(WHITE_ON_BLACK);
		mvaddstrAlt(21, 0, CONST_reviewmode129);
		if (music.isEnabled())
			mvaddstrAlt(21, 38, CONST_reviewmode130);
		else mvaddstrAlt(21, 38, CONST_reviewmode131);
		mvaddstrAlt(22, 0, CONST_reviewmode132);
		mvaddstrAlt(23, 0, addpagestr() + CONST_reviewmode133);
		mvaddstrAlt(24, 0, CONST_reviewmode134);
		int c = getkeyAlt();
		if ((c == interface_pgup || c == KEY_UP || c == KEY_LEFT) && page > 0) page--;
		if ((c == interface_pgdn || c == KEY_DOWN || c == KEY_RIGHT) && (page + 1) * 19 < len(squad) + REVIEWMODENUM) page++;
		if (c == 'x' || c == ENTER || c == ESC || c == SPACEBAR) return;
		if (c >= 'a'&&c <= 's')
		{
			int sq = page * 19 + c - 'a';
			if (sq < len(squad) && sq >= 0)
			{
				if (squad[sq] == activesquad)assemblesquad(squad[sq]);
				else activesquad = squad[sq];
			}
		}
		if (c >= '1'&&c <= '7') review_mode(c - '1');
		if (c == '8') equipmentbaseassign();
		if (c == 'z')
		{
			assemblesquad(NULL);
			if (!activesquad&&len(squad))
				activesquad = squad[len(squad) - 1];
		}
		if (c == 't') squadlessbaseassign();
		if (c == 'u') promoteliberals();
		if (c == 'v')
		{
			char clearformess = false;
			fundreport(clearformess);
			if (clearformess) eraseAlt();
		}
		if (c == 'y') music.enableIf(!music.isEnabled());
	}
}