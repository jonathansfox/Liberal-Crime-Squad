#include "../includes.h"
const string CONST_sitemode179 = "-D";
const string CONST_sitemode178 = "                                                                                ";
const string CONST_sitemode177 = "C - Reflect on your Conservative ineptitude";
const string CONST_sitemode176 = "R - Reorganize";
const string CONST_sitemode175 = "R - Release hostage";
const string CONST_sitemode174 = "R - Release oppressed";
const string CONST_sitemode173 = "F - Fight!";
const string CONST_sitemode172 = "E - Equip";
const string CONST_sitemode171 = "V - Evade";
const string CONST_sitemode170 = "V - Run";
const string CONST_sitemode169 = "V - Sneak";
const string CONST_sitemode168 = "U - Use";
const string CONST_sitemode167 = "U - Graffiti";
const string CONST_sitemode166 = "T - Talk";
const string CONST_sitemode165 = "K - Kidnap";
const string CONST_sitemode164 = "L - Reload";
const string CONST_sitemode163 = "S - Wait";
const string CONST_sitemode162 = "M - Map";
const string CONST_sitemode161 = "N - Options";
const string CONST_sitemode160 = "G - Get Loot";
const string CONST_sitemodeXRL = "J - Reload Empty";
const string CONST_sitemode159 = "W,A,D,X - Move";
const string CONST_sitemode158 = ": CONSERVATIVES SUSPICIOUS";
const string CONST_sitemode157 = ": CONSERVATIVES ALARMED";
const string CONST_sitemode156 = ": ALIENATED EVERYONE";
const string CONST_sitemode155 = ": ALIENATED MASSES";
const string CONST_sitemode154 = ": CONSERVATIVE REINFORCEMENTS INCOMING";
const string CONST_sitemode153 = ": POLICE RESPONDING";
const string CONST_sitemode152 = ": DEATH SQUADS RESPONDING";
const string CONST_sitemode151 = ": CCS VIGILANTIES RESPONDING";
const string CONST_sitemode150 = ": GANG MEMBERS RESPONDING";
const string CONST_sitemode149 = ": ANGRY MOB RESPONDING";
const string CONST_sitemode148 = ": MERCENARIES RESPONDING";
const string CONST_sitemode147 = ": AGENTS RESPONDING";
const string CONST_sitemode146 = ": SECRET SERVICE RESPONDING";
const string CONST_sitemode145 = ": SOLDIERS AND TANKS RESPONDING";
const string CONST_sitemode144 = ", Level ";
const string CONST_sitemode143 = ": Escape or Engage";
const string CONST_sitemode141 = "Prisoner";
const string CONST_sitemode140 = "There is a crowd of people passing by.";
const string CONST_sitemode139 = "There is a crowd of people up ahead.";
const string CONST_sitemode138 = "There is a group of people passing by.";
const string CONST_sitemode137 = "There is a group of people up ahead.";
const string CONST_sitemode136 = "There are a few people passing by.";
const string CONST_sitemode135 = "There are a few people up ahead.";
const string CONST_sitemode134 = "There is someone passing by.";
const string CONST_sitemode133 = "There is someone up ahead.";
const string CONST_sitemode132 = "The landlord is in.";
const string CONST_sitemode131 = "The landlord is out of the office.";
const string CONST_sitemode130 = "The CEO's study lies empty.";
const string CONST_sitemode129 = "The CEO is in his study.";
const string CONST_sitemode128 = "The CEO must have fled to a panic room.";
const string CONST_sitemode127 = "[Rats!] ";
const string CONST_sitemode126 = "Damn! ";
const string CONST_sitemode125 = "There are people sitting here.";
const string CONST_sitemode124 = "The bench is empty.";
const string CONST_sitemode123 = "The table is occupied.";
const string CONST_sitemode122 = "Some people are hiding under the table.";
const string CONST_sitemode121 = "The computer is occupied.";
const string CONST_sitemode120 = "The computer has been unplugged.";
const string CONST_sitemode119 = "the power of your Liberal Convictions!";
const string CONST_sitemode118 = "The Conservatives have shrunk back under ";
const string CONST_sitemode117 = "The CCS has been broken!";
const string CONST_sitemode116 = " has left ";
const string CONST_sitemode115 = "The squad sneaks past the conservatives!";
const string CONST_sitemode114 = "You find: ";
const string CONST_sitemode113 = " you, feeling safer getting out alone.";
const string CONST_sitemode112 = "One Liberal leaves";
const string CONST_sitemode111 = "The Liberal leaves";
const string CONST_sitemode110 = "Some leave";
const string CONST_sitemode109 = "They all leave";
const string CONST_sitemode108 = " from the Conservatives.";
const string CONST_sitemode107 = "an Oppressed Liberal";
const string CONST_sitemode106 = "some Oppressed Liberals";
const string CONST_sitemode105 = "You free ";
const string CONST_sitemode102 = "You have to deal with the enemies first.";
const string CONST_sitemode101 = " won't talk to you.";
const string CONST_sitemode100 = "To whom?";
const string CONST_sitemode099 = "Bluff";
const string CONST_sitemode098 = "Dating";
const string CONST_sitemode097 = "Issues";
const string CONST_sitemode096 = "Which Liberal will speak?";
const string CONST_sitemode095 = "[ ] M - Music";
const string CONST_sitemode094 = "[ ] E - Encounter warnings";
const string CONST_sitemode093 = "Site mode options";
const string CONST_sitemode092 = "Which way?  (W,A,D, and X to move, ENTER to abort)";
const string CONST_sitemode091 = "It opens easily. The alarm goes off!";
const string CONST_sitemode090 = "The alarm goes off!";
const string CONST_sitemode089 = "Force it open? (Yes or No)";
const string CONST_sitemode088 = "It's locked from the other side.";
const string CONST_sitemode087 = "locked.";
const string CONST_sitemode086 = "still ";
const string CONST_sitemode085 = "You shake the handle but it is ";
const string CONST_sitemode084 = "Your tampering sets off the alarm!";
const string CONST_sitemode083 = "Try to pick the lock? (Yes or No)";
const string CONST_sitemode082 = "You try the door, but it is locked.";
const string CONST_sitemode081 = "Try the door anyway? (Yes or No)";
const string CONST_sitemode080 = "EMERGENCY EXIT ONLY. ALARM WILL SOUND.";
const string CONST_sitemode079 = "This door appears to be wired up to an alarm.";
const string CONST_sitemode078 = "The vault door is impenetrable.";
const string CONST_sitemode077 = "too hot";
const string CONST_sitemode076 = "Your hostage is free.";
const string CONST_sitemode075 = "Your hostages are free.";
const string CONST_sitemode074 = "The police subdue and arrest the squad.";

const string tag_WEAPON = "WEAPON";
const string tag_WEAPON_FLAMETHROWER = "WEAPON_FLAMETHROWER";
const string tag_LOOT = "LOOT";
const string tag_LOOT_COMPUTER = "LOOT_COMPUTER";
const string tag_LOOT_CHEAPJEWELERY = "LOOT_CHEAPJEWELERY";
const string tag_LOOT_TRINKET = "LOOT_TRINKET";
const string tag_LOOT_SILVERWARE = "LOOT_SILVERWARE";
const string tag_LOOT_CELLPHONE = "LOOT_CELLPHONE";
const string tag_ARMOR_CIVILLIANARMOR = "ARMOR_CIVILLIANARMOR";
const string tag_ARMOR_SECURITYUNIFORM = "ARMOR_SECURITYUNIFORM";
const string tag_ARMOR_ARMYARMOR = "ARMOR_ARMYARMOR";
const string tag_ARMOR = "ARMOR";
const string tag_ARMOR_HEAVYARMOR = "ARMOR_HEAVYARMOR";
const string tag_ARMOR_CHEAPSUIT = "ARMOR_CHEAPSUIT";
const string tag_ARMOR_WORKCLOTHES = "ARMOR_WORKCLOTHES";
const string tag_ARMOR_CLOTHES = "ARMOR_CLOTHES";
const string tag_ARMOR_TRENCHCOAT = "ARMOR_TRENCHCOAT";
const string tag_WEAPON_AUTORIFLE_M16 = "WEAPON_AUTORIFLE_M16";
const string tag_WEAPON_SMG_MP5 = "WEAPON_SMG_MP5";
const string tag_WEAPON_CARBINE_M4 = "WEAPON_CARBINE_M4";
const string tag_WEAPON_REVOLVER_38 = "WEAPON_REVOLVER_38";
const string tag_WEAPON_REVOLVER_44 = "WEAPON_REVOLVER_44";
const string tag_WEAPON_SEMIPISTOL_9MM = "WEAPON_SEMIPISTOL_9MM";
const string tag_WEAPON_SEMIPISTOL_45 = "WEAPON_SEMIPISTOL_45";
const string tag_LOOT_PDA = "LOOT_PDA";
const string tag_LOOT_MICROPHONE = "LOOT_MICROPHONE";
const string tag_LOOT_CABLENEWSFILES = "LOOT_CABLENEWSFILES";
const string tag_LOOT_AMRADIOFILES = "LOOT_AMRADIOFILES";
const string tag_LOOT_FAMILYPHOTO = "LOOT_FAMILYPHOTO";
const string tag_LOOT_WATCH = "LOOT_WATCH";
const string tag_ARMOR_BONDAGEGEAR = "ARMOR_BONDAGEGEAR";
const string tag_ARMOR_EXPENSIVESUIT = "ARMOR_EXPENSIVESUIT";
const string tag_ARMOR_EXPENSIVEDRESS = "ARMOR_EXPENSIVEDRESS";
const string tag_LOOT_CORPFILES = "LOOT_CORPFILES";
const string tag_LOOT_CHEMICAL = "LOOT_CHEMICAL";
const string tag_LOOT_FINECLOTH = "LOOT_FINECLOTH";
const string tag_ARMOR_BUNKERGEAR = "ARMOR_BUNKERGEAR";
const string tag_LOOT_SECRETDOCUMENTS = "LOOT_SECRETDOCUMENTS";
const string tag_WEAPON_SHANK = "WEAPON_SHANK";
const string tag_ARMOR_PRISONER = "ARMOR_PRISONER";
const string tag_LOOT_JUDGEFILES = "LOOT_JUDGEFILES";
const string tag_LOOT_POLICERECORDS = "LOOT_POLICERECORDS";
const string tag_ARMOR_POLICEARMOR = "ARMOR_POLICEARMOR";
const string tag_ARMOR_SWATARMOR = "ARMOR_SWATARMOR";
const string tag_ARMOR_POLICEUNIFORM = "ARMOR_POLICEUNIFORM";
const string tag_ARMOR_DEATHSQUADUNIFORM = "ARMOR_DEATHSQUADUNIFORM";
const string tag_WEAPON_SHOTGUN_PUMP = "WEAPON_SHOTGUN_PUMP";
const string tag_WEAPON_NIGHTSTICK = "WEAPON_NIGHTSTICK";
const string tag_LOOT_LABEQUIPMENT = "LOOT_LABEQUIPMENT";
const string tag_LOOT_RESEARCHFILES = "LOOT_RESEARCHFILES";
const string tag_LOOT_EXPENSIVEJEWELERY = "LOOT_EXPENSIVEJEWELERY";
const string tag_ARMOR_BLACKROBE = "ARMOR_BLACKROBE";
const string tag_ARMOR_LABCOAT = "ARMOR_LABCOAT";
const string tag_ARMOR_BLACKDRESS = "ARMOR_BLACKDRESS";
const string tag_ARMOR_BLACKSUIT = "ARMOR_BLACKSUIT";
const string tag_WEAPON_SEMIRIFLE_AR15 = "WEAPON_SEMIRIFLE_AR15";
const string tag_WEAPON_COMBATKNIFE = "WEAPON_COMBATKNIFE";
const string tag_WEAPON_BASEBALLBAT = "WEAPON_BASEBALLBAT";
const string tag_WEAPON_DAISHO = "WEAPON_DAISHO";
const string tag_ARMOR_CLOWNSUIT = "ARMOR_CLOWNSUIT";
const string tag_ARMOR_DONKEYSUIT = "ARMOR_DONKEYSUIT";
const string tag_ARMOR_ELEPHANTSUIT = "ARMOR_ELEPHANTSUIT";
const string tag_ARMOR_CHEAPDRESS = "ARMOR_CHEAPDRESS";
const string tag_WEAPON_GUITAR = "WEAPON_GUITAR";
const string tag_LOOT_DIRTYSOCK = "LOOT_DIRTYSOCK";
const string tag_LOOT_KIDART = "LOOT_KIDART";
const string tag_ARMOR_TOGA = "ARMOR_TOGA";
const string tag_WEAPON_SPRAYCAN = "WEAPON_SPRAYCAN";
const string tag_WEAPON_SYRINGE = "WEAPON_SYRINGE";
const string tag_WEAPON_CHAIN = "WEAPON_CHAIN";
const string tag_WEAPON_CROWBAR = "WEAPON_CROWBAR";
const string tag_X = "X";
/*
Copyright (c) 2002,2003,2004 by Tarn Adams                                            //
																					  //
This file is part of Liberal Crime Squad.                                             //
																					//
	Liberal Crime Squad is free software; you can redistribute it and/or modify     //
	it under the terms of the GNU General Public License as published by            //
	the Free Software Foundation; either version 2 of the License, or               //
	(at your option) any later version.                                             //
																					//
	Liberal Crime Squad is distributed in the hope that it will be useful,          //
	but WITHOUT ANY WARRANTY; without even the implied warranty of                  //
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.   See the                  //
	GNU General Public License for more details.                                    //
																					//
	You should have received a copy of the GNU General Public License               //
	along with Liberal Crime Squad; if not, write to the Free Software              //
	Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA   02111-1307   USA     //
*/
/*
		This file was created by Chris Johnson (grundee@users.sourceforge.net)
		by copying code from game.cpp.
		To see descriptions of files and functions, see the list at
		the bottom of includes.h in the top src folder.
*/
const string blankString = "";
#include "../creature/creature.h"
#include "../locations/locations.h"
//#include "cursesgraphics.h"
#define CH_FULL_BLOCK 0xdb
#define CH_UPWARDS_ARROW 0x18
#define CH_DOWNWARDS_ARROW 0x19
#define CH_BLACK_SMILING_FACE 0x02
#define CH_YEN_SIGN 0x9d
#define CH_BOX_DRAWINGS_DOUBLE_VERTICAL 0xba
#define CH_BOX_DRAWINGS_DOUBLE_HORIZONTAL 0xcd
#define CH_WHITE_SMILING_FACE 0x01
#include "../vehicle/vehicletype.h"
#include "../vehicle/vehicle.h"
#include "../basemode/baseactions.h"
// for orderparty
#include "../basemode/reviewmode.h"
#include "advance.h"
//#include "sitemode/mapspecials.h"
void special_bouncer_assess_squad();
void special_bouncer_greet_squad();
void special_lab_cosmetics_cagedanimals();
void special_readsign(int sign);
void special_nuclear_onoff();
void special_lab_genetic_cagedanimals();
void special_policestation_lockup();
void special_courthouse_lockup();
void special_courthouse_jury();
void special_prison_control(short prison_control_type);
void special_intel_supercomputer();
void special_sweatshop_equipment();
void special_polluter_equipment();
void special_house_photos();
void special_corporate_files();
void special_radio_broadcaststudio();
void special_news_broadcaststudio();
void special_graffiti();
void special_armory();
void special_display_case();
void special_security_checkpoint();
void special_security_metaldetectors();
void special_security_secondvisit();
void special_bank_teller();
void special_bank_money();
void special_bank_vault();
void special_ccs_boss();
void special_oval_office();
#include "stealth.h"
#include "miscactions.h"
void reloadparty(bool wasteful = false);
#include "sitedisplay.h"
//#include "sitemode/newencounter.h"
void prepareencounter(short type, char sec);
char addsiegeencounter(char type);
#include "../items/lootTypePoolItem.h"
#include "../log/log.h"
// for commondisplay.h
#include "../common/commondisplay.h"
// for printparty()
#include "../common/commonactions.h"
#include "../common/commonactionsCreature.h"
// for squadsize
#include "../common/translateid.h"
// for  id_getcar
//#include "common/equipment.h"
/* review squad equipment */
void equip(vector<Item *> &loot, int loc);
//#include "daily/daily.h"
/* daily - returns true if the site type supports high security */
char securityable(int type);
#include "../daily/siege.h"
//for void conquertext();
#include "../combat/fight.h"
#include "../combat/fightCreature.h"  
//for void enemyattack();
#include "../combat/haulkidnap.h"
#include "../combat/haulkidnapCreature.h"
//for void kidnapattempt();
#include "../combat/chase.h"
//for void makechasers(long sitetype,long sitecrime);
char talk(Creature &a, const int t);
#include "../cursesAlternative.h"
#include "../cursesAlternativeConstants.h"
#include "../set_color_support.h"
#include "../common/creaturePoolCreature.h"
#include "../locations/locationsPool.h"
#include "../common/creaturePool.h"
#include "../common/musicClass.h"
extern string closeParenthesis;
extern string undefined;
extern string check_status_of_squad_liberal;
extern string show_squad_liberal_status;
extern string enter_done;
extern string chooseALiberalTo;
extern string spaceDashSpace;
extern string singleDot;
extern string change_squad_order;
extern string spaceParanthesisDollar;
void emptyEncounter();
void delete_and_clear_groundloot();
bool isThereGroundLoot();
extern string singleSpace;
void deleteVehicle(int carid);
void deleteVehicles(vector<Vehicle *>& carid);
void fight_subdued()
{
	extern Log gamelog;
	extern squadst *activesquad;
	extern chaseseqst chaseseq;
	//int p;
	//int ps=find_police_station(chaseseq.location);
	deleteVehicles(chaseseq.friendcar);
	int hostages = 0;
	for (int p = 0; p < 6; p++)
		if (activesquad->squad[p] != NULL)
			if (activesquad->squad[p]->prisoner&&activesquad->squad[p]->prisoner->align != ALIGN_LIBERAL)
				hostages++;
	int stolen = 0;
	// Police assess stolen goods in inventory
	for (int l = 0; l < len(activesquad->loot); l++)
		if (activesquad->loot[l]->whatIsThis() == THIS_IS_LOOT)
			stolen++;
	for (int p = 0; p < 6; p++)
	{
		if (!activesquad->squad[p]) continue;
		activesquad->squad[p]->crimes_suspected[LAWFLAG_THEFT] += stolen;
		capturecreature(*(activesquad->squad[p]));
		activesquad->squad[p] = NULL;
	}
	CreaturePool::getInstance().stopAllBleeding();
	clearmessagearea();
	clearcommandarea();
	set_color_easy(MAGENTA_ON_BLACK_BRIGHT);
	mvaddstrAlt(16, 1, CONST_sitemode074, gamelog);
	gamelog.newline();
	if (hostages > 0)
	{
		if (hostages > 1) {
			mvaddstrAlt(17, 1, CONST_sitemode075, gamelog);
		}
		else {
			mvaddstrAlt(17, 1, CONST_sitemode076, gamelog);
		}
	}
	gamelog.newline();
	pressAnyKey();
}

/* marks the area around the specified tile as explored */
void knowmap(int locx, int locy, int locz)
{
	extern siteblockst levelmap[MAPX][MAPY][MAPZ];
	levelmap[locx][locy][locz].flag |= SITEBLOCK_KNOWN;
	if (locx > 0)levelmap[locx - 1][locy][locz].flag |= SITEBLOCK_KNOWN;
	if (locx < MAPX - 1)levelmap[locx + 1][locy][locz].flag |= SITEBLOCK_KNOWN;
	if (locy > 0)levelmap[locx][locy - 1][locz].flag |= SITEBLOCK_KNOWN;
	if (locy < MAPY - 1)levelmap[locx][locy + 1][locz].flag |= SITEBLOCK_KNOWN;
	if (locx > 0 && locy > 0)
		if (!(levelmap[locx - 1][locy][locz].flag & SITEBLOCK_BLOCK) ||
			!(levelmap[locx][locy - 1][locz].flag & SITEBLOCK_BLOCK))
			levelmap[locx - 1][locy - 1][locz].flag |= SITEBLOCK_KNOWN;
	if (locx < MAPX - 1 && locy>0)
		if (!(levelmap[locx + 1][locy][locz].flag & SITEBLOCK_BLOCK) ||
			!(levelmap[locx][locy - 1][locz].flag & SITEBLOCK_BLOCK))
			levelmap[locx + 1][locy - 1][locz].flag |= SITEBLOCK_KNOWN;
	if (locx > 0 && locy < MAPY - 1)
		if (!(levelmap[locx - 1][locy][locz].flag & SITEBLOCK_BLOCK) ||
			!(levelmap[locx][locy + 1][locz].flag & SITEBLOCK_BLOCK))
			levelmap[locx - 1][locy + 1][locz].flag |= SITEBLOCK_KNOWN;
	if (locx < MAPX - 1 && locy < MAPY - 1)
		if (!(levelmap[locx + 1][locy][locz].flag & SITEBLOCK_BLOCK) ||
			!(levelmap[locx][locy + 1][locz].flag & SITEBLOCK_BLOCK))
			levelmap[locx + 1][locy + 1][locz].flag |= SITEBLOCK_KNOWN;
}

void knowmap() {
	extern int locx;
	extern int locy;
	extern int locz;
	knowmap(locx, locy, locz);
}
/* site - determines spin on site news story, CONST_sitemode077 timer */
void resolvesite()
{
	extern squadst *activesquad;
	extern short cursite;
	extern int sitecrime;
	extern newsstoryst *sitestory;
	extern short sitealienate;
	if (sitealienate) sitestory->positive = 0;
	//removed the 'alarmed' requirement for high security buildings, on the principle that even if they didn't see you, they will presumably
	//notice later on that all their stuff has been stolen or whatever.
	if (/*sitealarm==1&&*/sitecrime > 5 + LCSrandom(95))//was 100 but that meant I could still steal everything from a building every day without anyone caring...
	{
		if (LocationsPool::getInstance().getRentingType(cursite) == RENTING_NOCONTROL)
		{
			// Capture a warehouse or crack den?
			if (LocationsPool::getInstance().getLocationType(cursite) == SITE_INDUSTRY_WAREHOUSE ||
				LocationsPool::getInstance().getLocationType(cursite) == SITE_BUSINESS_CRACKHOUSE)
			{
				LocationsPool::getInstance().captureSite(cursite);
			}
			else LocationsPool::getInstance().closeSite(cursite, sitecrime);
		}
		// Out sleepers
		if (LocationsPool::getInstance().getRentingType(cursite) == RENTING_CCS)
		{
			CreaturePool::getInstance().outSleepers(cursite, activesquad->squad[0]->base);
		}
	}
	else if (sitecrime > 10 && (LocationsPool::getInstance().getRentingType(cursite) == RENTING_NOCONTROL || LocationsPool::getInstance().getRentingType(cursite) > 500))
	{
		if (LocationsPool::getInstance().getLocationType(cursite) != SITE_RESIDENTIAL_BOMBSHELTER &&
			LocationsPool::getInstance().getLocationType(cursite) != SITE_BUSINESS_BARANDGRILL &&
			LocationsPool::getInstance().getLocationType(cursite) != SITE_OUTDOOR_BUNKER &&
			LocationsPool::getInstance().getLocationType(cursite) != SITE_INDUSTRY_WAREHOUSE &&
			LocationsPool::getInstance().getLocationType(cursite) != SITE_BUSINESS_CRACKHOUSE)
		{
			if (securityable(LocationsPool::getInstance().getLocationType(cursite)))
				LocationsPool::getInstance().isThisPlaceHighSecurity(cursite, sitecrime);
			else LocationsPool::getInstance().closeSite(cursite, 70);
		}
	}
}
/* behavior when the player bumps into a door in sitemode */
void open_door(bool restricted)
{
	extern Log gamelog;
	extern squadst *activesquad;
	extern short sitealarm;
	extern int sitecrime;
	extern short sitealarmtimer;
	extern int locx;
	extern int locy;
	extern int locz;
	extern newsstoryst *sitestory;
	extern siteblockst levelmap[MAPX][MAPY][MAPZ];
	bool locked = levelmap[locx][locy][locz].flag&SITEBLOCK_LOCKED,
		alarmed = levelmap[locx][locy][locz].flag&SITEBLOCK_ALARMED,
		vault_door = levelmap[locx][locy][locz].flag&SITEBLOCK_METAL,
		//   known_locked=levelmap[locx][locy][locz].flag&SITEBLOCK_KLOCK,
		cant_unlock = levelmap[locx][locy][locz].flag&SITEBLOCK_CLOCK;
	if (vault_door)
	{
		// Vault door, not usable by bumping
		clearmessagearea(false);
		set_color_easy(WHITE_ON_BLACK_BRIGHT);
		mvaddstrAlt(16, 1, CONST_sitemode078, gamelog);
		gamelog.newline();
		pressAnyKey();
		return;
	}
	bool has_security = false;
	for (int i = 0; i < 6; i++)
	{
		if (activesquad->squad[i] &&
			activesquad->squad[i]->get_skill(SKILL_SECURITY) != 0)
		{
			has_security = true;
			break;
		}
	}
	if (alarmed)
	{
		// Unlocked but alarmed door, clearly marked as such
		clearmessagearea(false);
		set_color_easy(WHITE_ON_BLACK_BRIGHT);
		if (locked)
			mvaddstrAlt(16, 1, CONST_sitemode079, gamelog);
		else
			mvaddstrAlt(16, 1, CONST_sitemode080, gamelog);
		gamelog.newline();
		mvaddstrAlt(17, 1, CONST_sitemode081);
		while (true)
		{
			int c = getkeyAlt();
			if (c == 'y') break;
			else if (c == 'n') return;
		}
	}
	if (locked && !cant_unlock && has_security)
	{
		levelmap[locx][locy][locz].flag |= SITEBLOCK_KLOCK;
		while (true)
		{
			clearmessagearea(false);
			set_color_easy(WHITE_ON_BLACK_BRIGHT);
			mvaddstrAlt(16, 1, CONST_sitemode082, gamelog);
			gamelog.newline();
			mvaddstrAlt(17, 1, CONST_sitemode083);
			int c = getkeyAlt();
			clearmessagearea(false);
			if (c == 'y')
			{
				char actual; // 1 if an actual attempt was made, 0 otherwise
							 // If the unlock was successful
				if (unlock(UNLOCK_DOOR, actual))
				{
					// Unlock the door
					levelmap[locx][locy][locz].flag &= ~(SITEBLOCK_LOCKED | SITEBLOCK_ALARMED);
					sitestory->crime.push_back(CRIME_UNLOCKEDDOOR);
					if (sitealarmtimer < 0 || sitealarmtimer>50) sitealarmtimer = 50;
					//criminalizeparty(LAWFLAG_BREAKING);
				}
				// Else perma-lock it if an attempt was made
				else if (actual)
				{
					levelmap[locx][locy][locz].flag |= SITEBLOCK_CLOCK;
					if (levelmap[locx][locy][locz].flag&SITEBLOCK_ALARMED)
					{
						set_color_easy(WHITE_ON_BLACK_BRIGHT);
						mvaddstrAlt(17, 1, CONST_sitemode084, gamelog);
						gamelog.newline();
						sitealarm = 1;
						pressAnyKey();
					}
				}
				// Check for people noticing you fiddling with the lock
				if (actual)
				{
					alienationcheck(0);
					noticecheck(-1);
				}
				return;
			}
			else if (c == 'n') return;
		}
	}
	else if (locked || (!restricted && alarmed))
	{
		while (true)
		{
			clearmessagearea(false);
			set_color_easy(WHITE_ON_BLACK_BRIGHT);
			if (locked)
			{
				mvaddstrAlt(16, 1, CONST_sitemode085, gamelog);
				if (has_security) addstrAlt(CONST_sitemode086, gamelog);
				addstrAlt(CONST_sitemode087, gamelog);
			}
			else mvaddstrAlt(16, 1, CONST_sitemode088, gamelog);
			gamelog.newline();
			mvaddstrAlt(17, 1, CONST_sitemode089);
			int c = getkeyAlt();
			if (c == 'y')
			{
				char actual;
				if (bash(BASH_DOOR, actual))
				{
					levelmap[locx][locy][locz].flag &= ~SITEBLOCK_DOOR;
					int time = 0;
					if (sitealarmtimer > time || sitealarmtimer == -1)sitealarmtimer = time;
					if (levelmap[locx][locy][locz].flag&SITEBLOCK_ALARMED)
					{
						clearmessagearea(false);
						set_color_easy(WHITE_ON_BLACK_BRIGHT);
						mvaddstrAlt(16, 1, CONST_sitemode090, gamelog);
						gamelog.newline();
						sitealarm = 1;
						pressAnyKey();
					}
					sitecrime++;
					sitestory->crime.push_back(CRIME_BROKEDOWNDOOR);
					criminalizeparty(LAWFLAG_BREAKING);
				}
				if (actual)
				{
					alienationcheck(1);
					noticecheck(-1, DIFFICULTY_HEROIC);
				}
				break;
			}
			else if (c == 'n')break;
		}
	}
	else
	{
		levelmap[locx][locy][locz].flag &= ~SITEBLOCK_DOOR;
		if (alarmed)
		{
			// Opened an unlocked but clearly marked emergency exit door
			clearmessagearea(false);
			set_color_easy(WHITE_ON_BLACK_BRIGHT);
			mvaddstrAlt(16, 1, CONST_sitemode091, gamelog);
			gamelog.newline();
			sitealarm = 1;
			pressAnyKey();
		}
	}
}
int whichWay() {
	int c = 0;
	clearmessagearea();
	set_color_easy(WHITE_ON_BLACK_BRIGHT);
	mvaddstrAlt(16, 1, CONST_sitemode092);
	while (true)
	{
		int c2 = getkeyAlt();
		if (c2 == 'w' || c2 == 'a' || c2 == 'd' || c2 == 'x' ||
			c2 == KEY_LEFT || c2 == KEY_RIGHT || c2 == KEY_UP || c2 == KEY_DOWN)
		{
			c = c2;
			break;
		}
		if (c2 == ENTER || c2 == ESC || c2 == SPACEBAR)break;
	}
	return c;
}
void pressedKeyN() {
	extern MusicClass music;
	extern bool mapshowing;
	extern bool encounterwarnings;

	mapshowing = false;
	eraseAlt();
	set_color_easy(WHITE_ON_BLACK);
	mvaddstrAlt(0, 0, CONST_sitemode093);
	printparty();
	set_color_easy(WHITE_ON_BLACK);
	mvaddstrAlt(10, 1, CONST_sitemode094);
	mvaddstrAlt(11, 1, CONST_sitemode095);
	set_color_easy(WHITE_ON_BLACK);
	mvaddstrAlt(24, 1, enter_done);
	int c = 0;
	while (true)
	{
		if (c == 'e') encounterwarnings = !encounterwarnings;
		if (c == 'm') music.enableIf(!music.isEnabled());
		if (c == 'x' || c == ENTER || c == ESC || c == SPACEBAR)break;
		if (encounterwarnings)
			mvaddstrAlt(10, 2, tag_X);
		else mvaddstrAlt(10, 2, singleSpace);
		if (music.isEnabled())
			mvaddstrAlt(11, 2, tag_X);
		else mvaddstrAlt(11, 2, singleSpace);
		c = getkeyAlt();
	}
	mapshowing = true;

}
void pressedKeyU(const int enemy) {
	extern squadst *activesquad;
	extern short sitealarm;
	extern int locx;
	extern int locy;
	extern int locz;
	extern siteblockst levelmap[MAPX][MAPY][MAPZ];
	{
		if (levelmap[locx][locy][locz].special != -1)
		{
			switch (levelmap[locx][locy][locz].special)
			{
			case SPECIAL_LAB_COSMETICS_CAGEDANIMALS:special_lab_cosmetics_cagedanimals(); break;
			case SPECIAL_NUCLEAR_ONOFF:special_nuclear_onoff(); break;
			case SPECIAL_LAB_GENETIC_CAGEDANIMALS:special_lab_genetic_cagedanimals(); break;
			case SPECIAL_POLICESTATION_LOCKUP:special_policestation_lockup(); break;
			case SPECIAL_COURTHOUSE_LOCKUP:special_courthouse_lockup(); break;
			case SPECIAL_COURTHOUSE_JURYROOM:special_courthouse_jury(); break;
			case SPECIAL_PRISON_CONTROL:
			case SPECIAL_PRISON_CONTROL_LOW:
			case SPECIAL_PRISON_CONTROL_MEDIUM:
			case SPECIAL_PRISON_CONTROL_HIGH:
				special_prison_control(levelmap[locx][locy][locz].special); break;
			case SPECIAL_INTEL_SUPERCOMPUTER:special_intel_supercomputer(); break;
			case SPECIAL_SWEATSHOP_EQUIPMENT:special_sweatshop_equipment(); break;
			case SPECIAL_POLLUTER_EQUIPMENT:special_polluter_equipment(); break;
			case SPECIAL_HOUSE_PHOTOS:special_house_photos(); break;
			case SPECIAL_ARMORY:special_armory(); break;
			case SPECIAL_CORPORATE_FILES:special_corporate_files(); break;
			case SPECIAL_RADIO_BROADCASTSTUDIO:special_radio_broadcaststudio(); break;
			case SPECIAL_NEWS_BROADCASTSTUDIO:special_news_broadcaststudio(); break;
			case SPECIAL_SIGN_ONE:special_readsign(SPECIAL_SIGN_ONE); break;
			case SPECIAL_SIGN_TWO:special_readsign(SPECIAL_SIGN_TWO); break;
			case SPECIAL_SIGN_THREE:special_readsign(SPECIAL_SIGN_THREE); break;
			case SPECIAL_STAIRS_UP:locz++; break;
			case SPECIAL_STAIRS_DOWN:locz--; break;
			case SPECIAL_DISPLAY_CASE:special_display_case(); break;
			case SPECIAL_SECURITY_CHECKPOINT:special_security_checkpoint(); break;
			case SPECIAL_SECURITY_METALDETECTORS:special_security_metaldetectors(); break;
			case SPECIAL_SECURITY_SECONDVISIT:special_security_secondvisit(); break;
			case SPECIAL_BANK_VAULT:special_bank_vault(); break;
			case SPECIAL_BANK_TELLER:special_bank_teller(); break;
			case SPECIAL_BANK_MONEY:special_bank_money(); break;
			case SPECIAL_CCS_BOSS:special_ccs_boss(); break;
			case SPECIAL_OVAL_OFFICE_NW:
			case SPECIAL_OVAL_OFFICE_NE:
			case SPECIAL_OVAL_OFFICE_SW:
			case SPECIAL_OVAL_OFFICE_SE:special_oval_office(); break;
			}
		}
		else if (!(levelmap[locx][locy][locz].flag & (SITEBLOCK_GRAFFITI | SITEBLOCK_BLOODY2)) &&
			((levelmap[locx + 1][locy][locz].flag & SITEBLOCK_BLOCK) ||
			(levelmap[locx - 1][locy][locz].flag & SITEBLOCK_BLOCK) ||
				(levelmap[locx][locy + 1][locz].flag & SITEBLOCK_BLOCK) ||
				(levelmap[locx][locy - 1][locz].flag & SITEBLOCK_BLOCK)))
		{
			int spray = 0;
			for (int i = 0; i < 6; i++)
			{
				if (!activesquad->squad[i])break;
				if (activesquad->squad[i]->get_weapon().can_graffiti())
				{
					spray = 1;
					break;
				}
			}
			if (spray)
			{
				special_graffiti();
				if (enemy&&sitealarm)
				{
					enemyattack();
				}
			}
		}
	}
}
void pressedKeyL() {

	reloadparty(true);
	printparty();
	refreshAlt();
	creatureadvance();

}
void pressedKeyT(const int enemy, int& encounter_timer) {
	extern squadst *activesquad;
	extern short sitealarm;
	extern Creature encounter[ENCMAX];
	int forcesp = -1;
	int forcetk = -1;
	for (int p = 0; p < 6; p++)
	{
		if (activesquad->squad[p] != NULL)
		{
			if (activesquad->squad[p]->alive)
			{
				if (forcesp == -1)forcesp = p;
				else forcesp = -2;
			}
		}
	}
	for (int e = 0; e < ENCMAX; e++)
	{
		if (encounter[e].exists&&encounter[e].alive &&
			!(encounter[e].type == CREATURE_WORKER_SERVANT ||
				encounter[e].type == CREATURE_WORKER_SWEATSHOP))
		{
			if (encounter[e].cantbluff != 1 || sitealarm)
			{
				if (forcetk == -1)forcetk = e;
				else forcetk = -2;
			}
		}
	}
	if (forcetk != -1 && forcesp != -1)
	{
		int sp = -1;
		if (forcesp == -2)
		{
			clearcommandarea();
			clearmessagearea();
			clearmaparea();
			set_color_easy(WHITE_ON_BLACK_BRIGHT);
			mvaddstrAlt(9, 1, CONST_sitemode096);
			mvaddstrAlt(9, 50, CONST_sitemode097);
			mvaddstrAlt(9, 60, CONST_sitemode098);
			mvaddstrAlt(9, 70, CONST_sitemode099);
			int y = 11;
			for (int p = 0; p < 6; p++)
			{
				if (activesquad->squad[p] != NULL)
				{
					if (activesquad->squad[p]->alive)
					{
						mvaddcharAlt(y, 1, p + '1');
						addstrAlt(spaceDashSpace);
						addstrAlt(activesquad->squad[p]->name);
						mvaddstrAlt(y, 50, activesquad->squad[p]->get_attribute(ATTRIBUTE_CHARISMA, true) / 2 +
							activesquad->squad[p]->get_skill(SKILL_PERSUASION));
						mvaddstrAlt(y, 60, activesquad->squad[p]->get_attribute(ATTRIBUTE_CHARISMA, true) / 2 +
							activesquad->squad[p]->get_skill(SKILL_SEDUCTION));
						mvaddstrAlt(y++, 70, activesquad->squad[p]->get_attribute(ATTRIBUTE_CHARISMA, true) / 2 +
							activesquad->squad[p]->get_skill(SKILL_DISGUISE));
					}
				}
			}
			while (true)
			{
				int c = getkeyAlt();
				if (c >= '1'&&c <= '6')
				{
					sp = c - '1';
					if (activesquad->squad[sp] != NULL) if (activesquad->squad[sp]->alive) break;
				}
				if (c == 'x' || c == ENTER || c == ESC || c == SPACEBAR) { sp = -1; break; }
			}
		}
		else sp = forcesp;
		if (sp != -1)
		{
			int tk = -1;
			if (forcetk == -2)
			{
				while (true)
				{
					clearcommandarea();
					clearmessagearea();
					clearmaparea();
					set_color_easy(WHITE_ON_BLACK_BRIGHT);
					mvaddstrAlt(9, 1, CONST_sitemode100);
					int x = 1, y = 11;
					for (int t = 0; t < ENCMAX; t++)
					{
						if (encounter[t].exists)
						{
							if (encounter[t].cantbluff != 1)
							{
								set_color_easy(WHITE_ON_BLACK_BRIGHT);
								mvaddcharAlt(y, x, t + 'A');
								addstrAlt(spaceDashSpace);
								switch (encounter[t].align)
								{
								case ALIGN_CONSERVATIVE:
									set_color_easy(RED_ON_BLACK_BRIGHT);
									break;
								case ALIGN_LIBERAL:
									set_color_easy(GREEN_ON_BLACK_BRIGHT);
									break;
								case ALIGN_MODERATE:
									set_color_easy(WHITE_ON_BLACK_BRIGHT);
									break;
								}
								addstrAlt(encounter[t].name);
								add_age(encounter[t]);
								y++;
								if (y == 17)
								{
									y = 11;
									x += 30;
								}
							}
							else
							{
								y++;
								if (y == 17)
								{
									y = 11;
									x += 30;
								}
							}
						}
					}
					int c = getkeyAlt();
					if (c >= 'a'&&c <= 'z')
					{
						tk = c - 'a';
						if (tk < ENCMAX)
						{
							if (encounter[tk].exists)
							{
								if (encounter[tk].alive &&
									!(encounter[tk].type == CREATURE_WORKER_SERVANT ||
										encounter[tk].type == CREATURE_WORKER_SWEATSHOP))
								{
									if (encounter[tk].cantbluff == 1 &&
										(!sitealarm || encounter[tk].animalgloss == ANIMALGLOSS_ANIMAL))
									{
										clearcommandarea();
										clearmessagearea();
										clearmaparea();
										set_color_easy(WHITE_ON_BLACK_BRIGHT);
										mvaddstrAlt(9, 1, encounter[tk].name);
										addstrAlt(CONST_sitemode101);
										pressAnyKey();
									}
									else if (!encounter[tk].enemy() && sitealarm&&enemy)
									{
										clearcommandarea();
										clearmessagearea();
										clearmaparea();
										set_color_easy(WHITE_ON_BLACK_BRIGHT);
										mvaddstrAlt(9, 1, CONST_sitemode102);
										pressAnyKey();
									}
									else break;
								}
							}
						}
					}
					if (c == 'x' || c == ENTER || c == ESC || c == SPACEBAR) { tk = -1; break; }
				}
			}
			else tk = forcetk;
			if (tk != -1)
			{
				if (talk(*activesquad->squad[sp], tk))
				{
					if (enemy&&sitealarm)enemyattack();
					else if (enemy)disguisecheck(encounter_timer);
					creatureadvance();
					encounter_timer++;
				}
			}
		}
	}

}
void pressedKeyM() {
	extern short cursite;
	extern int locx;
	extern int locy;
	extern int locz;
	extern siteblockst levelmap[MAPX][MAPY][MAPZ];
	for (int x = 0; x < MAPX; x++)
	{
		for (int y = 0; y < MAPY; y++)
		{
			if (levelmap[x][y][locz].flag & SITEBLOCK_KNOWN)
			{
				if (x == locx && y == locy)
				{
					set_color_easy(GREEN_ON_BLACK_BRIGHT);
					mvaddchAlt(y + 1, x + 5, CH_WHITE_SMILING_FACE);
				}
				else
				{
					set_color_easy(WHITE_ON_BLACK);
					if (levelmap[x][y][locz].flag & SITEBLOCK_BLOCK)
					{
						set_color_easy(WHITE_ON_WHITE);
						mvaddchAlt(y + 1, x + 5, ' ');
					}
					else if (levelmap[x][y][locz].flag & SITEBLOCK_DOOR)
					{  // Pick color
						if (levelmap[x][y][locz].flag & SITEBLOCK_METAL)
							set_color_easy(WHITE_ON_WHITE_BRIGHT);
						else if (levelmap[x][y][locz].flag & SITEBLOCK_CLOCK
							&& levelmap[x][y][locz].flag & SITEBLOCK_LOCKED)
							set_color_easy(RED_ON_BLACK);
						else if (levelmap[x][y][locz].flag & SITEBLOCK_KLOCK
							&& levelmap[x][y][locz].flag & SITEBLOCK_LOCKED)
							set_color_easy(BLACK_ON_BLACK_BRIGHT);
						else set_color_easy(YELLOW_ON_BLACK);
						if ((levelmap[x + 1][y][locz].flag & SITEBLOCK_BLOCK) ||
							(levelmap[x - 1][y][locz].flag & SITEBLOCK_BLOCK))
							mvaddchAlt(y + 1, x + 5, CH_BOX_DRAWINGS_DOUBLE_HORIZONTAL);
						else mvaddchAlt(y + 1, x + 5, CH_BOX_DRAWINGS_DOUBLE_VERTICAL);
					}
					else if ((levelmap[x][y][locz].siegeflag & SIEGEFLAG_HEAVYUNIT) &&
						LocationsPool::getInstance().siteHasCameras(cursite))
					{
						set_color_easy(RED_ON_BLACK_BRIGHT);
						mvaddchAlt(y + 1, x + 5, CH_YEN_SIGN);
					}
					else if ((levelmap[x][y][locz].siegeflag & SIEGEFLAG_UNIT) &&
						LocationsPool::getInstance().siteHasCameras(cursite))
					{
						set_color_easy(RED_ON_BLACK_BRIGHT);
						mvaddchAlt(y + 1, x + 5, CH_BLACK_SMILING_FACE);
					}
					else if ((levelmap[x][y][locz].siegeflag & SIEGEFLAG_UNIT_DAMAGED) &&
						LocationsPool::getInstance().siteHasCameras(cursite))
					{
						set_color_easy(RED_ON_BLACK);
						mvaddchAlt(y + 1, x + 5, CH_BLACK_SMILING_FACE);
					}
					else if (levelmap[x][y][locz].special == SPECIAL_STAIRS_UP)
					{
						set_color_easy(YELLOW_ON_BLACK_BRIGHT);
						mvaddchAlt(y + 1, x + 5, CH_UPWARDS_ARROW);
					}
					else if (levelmap[x][y][locz].special == SPECIAL_STAIRS_DOWN)
					{
						set_color_easy(YELLOW_ON_BLACK_BRIGHT);
						mvaddchAlt(y + 1, x + 5, CH_DOWNWARDS_ARROW);
					}
					else if (levelmap[x][y][locz].special != -1)
					{
						set_color_easy(YELLOW_ON_BLACK_BRIGHT);
						mvaddchAlt(y + 1, x + 5, '!');
					}
					else if (levelmap[x][y][locz].siegeflag & SIEGEFLAG_TRAP)
					{
						set_color_easy(YELLOW_ON_BLACK_BRIGHT);
						mvaddchAlt(y + 1, x + 5, '!');
					}
					else if (levelmap[x][y][locz].flag & SITEBLOCK_LOOT)
					{
						set_color_easy(MAGENTA_ON_BLACK_BRIGHT);
						mvaddchAlt(y + 1, x + 5, '$');
					}
					else mvaddchAlt(y + 1, x + 5, ' ');
				}
			}
			else
			{
				set_color_easy(BLACK_ON_BLACK_BRIGHT);
				mvaddchAlt(y + 1, x + 5, CH_FULL_BLOCK);
			}
		}
	}
	pressAnyKey();

}
void pressedKeyF(int& encounter_timer) {
	extern squadst *activesquad;
	extern Creature encounter[ENCMAX];
	// Don't subdue squad if someone is still in good condition.
	bool cannotsubdue = false;
	for (int j = 0; j < 6 && !cannotsubdue; j++)
	{
		if (activesquad->squad[j] &&
			activesquad->squad[j]->alive &&
			activesquad->squad[j]->blood > 40)
		{
			cannotsubdue = true;
		}
	}
	// Cops can subdue and arrest the squad.
	bool subdue = false;
	for (int i = 0; i < ENCMAX && (!cannotsubdue && !subdue); i++)
	{
		if (encounter[i].exists&&
			encounter[i].blood > 60 &&
			(encounter[i].type == CREATURE_COP))
		{
			subdue = true;
		}
	}
	if (subdue)
		fight_subdued();
	else
	{
		youattack();
		enemyattack();
		creatureadvance();
		encounter_timer++;
	}

}
int checkForPeopleWhoCanRecruit() {
	extern squadst *activesquad;
	// Check for people who can recruit followers
	for (int i = 0; i < 6; i++)
		if (activesquad->squad[i] != NULL)
			if (subordinatesleft(*activesquad->squad[i]))
				return i;
	return -1;
}
void addNewRecruit(int i, int e) {
	extern int stat_recruits;
	extern squadst *activesquad;
	extern Creature encounter[ENCMAX];
	Creature *newcr = new Creature;
	*newcr = encounter[e];
	newcr->namecreature();
	newcr->location = activesquad->squad[i]->location;
	newcr->base = activesquad->squad[i]->base;
	newcr->hireid = activesquad->squad[i]->id;
	addCreature(newcr);
	stat_recruits++;
	for (int p = 0; p < 6; p++)
	{
		if (activesquad->squad[p] == NULL)
		{
			activesquad->squad[p] = newcr;
			newcr->squadid = activesquad->id;
			break;
		}
	}
}
void pressedKeyR(const int freeable, const int libnum, const int enemy, const int hostages, int& partysize) {
	extern Log gamelog;
	extern squadst *activesquad;
	extern short sitealarmtimer;
	extern short sitealarm;
	extern short cursite;
	extern Creature encounter[ENCMAX];
	if (LocationsPool::getInstance().isThereASiegeHere(cursite) && libnum > 6)
	{
		assemblesquad(activesquad);
		autopromote(cursite);
	}
	else if (freeable && (!enemy || !sitealarm) && !LocationsPool::getInstance().isThereASiegeHere(cursite))
	{
		short followers = 0, actgot = 0;
		if (enemy)sitealarm = 1;
		bool freed;
		do
		{
			bool flipstart = 0;
			freed = 0;
			for (int e = 0; e < ENCMAX; e++)
			{
				if (!encounter[e].exists)break;
				if ((encounter[e].type == CREATURE_WORKER_SERVANT ||
					encounter[e].type == CREATURE_WORKER_FACTORY_CHILD ||
					encounter[e].type == CREATURE_WORKER_SWEATSHOP ||
					(strcmp(encounter[e].name, CONST_sitemode141.c_str()) == 0 && encounter[e].align == 1)) && !flipstart)
				{
					if (strcmp(encounter[e].name, CONST_sitemode141.c_str()) == 0)
					{
						sitealarm = 1; /* alarm for prisoner escape */
						criminalize(encounter[e], LAWFLAG_ESCAPED);
					}
					followers++, flipstart = 1, freed = 1;
					if (partysize < 6)
					{
						int i = checkForPeopleWhoCanRecruit();

						// If someone can, add this person as a newly recruited Liberal!
						if (i < 6 && i > -1)
						{
							addNewRecruit(i, e);
							actgot++;
							partysize++;
						}
					}
				}
				if (flipstart)
					if (e < ENCMAX - 1)encounter[e] = encounter[e + 1];
			}
			if (flipstart)encounter[ENCMAX - 1].exists = 0;
			if (freed)
			{
				int time = 20 + LCSrandom(10);
				if (time < 1)time = 1;
				if (sitealarmtimer > time || sitealarmtimer == -1)sitealarmtimer = time;
			}
		} while (freed);
		if (followers > 0)
		{
			clearmessagearea();
			set_color_easy(WHITE_ON_BLACK_BRIGHT);
			mvaddstrAlt(16, 1, CONST_sitemode105, gamelog);
			if (followers > 1)addstrAlt(CONST_sitemode106, gamelog);
			else addstrAlt(CONST_sitemode107, gamelog);
			addstrAlt(CONST_sitemode108, gamelog);
			gamelog.newline();
			if (actgot < followers)
			{
				pressAnyKey();
				clearmessagearea();
				set_color_easy(WHITE_ON_BLACK_BRIGHT);
				if (actgot == 0 && followers > 1)mvaddstrAlt(16, 1, CONST_sitemode109, gamelog);
				else if (followers - actgot > 1)mvaddstrAlt(16, 1, CONST_sitemode110, gamelog);
				else if (actgot == 0)mvaddstrAlt(16, 1, CONST_sitemode111, gamelog);
				else mvaddstrAlt(16, 1, CONST_sitemode112, gamelog);
				addstrAlt(CONST_sitemode113, gamelog);
				gamelog.newline();
			}
			pressAnyKey();
		}
	}
	else if (hostages)
		releasehostage();
}
void getRandomLoot(int cursite);
Weapon* spawnNewWeapon(string newWeaponType);
Armor* spawnNewArmor(string newArmorType);
void pressedKeyG(const int enemy, int& encounter_timer) {
	extern Log gamelog;
	extern squadst *activesquad;
	extern newsstoryst *sitestory;
	extern short lawList[LAWNUM];
	extern siteblockst levelmap[MAPX][MAPY][MAPZ];
	extern vector<Item *> groundloot;
	extern int locx;
	extern int locy;
	extern int locz;
	extern short sitealarm;
	extern short cursite;
	extern short sitealarmtimer;
	extern short sitetype;
	extern int sitecrime;
	if ((isThereGroundLoot() || (levelmap[locx][locy][locz].flag&SITEBLOCK_LOOT)))
	{
		bool tookground = 0;
		if (levelmap[locx][locy][locz].flag&SITEBLOCK_LOOT)
		{
			levelmap[locx][locy][locz].flag &= ~SITEBLOCK_LOOT;
			if (LocationsPool::getInstance().isThereASiegeHere(cursite))
			{
				//GRAB SOME OF THE BASE LOOT
				int lcount = 1; //1 FROM THE ONE DELETED ABOVE
				for (int x = 0; x < MAPX; x++)
					for (int y = 0; y < MAPY; y++)
						for (int z = 0; z < MAPZ; z++)
							if (levelmap[x][y][z].flag&SITEBLOCK_LOOT)
								lcount++;
				int lplus = LocationsPool::getInstance().lenloot(cursite) / lcount;
				if (lcount == 1) lplus = LocationsPool::getInstance().lenloot(cursite);
				for (; lplus > 0; lplus--)
				{
					getRandomLoot(cursite);
				}
			}
			else
			{
				int time = 20 + LCSrandom(10);
				if (time < 1)time = 1;
				if (sitealarmtimer > time || sitealarmtimer == -1)sitealarmtimer = time;
				Item *item;
				string newLootType, newWeaponType, newArmorType;
				switch (sitetype)
				{
				case SITE_RESIDENTIAL_TENEMENT:
					if (!LCSrandom(25))
					{
						string rndWeps[] = { tag_WEAPON_BASEBALLBAT, tag_WEAPON_CROWBAR, tag_WEAPON_SHANK,
							tag_WEAPON_SYRINGE, tag_WEAPON_CHAIN, tag_WEAPON_GUITAR,tag_WEAPON_SPRAYCAN };
						newWeaponType = pickrandom(rndWeps);
					}
					else if (!LCSrandom(20))
					{
						string rndArmors[] = { tag_ARMOR_CHEAPDRESS, tag_ARMOR_CHEAPSUIT, tag_ARMOR_CLOTHES, tag_ARMOR_TRENCHCOAT,
							tag_ARMOR_WORKCLOTHES, tag_ARMOR_TOGA, tag_ARMOR_PRISONER };
						newArmorType = pickrandom(rndArmors);
					}
					else if (!LCSrandom(3))newLootType = tag_LOOT_KIDART;
					else if (!LCSrandom(2))newLootType = tag_LOOT_DIRTYSOCK;
					else newLootType = tag_LOOT_FAMILYPHOTO;
					break;
				case SITE_BUSINESS_BANK:
					if (!LCSrandom(4))newLootType = tag_LOOT_WATCH;
					else if (!LCSrandom(3))newLootType = tag_LOOT_CELLPHONE;
					else if (!LCSrandom(2))newLootType = tag_LOOT_PDA;
					else newLootType = tag_LOOT_COMPUTER;
					break;
				case SITE_RESIDENTIAL_APARTMENT:
					if (!LCSrandom(25))
					{
						string rndWeps[] = { tag_WEAPON_BASEBALLBAT, tag_WEAPON_REVOLVER_38,
							tag_WEAPON_REVOLVER_44, tag_WEAPON_NIGHTSTICK, tag_WEAPON_GUITAR };
						newWeaponType = pickrandom(rndWeps);
					}
					else if (!LCSrandom(20))
					{
						string rndArmors[] = { tag_ARMOR_CHEAPDRESS, tag_ARMOR_CHEAPSUIT, tag_ARMOR_CLOTHES, tag_ARMOR_TRENCHCOAT,
							tag_ARMOR_WORKCLOTHES, tag_ARMOR_CLOWNSUIT, tag_ARMOR_ELEPHANTSUIT, tag_ARMOR_DONKEYSUIT };
						newArmorType = pickrandom(rndArmors);
					}
					else if (!LCSrandom(5))newLootType = tag_LOOT_CELLPHONE;
					else if (!LCSrandom(4))newLootType = tag_LOOT_SILVERWARE;
					else if (!LCSrandom(3))newLootType = tag_LOOT_TRINKET;
					else if (!LCSrandom(2))newLootType = tag_LOOT_CHEAPJEWELERY;
					else newLootType = tag_LOOT_COMPUTER;
					break;
				case SITE_RESIDENTIAL_APARTMENT_UPSCALE:
					if (!LCSrandom(30))
					{
						string rndWeps[] = { tag_WEAPON_BASEBALLBAT, tag_WEAPON_COMBATKNIFE, tag_WEAPON_DAISHO, tag_WEAPON_SHOTGUN_PUMP,
							tag_WEAPON_REVOLVER_44, tag_WEAPON_SEMIPISTOL_45, tag_WEAPON_SEMIRIFLE_AR15, tag_WEAPON_AUTORIFLE_M16 };
						//make sure the number of types matches the random range...
						newWeaponType = rndWeps[LCSrandom(6 - lawList[LAW_GUNCONTROL])];
					}
					else if (!LCSrandom(20))
					{
						string rndArmors[] = { tag_ARMOR_EXPENSIVEDRESS, tag_ARMOR_BLACKDRESS, tag_ARMOR_EXPENSIVESUIT, tag_ARMOR_BLACKSUIT,
							tag_ARMOR_BONDAGEGEAR, tag_ARMOR_CIVILLIANARMOR, tag_ARMOR_BLACKROBE, tag_ARMOR_LABCOAT };
						newArmorType = pickrandom(rndArmors);
					}
					else if (!LCSrandom(10))newLootType = tag_LOOT_EXPENSIVEJEWELERY;
					else if (!LCSrandom(5))newLootType = tag_LOOT_CELLPHONE;
					else if (!LCSrandom(4))newLootType = tag_LOOT_SILVERWARE;
					else if (!LCSrandom(3))newLootType = tag_LOOT_PDA;
					else if (!LCSrandom(2))newLootType = tag_LOOT_CHEAPJEWELERY;
					else newLootType = tag_LOOT_COMPUTER;
					break;
				case SITE_LABORATORY_COSMETICS:
				case SITE_INDUSTRY_NUCLEAR:
				case SITE_LABORATORY_GENETIC:
					if (!LCSrandom(20))newLootType = tag_LOOT_RESEARCHFILES;
					else if (!LCSrandom(2))newLootType = tag_LOOT_LABEQUIPMENT;
					else if (!LCSrandom(2))newLootType = tag_LOOT_COMPUTER;
					else if (!LCSrandom(5))newLootType = tag_LOOT_PDA;
					else if (!LCSrandom(5))newLootType = tag_LOOT_CHEMICAL;
					else newLootType = tag_LOOT_COMPUTER;
					break;
				case SITE_GOVERNMENT_POLICESTATION:
					if (!LCSrandom(25))
					{
						string rndWeps[] = { tag_WEAPON_NIGHTSTICK, tag_WEAPON_NIGHTSTICK, tag_WEAPON_SHOTGUN_PUMP, tag_WEAPON_SEMIPISTOL_9MM,
							tag_WEAPON_SMG_MP5, tag_WEAPON_CARBINE_M4, tag_WEAPON_AUTORIFLE_M16, tag_WEAPON_AUTORIFLE_M16 };
						//make sure the number of types matches the random range...
						newWeaponType = rndWeps[LCSrandom(4) + 2 - lawList[LAW_GUNCONTROL]];
					}
					else if (!LCSrandom(25))
					{
						string rndArmors[] = { tag_ARMOR_POLICEUNIFORM, tag_ARMOR_POLICEUNIFORM, tag_ARMOR_POLICEARMOR, tag_ARMOR_POLICEUNIFORM,
							tag_ARMOR_SWATARMOR, tag_ARMOR_POLICEUNIFORM, tag_ARMOR_POLICEARMOR, tag_ARMOR_DEATHSQUADUNIFORM };
						//make sure the number of types matches the random range...
						newArmorType = rndArmors[LCSrandom(4) + 2 - lawList[LAW_GUNCONTROL]];
					}
					else if (!LCSrandom(20))newLootType = tag_LOOT_POLICERECORDS;
					else if (!LCSrandom(3))newLootType = tag_LOOT_CELLPHONE;
					else if (!LCSrandom(2))newLootType = tag_LOOT_PDA;
					else newLootType = tag_LOOT_COMPUTER;
					break;
				case SITE_GOVERNMENT_COURTHOUSE:
					if (!LCSrandom(20))newLootType = tag_LOOT_JUDGEFILES;
					else if (!LCSrandom(3))newLootType = tag_LOOT_CELLPHONE;
					else if (!LCSrandom(2))newLootType = tag_LOOT_PDA;
					else newLootType = tag_LOOT_COMPUTER;
					break;
				case SITE_GOVERNMENT_PRISON:
					if (!LCSrandom(5))
						newArmorType = tag_ARMOR_PRISONER;
					else newWeaponType = tag_WEAPON_SHANK;
					break;
				case SITE_GOVERNMENT_WHITE_HOUSE:
					if (!LCSrandom(20))newLootType = tag_LOOT_SECRETDOCUMENTS;
					else if (!LCSrandom(3))newLootType = tag_LOOT_CELLPHONE;
					else if (!LCSrandom(2))newLootType = tag_LOOT_PDA;
					else newLootType = tag_LOOT_COMPUTER;
					break;
				case SITE_GOVERNMENT_ARMYBASE:
					if (!LCSrandom(3))
					{
						string rndWeps[] = { tag_WEAPON_SEMIPISTOL_9MM, tag_WEAPON_CARBINE_M4, tag_WEAPON_AUTORIFLE_M16 };
						newWeaponType = pickrandom(rndWeps);
					}
					else if (!LCSrandom(2))
					{
						string rndArmors[] = { tag_ARMOR_ARMYARMOR };
						newArmorType = pickrandom(rndArmors);
					}
					else if (!LCSrandom(20))newLootType = tag_LOOT_SECRETDOCUMENTS;
					else if (!LCSrandom(3))newLootType = tag_LOOT_CELLPHONE;
					else if (!LCSrandom(2))newLootType = tag_LOOT_WATCH;
					else newLootType = tag_LOOT_TRINKET;
					break;
				case SITE_GOVERNMENT_INTELLIGENCEHQ:
					if (!LCSrandom(24))
					{
						string rndWeps[] = { tag_WEAPON_FLAMETHROWER, tag_WEAPON_SEMIPISTOL_45,
							tag_WEAPON_SMG_MP5, tag_WEAPON_CARBINE_M4, tag_WEAPON_AUTORIFLE_M16 };
						newWeaponType = pickrandom(rndWeps);
					}
					else if (!LCSrandom(30))
					{
						string rndArmors[] = { tag_ARMOR_HEAVYARMOR };
						newArmorType = pickrandom(rndArmors);
					}
					else if (!LCSrandom(20))newLootType = tag_LOOT_SECRETDOCUMENTS;
					else if (!LCSrandom(3))newLootType = tag_LOOT_CELLPHONE;
					else if (!LCSrandom(2))newLootType = tag_LOOT_PDA;
					else newLootType = tag_LOOT_COMPUTER;
					break;
				case SITE_GOVERNMENT_FIRESTATION:
					if (!LCSrandom(25)) newArmorType = tag_ARMOR_BUNKERGEAR;
					else if (LCSrandom(2))newLootType = tag_LOOT_TRINKET;
					else newLootType = tag_LOOT_COMPUTER;
					break;
				case SITE_INDUSTRY_SWEATSHOP:
					newLootType = tag_LOOT_FINECLOTH;
					break;
				case SITE_INDUSTRY_POLLUTER:
					newLootType = tag_LOOT_CHEMICAL;
					break;
				case SITE_CORPORATE_HEADQUARTERS:
					if (!LCSrandom(50))newLootType = tag_LOOT_CORPFILES;
					else if (!LCSrandom(3))newLootType = tag_LOOT_CELLPHONE;
					else if (!LCSrandom(2))newLootType = tag_LOOT_PDA;
					else newLootType = tag_LOOT_COMPUTER;
					break;
				case SITE_CORPORATE_HOUSE:
					if (!LCSrandom(50))
					{
						string rndArmors[] = { tag_ARMOR_EXPENSIVEDRESS, tag_ARMOR_EXPENSIVESUIT, tag_ARMOR_EXPENSIVESUIT,
							tag_ARMOR_EXPENSIVESUIT, tag_ARMOR_BONDAGEGEAR };
						newArmorType = pickrandom(rndArmors);
					}
					if (!LCSrandom(8))newLootType = tag_LOOT_TRINKET;
					else if (!LCSrandom(7))newLootType = tag_LOOT_WATCH;
					else if (!LCSrandom(6))newLootType = tag_LOOT_PDA;
					else if (!LCSrandom(5))newLootType = tag_LOOT_CELLPHONE;
					else if (!LCSrandom(4))newLootType = tag_LOOT_SILVERWARE;
					else if (!LCSrandom(3))newLootType = tag_LOOT_CHEAPJEWELERY;
					else if (!LCSrandom(2))newLootType = tag_LOOT_FAMILYPHOTO;
					else newLootType = tag_LOOT_COMPUTER;
					break;
				case SITE_MEDIA_AMRADIO:
					if (!LCSrandom(20))newLootType = tag_LOOT_AMRADIOFILES;
					else if (!LCSrandom(4))newLootType = tag_LOOT_MICROPHONE;
					else if (!LCSrandom(3))newLootType = tag_LOOT_PDA;
					else if (!LCSrandom(2))newLootType = tag_LOOT_CELLPHONE;
					else newLootType = tag_LOOT_COMPUTER;
					break;
				case SITE_MEDIA_CABLENEWS:
					if (!LCSrandom(20))newLootType = tag_LOOT_CABLENEWSFILES;
					else if (!LCSrandom(4))newLootType = tag_LOOT_MICROPHONE;
					else if (!LCSrandom(3))newLootType = tag_LOOT_PDA;
					else if (!LCSrandom(2))newLootType = tag_LOOT_CELLPHONE;
					else newLootType = tag_LOOT_COMPUTER;
					break;
				case SITE_BUSINESS_BARANDGRILL:
				case SITE_OUTDOOR_BUNKER:
				case SITE_RESIDENTIAL_BOMBSHELTER:
					//storming a CCS stronghold. Logically you ought to get all the leftover stuff if you win...
					string rndWeps[] = { tag_WEAPON_SEMIPISTOL_9MM, tag_WEAPON_SEMIPISTOL_45, tag_WEAPON_REVOLVER_38, tag_WEAPON_REVOLVER_44,
						tag_WEAPON_SMG_MP5, tag_WEAPON_CARBINE_M4, tag_WEAPON_AUTORIFLE_M16 };
					string rndArmors[] = { tag_ARMOR_CHEAPSUIT, tag_ARMOR_CLOTHES, tag_ARMOR_TRENCHCOAT, tag_ARMOR_WORKCLOTHES,
						tag_ARMOR_SECURITYUNIFORM, tag_ARMOR_CIVILLIANARMOR, tag_ARMOR_ARMYARMOR, tag_ARMOR_HEAVYARMOR };
					switch (LCSrandom(3))
					{
					case 0:
						newWeaponType = pickrandom(rndWeps);
						break;
					case 1:
						newArmorType = pickrandom(rndArmors);
						break;
					default:
						if (!LCSrandom(5))newLootType = tag_LOOT_CELLPHONE;
						else if (!LCSrandom(4))newLootType = tag_LOOT_SILVERWARE;
						else if (!LCSrandom(3))newLootType = tag_LOOT_TRINKET;
						else if (!LCSrandom(2))newLootType = tag_LOOT_CHEAPJEWELERY;
						else newLootType = tag_LOOT_COMPUTER;
						break;
					}
					break;
				}
				item = NULL;
				if (len(newLootType))
				{
					item = getNewLoot(newLootType);
					activesquad->loot.push_back(item);
				}
				if (len(newArmorType))
				{
					item = spawnNewArmor(newArmorType);
					activesquad->loot.push_back(item);
				}
				if (len(newWeaponType))
				{

					item = spawnNewWeapon(newWeaponType);
					activesquad->loot.push_back(item);
				}
				if (item)
				{
					string s = item->equip_title();
					clearmessagearea();
					set_color_easy(WHITE_ON_BLACK);
					mvaddstrAlt(16, 1, CONST_sitemode114, gamelog);
					mvaddstrAlt(17, 1, s, gamelog);
					gamelog.newline();
					pressAnyKey(); //wait for key press before clearing.
				}
			}
			tookground = 1;
		}
		//MAKE GROUND LOOT INTO MISSION LOOT
		for (int l = 0; l < len(groundloot); l++)
			activesquad->loot.push_back(groundloot[l]);
		groundloot.clear();
		if (enemy&&sitealarm)enemyattack();
		else if (enemy)disguisecheck(encounter_timer);
		if (tookground)
		{
			// If the party steals from the ground, party member 0 gets the blame
			juiceparty(1, 200);
			alienationcheck(0);
			noticecheck(-1);
			sitecrime++;
			sitestory->crime.push_back(CRIME_STOLEGROUND);
			if (enemy)
				criminalize(*(activesquad->squad[0]), LAWFLAG_THEFT);
		}
		creatureadvance();
		encounter_timer++;
	}
}
void putBackSpecials(const int olocx, const int olocy, const int olocz) {
	extern siteblockst levelmap[MAPX][MAPY][MAPZ];
	extern Creature encounter[ENCMAX];
	//PUT BACK SPECIALS
	for (int e = 0; e < ENCMAX; e++)
		if (encounter[e].exists)
		{
			if (!encounter[e].cantbluff&&encounter[e].type == CREATURE_LANDLORD)
				levelmap[olocx][olocy][olocz].special = SPECIAL_APARTMENT_LANDLORD;
			if (!encounter[e].cantbluff&&encounter[e].type == CREATURE_BANK_TELLER)
				levelmap[olocx][olocy][olocz].special = SPECIAL_BANK_TELLER;
			encounter[e].exists = 0;
		}
}
void enemyAttemptsFreeShots(int& encounter_timer) {
	extern Log gamelog;
	extern squadst *activesquad;
	extern short fieldskillrate;
	extern short sitealarm;
	extern Creature encounter[ENCMAX];
	//ENEMIES SHOULD GET FREE SHOTS NOW
	if (sitealarm)
	{
		bool snuck_away = true;
		// Try to sneak past
		for (int e = 0; e < ENCMAX && snuck_away; e++)
		{
			if (encounter[e].exists &&
				encounter[e].alive  &&
				encounter[e].cantbluff == 2)
			{
				// You can't sneak past this person; they already know you're there
				snuck_away = false;
			}
		}
		// If you can sneak past all enemies
		if (snuck_away)
		{
			for (int e = 0; e < ENCMAX && snuck_away; e++)
			{
				if (!encounter[e].exists)continue;
				for (int i = 0; i < 6; i++)
				{
					if (activesquad->squad[i])
					{
						int roll = activesquad->squad[i]->skill_roll(SKILL_STEALTH);
						if (roll + 1 == DIFFICULTY_HARD && fieldskillrate == FIELDSKILLRATE_HARD)
							activesquad->squad[i]->train(SKILL_STEALTH, 10);
						if (roll < DIFFICULTY_HARD)
						{
							snuck_away = false;
							break;
						}
					}
				}
			}
		}
		// If snuck past everyone
		if (snuck_away)
		{
			for (int i = 0; i < 6; i++)
			{
				if (activesquad->squad[i] != NULL)
				{
					switch (fieldskillrate)
					{
					case FIELDSKILLRATE_FAST:
						activesquad->squad[i]->train(SKILL_STEALTH, 40); break;
					case FIELDSKILLRATE_CLASSIC:
						activesquad->squad[i]->train(SKILL_STEALTH, 10); break;
					case FIELDSKILLRATE_HARD:
						activesquad->squad[i]->train(SKILL_STEALTH, 0); break;
					}
				}
			}
			clearmessagearea();
			set_color_easy(CYAN_ON_BLACK_BRIGHT);
			mvaddstrAlt(16, 1, CONST_sitemode115, gamelog);
			gamelog.newline();
			pressAnyKey();
		}
		else
			enemyattack();
	}
	else disguisecheck(encounter_timer);
}
void bailUponVictory() {
	extern Log gamelog;
	extern short cursite;
	extern newsstoryst *sitestory;
	extern squadst *activesquad;
	extern MusicClass music;
	music.play(MUSIC_CONQUER);
	if (LocationsPool::getInstance().isThisUnderAttack(cursite))sitestory->type = NEWSSTORY_SQUAD_DEFENDED;
	else sitestory->type = NEWSSTORY_SQUAD_BROKESIEGE;
	if (LocationsPool::getInstance().getSiegeType(cursite) == SIEGE_CCS)
	{
		// CCS DOES NOT capture the warehouse -- reverse earlier assumption of your defeat!
		if (LocationsPool::getInstance().getLocationType(cursite) == SITE_INDUSTRY_WAREHOUSE || LocationsPool::getInstance().getLocationType(cursite) == SITE_BUSINESS_CRACKHOUSE)
			LocationsPool::getInstance().setRenting(cursite, RENTING_PERMANENT);
		else if (LocationsPool::getInstance().getLocationType(cursite) == SITE_RESIDENTIAL_TENEMENT)
			LocationsPool::getInstance().setRenting(cursite, 200);
		else if (LocationsPool::getInstance().getLocationType(cursite) == SITE_RESIDENTIAL_APARTMENT)
			LocationsPool::getInstance().setRenting(cursite, 650);
		else if (LocationsPool::getInstance().getLocationType(cursite) == SITE_RESIDENTIAL_APARTMENT_UPSCALE)
			LocationsPool::getInstance().setRenting(cursite, 1500);
	}
	//DEAL WITH PRISONERS AND STOP BLEEDING
	for (int p = 0; p < 6; p++)
	{
		if (activesquad->squad[p] == NULL)continue;
		if (activesquad->squad[p]->prisoner != NULL)
		{
			if (activesquad->squad[p]->prisoner->squadid != -1)
			{
				//RESTORE POOL MEMBER
				activesquad->squad[p]->prisoner->squadid = -1;
				//MUST LOCATE THE MEMBER
				activesquad->squad[p]->prisoner->location = activesquad->squad[p]->base;
				activesquad->squad[p]->prisoner->base = activesquad->squad[p]->base;
			}
			else
			{
				//CONVERT KIDNAP VICTIM
				kidnaptransfer(*activesquad->squad[p]->prisoner);
				delete activesquad->squad[p]->prisoner;
			}
			activesquad->squad[p]->prisoner = NULL;
		}
	}
	//Clear all bleeding and prison escape flags
	CreaturePool::getInstance().clearAllBleedingAndEscapeFlags();
	//INFORM
	clearmessagearea();
	set_color_easy(GREEN_ON_BLACK_BRIGHT);
	mvaddstrAlt(16, 1, CONST_sitemode118, gamelog);
	mvaddstrAlt(17, 1, CONST_sitemode119, gamelog);
	gamelog.newline();
	pressAnyKey();
	conquertext();
	escapesiege(1);
}
void bailOnBase() {
	extern Log gamelog;
	extern squadst *activesquad;
	extern short postalarmtimer;
	extern short sitetype;
	extern int sitecrime;
	extern short sitealarm;
	extern short cursite;
	extern chaseseqst chaseseq;
	extern char showcarprefs;
	extern newsstoryst *sitestory;
	// Seperate logging message.
	gamelog.record(activesquad->name);
	gamelog.record(CONST_sitemode116);
	if (LocationsPool::getInstance().isThisAFront(cursite) != -1)
		gamelog.record(LocationsPool::getInstance().getFrontName(cursite));
	else
		gamelog.record(LocationsPool::getInstance().getLocationName(cursite));
	gamelog.record(singleDot);
	gamelog.nextMessage();
	//RESET MODE PRIOR TO CHASE
	showcarprefs = 0;
	//CHASE SEQUENCE OR FOOT CHASE
	chaseseq.clean();
	chaseseq.location = cursite;
	long level = sitecrime;
	if (sitealarm == 0)level = 0;
	if (LCSrandom(3) && level < 4)level = 0;
	if (LCSrandom(2) && level < 8)level = 0;
	if (postalarmtimer < 10 + (int)LCSrandom(20))level = 0;
	else if (postalarmtimer < 20 + (int)LCSrandom(20) && LCSrandom(3))level = 0;
	else if (postalarmtimer < 40 + (int)LCSrandom(20) && !LCSrandom(3))level = 0;
	if (LocationsPool::getInstance().isThereASiegeHere(cursite))level = 1000;
	//MAKE SURE YOU ARE GUILTY OF SOMETHING
	bool guilty = 0;
	for (int p = 0; p < 6; p++)
		if (activesquad->squad[p] != NULL)
			if (iscriminal(*activesquad->squad[p]))guilty = 1;
	if (!guilty)level = 0;
	makechasers(sitetype, level);
	bool havecar = 0;
	for (int p = 0; p < 6; p++)
	{
		if (activesquad->squad[p] != NULL)
		{
			if (activesquad->squad[p]->carid != -1)
			{
				havecar = 1;
				for (int i = 0; i < 6; i++)
				{
					if (activesquad->squad[i] != NULL &&
						activesquad->squad[i]->carid == -1)
					{
						activesquad->squad[i]->carid = activesquad->squad[p]->carid;
					}
				}
				break;
			}
		}
	}
	bool gotout;
	if (havecar)gotout = chasesequence();
	else gotout = footchase();
	//If you survived
	if (gotout)
	{
		//Check for hauled prisoners/corpses
		for (int p = 0; p < 6; p++)
		{
			if (activesquad->squad[p] == NULL)continue;
			if (activesquad->squad[p]->prisoner != NULL)
			{
				//If this is an LCS member or corpse being hauled (marked as in the squad)
				if (activesquad->squad[p]->prisoner->squadid != -1)
				{
					//Take them out of the squad
					activesquad->squad[p]->prisoner->squadid = -1;
					//Set base and current location to squad's safehouse
					activesquad->squad[p]->prisoner->location = activesquad->squad[p]->base;
					activesquad->squad[p]->prisoner->base = activesquad->squad[p]->base;
				}
				else //A kidnapped conservative
				{
					//Convert them into a prisoner
					kidnaptransfer(*activesquad->squad[p]->prisoner);
					delete activesquad->squad[p]->prisoner;
				}
				activesquad->squad[p]->prisoner = NULL;
			}
		}
		//Clear all bleeding and prison escape flags
		CreaturePool::getInstance().clearAllBleedingAndEscapeFlags();
		//END SITE MODE
		if (LocationsPool::getInstance().isThereASiegeHere(cursite))
		{
			//Special handling for escaping siege
			escapesiege(0);
		}
		else
		{
			resolvesite();
		}
	}
	//You didn't survive -- handle squad death (unless that ended the game)
	else if (!endcheck())
	{
		if (LocationsPool::getInstance().isThereASiegeHere(cursite))
		{
			//Report on squad killed during siege
			if (LocationsPool::getInstance().isThisUnderAttack(cursite))sitestory->type = NEWSSTORY_SQUAD_KILLED_SIEGEATTACK;
			else sitestory->type = NEWSSTORY_SQUAD_KILLED_SIEGEESCAPE;
			LocationsPool::getInstance().isThereASiegeHere(cursite, 0);
		}
		else
		{
			//Or report on your failed raid
			sitestory->type = NEWSSTORY_SQUAD_KILLED_SITE;
			//Would juice the party here, but you're all dead, so...
			resolvesite();
		}
	}
}
void bailUponDefeatCCS() {
	extern Log gamelog;
	extern short cursite;
	extern char ccs_kills;
	extern squadst *activesquad;
	extern char endgamestate;
	extern MusicClass music;
	music.play(MUSIC_CONQUER);
	//DEAL WITH PRISONERS AND STOP BLEEDING
	for (int p = 0; p < 6; p++)
	{
		if (activesquad->squad[p] == NULL)continue;
		if (activesquad->squad[p]->prisoner != NULL)
		{
			if (activesquad->squad[p]->prisoner->squadid != -1)
			{
				//RESTORE POOL MEMBER
				activesquad->squad[p]->prisoner->squadid = -1;
				//MUST LOCATE THE MEMBER
				activesquad->squad[p]->prisoner->location = activesquad->squad[p]->base;
				activesquad->squad[p]->prisoner->base = activesquad->squad[p]->base;
			}
			else
			{
				//CONVERT KIDNAP VICTIM
				kidnaptransfer(*activesquad->squad[p]->prisoner);
				delete activesquad->squad[p]->prisoner;
			}
			activesquad->squad[p]->prisoner = NULL;
		}
	}
	//Clear all bleeding and prison escape flags
	CreaturePool::getInstance().clearAllBleedingAndEscapeFlags();
	//INFORM
	clearmessagearea();
	set_color_easy(GREEN_ON_BLACK_BRIGHT);
	mvaddstrAlt(16, 1, CONST_sitemode117, gamelog);
	gamelog.newline();
	pressAnyKey();
	LocationsPool::getInstance().captureSite(cursite);
	// CCS Safehouse killed?
	if (LocationsPool::getInstance().getLocationType(cursite) == SITE_RESIDENTIAL_BOMBSHELTER ||
		LocationsPool::getInstance().getLocationType(cursite) == SITE_BUSINESS_BARANDGRILL ||
		LocationsPool::getInstance().getLocationType(cursite) == SITE_OUTDOOR_BUNKER)
	{
		ccs_kills++;
		if (ccs_kills < 3) endgamestate--;
		else endgamestate = ENDGAME_CCS_DEFEATED;
	}
	conquertextccs();
}
int attemptResolveSiege(const int olocx, const int olocy, const int olocz) {
	extern siteblockst levelmap[MAPX][MAPY][MAPZ];
	extern int locx;
	extern int locy;
	extern int locz;
	extern short cursite;

	if (locx != olocx || locy != olocy || locz != olocz)
		emptyEncounter();
	//MOVE SIEGE UNITS AROUND
	//MOVE UNITS
	vector<int> unitx, unity, unitz;
	for (int x = 0; x < MAPX; x++) for (int y = 0; y < MAPY; y++) for (int z = 0; z < MAPZ; z++)
		if (levelmap[x][y][z].siegeflag&SIEGEFLAG_UNIT)
			unitx.push_back(x), unity.push_back(y), unitz.push_back(z);
	int sx = 0, sy = 0, sz = 0;
	for (int u = 0; u < len(unitx); u++)
	{
		// don't leave tile if player is here
		if (unitx[u] == locx && unity[u] == locy && unitz[u] == locz) continue;
		// move into player's tile if possible
		if ((((unitx[u] == locx - 1 || unitx[u] == locx + 1) &&
			unity[u] == locy) ||
			((unity[u] == locy - 1 || unity[u] == locy + 1) &&
				unitx[u] == locx))
			&& unitz[u] == locz)
		{
			levelmap[unitx[u]][unity[u]][unitz[u]].siegeflag &= ~SIEGEFLAG_UNIT;
			//Get torched
			if (levelmap[locx][locy][locz].flag & SITEBLOCK_FIRE_PEAK)
				levelmap[locx][locy][locz].siegeflag |= SIEGEFLAG_UNIT_DAMAGED;
			//BLOW TRAPS
			if (levelmap[locx][locy][locz].siegeflag & SIEGEFLAG_TRAP)
			{
				levelmap[locx][locy][locz].siegeflag &= ~SIEGEFLAG_TRAP;
				levelmap[locx][locy][locz].siegeflag |= SIEGEFLAG_UNIT_DAMAGED;
			}
			else levelmap[locx][locy][locz].siegeflag |= SIEGEFLAG_UNIT;
			continue;
		}
		sz = 0;
		switch (LCSrandom(4))
		{
		case 0: sx = -1, sy = 0; break;
		case 1: sx = 1, sy = 0; break;
		case 2: sx = 0, sy = 1; break;
		case 3: sx = 0, sy = -1; break;
		}
		sx += unitx[u], sy += unity[u], sz += unitz[u];
		if (sx >= 0 && sx < MAPX&&sy >= 0 && sy < MAPY&&sz >= 0 && sz < MAPZ)
			if (!(levelmap[sx][sy][sz].flag&SITEBLOCK_BLOCK))
			{
				if ((levelmap[sx][sy][sz].flag&SITEBLOCK_DOOR))
					levelmap[sx][sy][sz].flag &= ~(SITEBLOCK_DOOR | SITEBLOCK_LOCKED | SITEBLOCK_KLOCK | SITEBLOCK_CLOCK);
				else
				{  //BLOCK PASSAGE
					if (!(levelmap[sx][sy][sz].siegeflag&(SIEGEFLAG_UNIT | SIEGEFLAG_HEAVYUNIT)))
					{
						levelmap[unitx[u]][unity[u]][unitz[u]].siegeflag &= ~SIEGEFLAG_UNIT;
						//BLOW TRAPS
						if (levelmap[sx][sy][sz].siegeflag&SIEGEFLAG_TRAP)
						{
							levelmap[sx][sy][sz].siegeflag &= ~SIEGEFLAG_TRAP;
							levelmap[sx][sy][sz].siegeflag |= SIEGEFLAG_UNIT_DAMAGED;
						}
						else levelmap[sx][sy][sz].siegeflag |= SIEGEFLAG_UNIT;
					}
				}
			}
	}
	unitx.clear(), unity.clear(), unitz.clear();
	for (int u = 0; u < len(unitx); u++)
	{
		sz = 0;
		switch (LCSrandom(4))
		{
		case 0: sx = -1, sy = 0; break;
		case 1: sx = 1, sy = 0; break;
		case 2: sx = 0, sy = 1; break;
		case 3: sx = 0, sy = -1; break;
		}
		sx += unitx[u], sy += unity[u], sz += unitz[u];
		if (sx >= 0 && sx < MAPX&&sy >= 0 && sy < MAPY&&sz >= 0 && sz < MAPZ)
			if (!(levelmap[sx][sy][sz].flag&SITEBLOCK_BLOCK) && (levelmap[sx][sy][sz].flag&SITEBLOCK_DOOR))
				levelmap[sx][sy][sz].flag &= ~(SITEBLOCK_DOOR | SITEBLOCK_LOCKED | SITEBLOCK_KLOCK | SITEBLOCK_CLOCK);
	}
	unitx.clear(), unity.clear(), unitz.clear();
	//NEW WAVES
	//IF THERE AREN'T ENOUGH UNITS AROUND
	//AND THEY HAVEN'T BEEN SCARED OFF
	//MORE WAVES WILL ATTACK
	//AND IT GETS WORSE AND WORSE
	//but not as bad as it used to get,
	//since the extra waves are small
	LocationsPool::getInstance().tickAttackTime(cursite);
	if ((LocationsPool::getInstance().getAttackTime(cursite) >= 100 + LCSrandom(10) &&
		(locz != 0 || locx<(MAPX / 2 - 3) || locx>(MAPX / 2 + 3) ||
			locy > 5)))
	{
		LocationsPool::getInstance().resetAttackTime(cursite);
		int existingUnits = 0;
		for (int x = 0; x < MAPX; x++) for (int y = 0; y < MAPY; y++) for (int z = 0; z < MAPZ; z++)
			if (levelmap[x][y][z].siegeflag&(SIEGEFLAG_UNIT | SIEGEFLAG_HEAVYUNIT))
				existingUnits++;
		//PLACE UNITS
		int lx, ly, lz, unitnum = 7 - existingUnits, count = 10000;
		if (unitnum < 0)unitnum = 0;
		for (int t = 0; t < unitnum; t++)
		{
			count = 10000;
			do
			{
				lx = LCSrandom(7) + (MAPX / 2) - 3, ly = LCSrandom(5), lz = 0, count--;
				if (count == 0) break;
			} while ((levelmap[lx][ly][lz].flag & (SITEBLOCK_BLOCK | SITEBLOCK_DOOR | SITEBLOCK_EXIT)) ||
				(levelmap[lx][ly][lz].siegeflag & (SIEGEFLAG_UNIT | SIEGEFLAG_HEAVYUNIT | SIEGEFLAG_TRAP)));
			levelmap[lx][ly][lz].siegeflag |= SIEGEFLAG_UNIT;
		}
		if (!LocationsPool::getInstance().doWeHaveTankTraps(cursite) &&
			LocationsPool::getInstance().getSiegeType(cursite) == SIEGE_POLICE &&
			LocationsPool::getInstance().getSiegeEscalationState(cursite) >= 2)
		{
			count = 10000;
			int hunitnum = 1;
			for (int t = 0; t < hunitnum; t++)
			{
				do
				{
					lx = LCSrandom(7) + (MAPX / 2) - 3, ly = LCSrandom(5), lz = 0, count--;
					if (count == 0) break;
				} while ((levelmap[lx][ly][lz].flag&(SITEBLOCK_BLOCK | SITEBLOCK_DOOR | SITEBLOCK_EXIT)) ||
					(levelmap[lx][ly][lz].siegeflag&(SIEGEFLAG_UNIT | SIEGEFLAG_HEAVYUNIT | SIEGEFLAG_TRAP)));
				levelmap[lx][ly][lz].siegeflag |= SIEGEFLAG_HEAVYUNIT;
				LocationsPool::getInstance().spawnATank(cursite);
			}
		}
	}
	//CHECK FOR SIEGE UNITS
	//INCLUDING DAMAGED ONES
	if (levelmap[locx][locy][locz].siegeflag&SIEGEFLAG_UNIT)
	{
		if (addsiegeencounter(SIEGEFLAG_UNIT))
			levelmap[locx][locy][locz].siegeflag &= ~SIEGEFLAG_UNIT;
	}
	if (levelmap[locx][locy][locz].siegeflag&SIEGEFLAG_HEAVYUNIT)
	{
		if (addsiegeencounter(SIEGEFLAG_HEAVYUNIT))
			levelmap[locx][locy][locz].siegeflag &= ~SIEGEFLAG_HEAVYUNIT;
	}
	if (levelmap[locx][locy][locz].siegeflag&SIEGEFLAG_UNIT_DAMAGED)
	{
		if (addsiegeencounter(SIEGEFLAG_UNIT_DAMAGED))
			levelmap[locx][locy][locz].siegeflag &= ~SIEGEFLAG_UNIT_DAMAGED;
	}
	//BAIL UPON VICTORY
	if (LocationsPool::getInstance().getSiegeKills(cursite) >= 10 &&
		LocationsPool::getInstance().getSiegeTanks(cursite) < 1 &&
		LocationsPool::getInstance().isThereASiegeHere(cursite))
	{
		bailUponVictory();
		return 1;
	}
	return 0;
}
void encounterSpecial(const int makespecial, const int olocx, const int olocy, const int olocz) {
	extern Log gamelog;
	extern int locx;
	extern int locy;
	extern int locz;
	extern bool encounterwarnings;
	extern short sitetype;
	extern short cursite;
	extern short sitealienate;
	extern short sitealarm;
	extern UniqueCreatures uniqueCreatures;
	extern siteblockst levelmap[MAPX][MAPY][MAPZ];
	extern Creature encounter[ENCMAX];
	extern short lawList[LAWNUM];
	switch (makespecial)
	{
	case SPECIAL_CAFE_COMPUTER:
		if (sitealarm || sitealienate)
		{
			clearmessagearea();
			set_color_easy(WHITE_ON_BLACK_BRIGHT);
			mvaddstrAlt(16, 1, CONST_sitemode120, gamelog);
			gamelog.newline();
			levelmap[locx][locy][locz].special = -1;
			pressAnyKey();
		}
		else
		{
			clearmessagearea();
			set_color_easy(WHITE_ON_BLACK_BRIGHT);
			mvaddstrAlt(16, 1, CONST_sitemode121, gamelog);
			gamelog.newline();
			levelmap[locx][locy][locz].special = -1;
			pressAnyKey();
			prepareencounter(sitetype, 0);
			emptyEncounter();
		}
		break;
	case SPECIAL_RESTAURANT_TABLE:
		if (sitealarm || sitealienate)
		{
			clearmessagearea();
			set_color_easy(WHITE_ON_BLACK_BRIGHT);
			mvaddstrAlt(16, 1, CONST_sitemode122, gamelog);
			gamelog.newline();
			levelmap[locx][locy][locz].special = -1;
			pressAnyKey();
			prepareencounter(sitetype, 0);
		}
		else
		{
			clearmessagearea();
			set_color_easy(WHITE_ON_BLACK_BRIGHT);
			mvaddstrAlt(16, 1, CONST_sitemode123, gamelog);
			gamelog.newline();
			levelmap[locx][locy][locz].special = -1;
			pressAnyKey();
			prepareencounter(sitetype, 0);
		}
		break;
	case SPECIAL_PARK_BENCH:
		if (sitealarm || sitealienate)
		{
			clearmessagearea();
			set_color_easy(WHITE_ON_BLACK_BRIGHT);
			mvaddstrAlt(16, 1, CONST_sitemode124, gamelog);
			gamelog.newline();
			levelmap[locx][locy][locz].special = -1;
			pressAnyKey();
		}
		else
		{
			clearmessagearea();
			set_color_easy(WHITE_ON_BLACK_BRIGHT);
			mvaddstrAlt(16, 1, CONST_sitemode125, gamelog);
			gamelog.newline();
			levelmap[locx][locy][locz].special = -1;
			pressAnyKey();
			prepareencounter(sitetype, 0);
		}
		break;
	case SPECIAL_SECURITY_CHECKPOINT:
		special_security_checkpoint();
		break;
	case SPECIAL_SECURITY_METALDETECTORS:
		special_security_metaldetectors();
		break;
	case SPECIAL_SECURITY_SECONDVISIT:
		special_security_secondvisit();
		break;
	case SPECIAL_CLUB_BOUNCER:
		special_bouncer_assess_squad();
		break;
	case SPECIAL_CLUB_BOUNCER_SECONDVISIT:
		special_bouncer_greet_squad();
		break;
	case SPECIAL_HOUSE_CEO:
		if ((sitealarm || sitealienate || LocationsPool::getInstance().isThereASiegeHere(cursite)) &&
			uniqueCreatures.CEO_state == UNIQUECREATURE_ALIVE)
		{
			clearmessagearea(false);
			set_color_easy(WHITE_ON_BLACK_BRIGHT);
			if (lawList[LAW_FREESPEECH] != ALIGN_ARCHCONSERVATIVE)
				mvaddstrAlt(16, 1, CONST_sitemode126, gamelog);
			else
				mvaddstrAlt(16, 1, CONST_sitemode127, gamelog);
			addstrAlt(CONST_sitemode128, gamelog);
			gamelog.newline();
			levelmap[locx][locy][locz].special = -1;
			pressAnyKey();
		}
		else
		{
			switch (uniqueCreatures.CEO_state)
			{
			case UNIQUECREATURE_ALIVE:
				clearmessagearea(false);
				set_color_easy(WHITE_ON_BLACK_BRIGHT);
				mvaddstrAlt(16, 1, CONST_sitemode129, gamelog);
				gamelog.newline();
				levelmap[locx][locy][locz].special = -1;
				pressAnyKey();
				emptyEncounter();
				encounter[0] = uniqueCreatures.CEO();
				encounter[0].exists = true;
				break;
			case UNIQUECREATURE_DEAD:
			case UNIQUECREATURE_LIBERAL:
				clearmessagearea(false);
				set_color_easy(WHITE_ON_BLACK_BRIGHT);
				mvaddstrAlt(16, 1, CONST_sitemode130, gamelog);
				gamelog.newline();
				levelmap[locx][locy][locz].special = -1;
				pressAnyKey();
				break;
			}
		}
		break;
	case SPECIAL_APARTMENT_LANDLORD:
		if (sitealarm || sitealienate ||
			LocationsPool::getInstance().isThereASiegeHere(cursite))
		{
			clearmessagearea(false);
			set_color_easy(WHITE_ON_BLACK_BRIGHT);
			mvaddstrAlt(16, 1, CONST_sitemode131, gamelog);
			gamelog.newline();
			levelmap[locx][locy][locz].special = -1;
			pressAnyKey();
		}
		else
		{
			clearmessagearea(false);
			set_color_easy(WHITE_ON_BLACK_BRIGHT);
			mvaddstrAlt(16, 1, CONST_sitemode132, gamelog);
			gamelog.newline();
			levelmap[locx][locy][locz].special = -1;
			pressAnyKey();
			emptyEncounter();
			makecreature(encounter[0], CREATURE_LANDLORD);
		}
		break;
	case SPECIAL_BANK_TELLER:
		special_bank_teller();
		break;
	case SPECIAL_CCS_BOSS:
		special_ccs_boss();
		break;
	case SPECIAL_OVAL_OFFICE_NW:
	case SPECIAL_OVAL_OFFICE_NE:
	case SPECIAL_OVAL_OFFICE_SW:
	case SPECIAL_OVAL_OFFICE_SE:
		special_oval_office();
		break;
	default:
		bool squadmoved = (olocx != locx || olocy != locy || olocz != locz);
		if (squadmoved &&
			(LocationsPool::getInstance().getLocationType(cursite) == SITE_RESIDENTIAL_APARTMENT ||
				LocationsPool::getInstance().getLocationType(cursite) == SITE_RESIDENTIAL_TENEMENT ||
				LocationsPool::getInstance().getLocationType(cursite) == SITE_RESIDENTIAL_APARTMENT_UPSCALE))
		{
			if (LCSrandom(3))break; // Rarely encounter someone in apartments.
		}
		prepareencounter(sitetype, LocationsPool::getInstance().isThisPlaceHighSecurity(cursite));
		int numenc = 0;
		// TODO This is bizarre
		// the for loop breaks if it finds an empty encounter
		for (int e = 0; e < ENCMAX; e++)
		{
			if (encounter[e].exists) numenc++;
			else break;
		}
		if (encounterwarnings&&numenc > 0)
		{  // show an encounter warning, based on whether the squad moved or not and the size of the encounter
			clearmessagearea(false);
			set_color_easy(WHITE_ON_BLACK_BRIGHT);
			string weMoved;
			string weDidntMove;
			if (numenc == 1)
			{
				weMoved = CONST_sitemode133;
				weDidntMove = CONST_sitemode134;
			}
			else if (numenc <= 3)
			{
				weMoved = CONST_sitemode135;
				weDidntMove = CONST_sitemode136;
			}
			else if (numenc <= 6)
			{
				weMoved = CONST_sitemode137;
				weDidntMove = CONST_sitemode138;
			}
			else
			{
				weMoved = CONST_sitemode139;
				weDidntMove = CONST_sitemode140;
			}
			if (squadmoved) {
				mvaddstrAlt(16, 1, weMoved, gamelog);
			}
			else {
				mvaddstrAlt(16, 1, weDidntMove, gamelog);
			}
			gamelog.newline();
			pressAnyKey();
		}
		break;
	}
}
void pressedKeyShiftL() {

	reloadparty();
	printparty();
	refreshAlt();
	creatureadvance();

}
// return true if leaving site
int moveOrWaitThenCheckForExit(const int olocx, const int olocy, const int olocz, const char c, const int encsize, char& hostcheck) {

	extern int locx;
	extern int locy;
	extern int locz;
	extern short postalarmtimer;
	extern char showcarprefs;
	extern short cursite;
	extern int ccs_boss_kills;
	extern siteblockst levelmap[MAPX][MAPY][MAPZ];
	extern Creature encounter[ENCMAX];




	//SEE IF THERE IS AN ENCOUNTER
	char newenc = 0;
	// 10% chance of encounter normally (100% if waiting)
	// 20% chance of encounter after massive response
	// 0% chance of encounter during sieges
	if (!LocationsPool::getInstance().isThereASiegeHere(cursite))
	{
		if (postalarmtimer > 80) { if (!LCSrandom(5)) newenc = 1; }
		else if (!LCSrandom(10) || c == 's') newenc = 1;
	}
	for (int e = 0; e < ENCMAX; e++) if (encounter[e].exists) newenc = 0;
	// Handle special tiles that activate when you step on them
	// (rather than those that must be manually activated)
	long makespecial = -1;
	switch (levelmap[locx][locy][locz].special)
	{
	case SPECIAL_SECURITY_CHECKPOINT:
	case SPECIAL_SECURITY_METALDETECTORS:
	case SPECIAL_SECURITY_SECONDVISIT:
	case SPECIAL_CLUB_BOUNCER:
	case SPECIAL_CLUB_BOUNCER_SECONDVISIT:
	case SPECIAL_APARTMENT_LANDLORD:
	case SPECIAL_HOUSE_CEO:
	case SPECIAL_RESTAURANT_TABLE:
	case SPECIAL_CAFE_COMPUTER:
	case SPECIAL_PARK_BENCH:
	case SPECIAL_BANK_TELLER:
	case SPECIAL_CCS_BOSS:
	case SPECIAL_OVAL_OFFICE_NW:
	case SPECIAL_OVAL_OFFICE_NE:
	case SPECIAL_OVAL_OFFICE_SW:
	case SPECIAL_OVAL_OFFICE_SE:
		makespecial = levelmap[locx][locy][locz].special;
		newenc = 1;
		break;
	}
	//DO DOORS
	if (levelmap[locx][locy][locz].flag & SITEBLOCK_DOOR)
	{
		open_door(levelmap[olocx][olocy][olocz].flag&SITEBLOCK_RESTRICTED);
		locx = olocx, locy = olocy, locz = olocz;
		if (encsize > 0) newenc = 0;
	}
	//BAIL UPON VICTORY (version 2 -- defeated CCS safehouse)
	if (ccs_boss_kills >= 1 &&
		!LocationsPool::getInstance().isThereASiegeHere(cursite) &&
		LocationsPool::getInstance().getRentingType(cursite) == RENTING_CCS)
	{
		bailUponDefeatCCS();
		showcarprefs = 0;
		return 1;
	}
	if (LocationsPool::getInstance().isThereASiegeHere(cursite)) // *JDS* police response added
	{
		if (attemptResolveSiege(olocx, olocy, olocz)) {
			showcarprefs = 0;
			return 1;
		}
	}
	if (!LocationsPool::getInstance().isThereASiegeHere(cursite) && newenc)
	{
		encounterSpecial(makespecial, olocx, olocy, olocz);
		hostcheck = 1;
	}
	if (!LocationsPool::getInstance().isThereASiegeHere(cursite))
		if ((locx != olocx || locy != olocy || locz != olocz) && !newenc)
			putBackSpecials(olocx, olocy, olocz);

	if (locx != olocx || locy != olocy || locz != olocz)
	{
		//NUKE GROUND LOOT
		delete_and_clear_groundloot();
		//MOVE BLOOD
		if (levelmap[olocx][olocy][olocz].flag&SITEBLOCK_BLOODY2)
			levelmap[locx][locy][locz].flag |= SITEBLOCK_BLOODY;
	}
	knowmap();


	return 0;
}
void mode_site() {
	extern short cursite;
	extern squadst *activesquad;
	extern Log gamelog;
	extern MusicClass music;
	extern short postalarmtimer;
	extern short sitealarmtimer;
	extern short mode;
	extern bool mapshowing;
	extern short party_status;
	extern char foughtthisround;
	extern int sitecrime;
	extern int locx;
	extern int locy;
	extern int locz;
	extern short sitealarm;
	extern short sitealienate;
	extern newsstoryst *sitestory;
	extern char showcarprefs;
	extern short offended_amradio;
	extern short offended_cablenews;
	extern siteblockst levelmap[MAPX][MAPY][MAPZ];
	extern Creature encounter[ENCMAX];
	extern short lawList[LAWNUM];
	if (activesquad == NULL)return;
	reloadparty();
	showcarprefs = -1;
	char bail_on_base = 1;
	if (cursite == activesquad->squad[0]->base)bail_on_base = 0;
	knowmap();
	char hostcheck = 0;
	int encounter_timer = 0;
	while (true)
	{
		int partysize = squadsize(activesquad), partyalive = squadalive(activesquad), hostages = 0, encsize = 0, freeable = 0, enemy = 0, majorenemy = 0, talkers = 0;
		for (int p = 0; p < 6; p++)
			if (activesquad->squad[p] != NULL)
				if (activesquad->squad[p]->prisoner&&activesquad->squad[p]->prisoner->align != ALIGN_LIBERAL)
					hostages++;
		for (int e = 0; e < ENCMAX; e++)
		{
			if (encounter[e].exists)
			{
				encsize++;
				if (encounter[e].enemy())enemy++;
				if (encounter[e].type == CREATURE_WORKER_SERVANT ||
					encounter[e].type == CREATURE_WORKER_FACTORY_CHILD ||
					encounter[e].type == CREATURE_WORKER_SWEATSHOP ||
					(strcmp(encounter[e].name, CONST_sitemode141.c_str()) == 0 && encounter[e].align == 1))freeable++;
				else if ((encounter[e].cantbluff != 1 || sitealarm) && !(encounter[e].align == 1 && sitealarm&&enemy))talkers++;
				if (encounter[e].type == CREATURE_CORPORATE_CEO ||
					encounter[e].type == CREATURE_RADIOPERSONALITY ||
					encounter[e].type == CREATURE_NEWSANCHOR ||
					encounter[e].type == CREATURE_SCIENTIST_EMINENT ||
					encounter[e].type == CREATURE_JUDGE_CONSERVATIVE)majorenemy++;
			}
		}
		//If in combat, do a second check
		if (talkers&&sitealarm&&enemy)
		{
			talkers = 0;
			for (int e = 0; e < ENCMAX; e++)
				if (encounter[e].exists)
					if (encounter[e].enemy() && (encounter[e].cantbluff == 0 || encounter[e].animalgloss == ANIMALGLOSS_ANIMAL)) talkers++;
		}
		int libnum = CreaturePool::getInstance().countLiberals(cursite);
		// Let the squad stop stressing out over the encounter if there are no enemies this round
		if (!enemy) encounter_timer = 0;
		eraseAlt();
		{
			if (LocationsPool::getInstance().isThereASiegeHere(cursite))
			{
				music.play(MUSIC_DEFENSE);
				set_color_easy(RED_ON_BLACK_BRIGHT);
				mvaddstrAlt(0, 0, LocationsPool::getInstance().getLocationNameWithGetnameMethod(cursite, -1, true));
				addstrAlt(CONST_sitemode144);
				addstrAlt(locz + 1);
				addstrAlt(CONST_sitemode143);
			}
			else
			{
				if (postalarmtimer > 80) set_color_easy(RED_ON_BLACK_BRIGHT);
				else if (postalarmtimer > 60) set_color_easy(YELLOW_ON_BLACK_BRIGHT);
				else set_color_easy(WHITE_ON_BLACK);
				mvaddstrAlt(0, 0, LocationsPool::getInstance().getLocationNameWithGetnameMethod(cursite, -1, true));
				addstrAlt(CONST_sitemode144);
				addstrAlt(locz + 1);
				if (postalarmtimer > 80)
				{
					switch (LocationsPool::getInstance().getLocationType(cursite))
					{
					case SITE_GOVERNMENT_ARMYBASE:
						addstrAlt(CONST_sitemode145);
						break;
					case SITE_GOVERNMENT_WHITE_HOUSE:
						addstrAlt(CONST_sitemode146);
						break;
					case SITE_GOVERNMENT_INTELLIGENCEHQ:
						addstrAlt(CONST_sitemode147);
						break;
					case SITE_CORPORATE_HEADQUARTERS:
					case SITE_CORPORATE_HOUSE:
						addstrAlt(CONST_sitemode148);
						break;
					case SITE_MEDIA_AMRADIO:
					case SITE_MEDIA_CABLENEWS:
						addstrAlt(CONST_sitemode149);
						break;
					case SITE_BUSINESS_CRACKHOUSE:
						addstrAlt(CONST_sitemode150);
						break;
					case SITE_GOVERNMENT_POLICESTATION:
					default:
						if (LocationsPool::getInstance().getRentingType(cursite) == RENTING_CCS)
						{
							addstrAlt(CONST_sitemode151);
						}
						else if (lawList[LAW_DEATHPENALTY] == -2 &&
							lawList[LAW_POLICEBEHAVIOR] == -2)addstrAlt(CONST_sitemode152);
						else addstrAlt(CONST_sitemode153);
						break;
					}
					music.play(MUSIC_HEAVYCOMBAT);
				}
				else if (postalarmtimer > 60) { addstrAlt(CONST_sitemode154); music.play(MUSIC_ALARMED); }
				else if (sitealienate == 1) { addstrAlt(CONST_sitemode155); music.play(MUSIC_ALARMED); }
				else if (sitealienate == 2) { addstrAlt(CONST_sitemode156); music.play(MUSIC_ALARMED); }
				else if (sitealarm) { addstrAlt(CONST_sitemode157); music.play(MUSIC_ALARMED); }
				else if (sitealarmtimer == 0) { addstrAlt(CONST_sitemode158); music.play(MUSIC_SUSPICIOUS); }
				else music.play(MUSIC_SITEMODE);
			}
		}
		{
			//PRINT PARTY
			if (partyalive == 0)party_status = -1;
			printparty();
			//PRINT SITE INSTRUCTIONS
			if (partyalive > 0)
			{
				if (!enemy || !sitealarm)set_color_easy(WHITE_ON_BLACK);
				else set_color_easy(BLACK_ON_BLACK_BRIGHT);
				mvaddstrAlt(9, 1, CONST_sitemode159);
				if (partysize > 1)set_color_easy(WHITE_ON_BLACK);
				else set_color_easy(BLACK_ON_BLACK_BRIGHT);
				mvaddstrAlt(11, 1, change_squad_order);
				if (partysize > 0 && (party_status == -1 || partysize > 1))set_color_easy(WHITE_ON_BLACK);
				else set_color_easy(BLACK_ON_BLACK_BRIGHT);
				mvaddstrAlt(12, 1, check_status_of_squad_liberal);
				if (party_status != -1)set_color_easy(WHITE_ON_BLACK);
				else set_color_easy(BLACK_ON_BLACK_BRIGHT);
				mvaddstrAlt(13, 1, show_squad_liberal_status);
				if (isThereGroundLoot() || (levelmap[locx][locy][locz].flag&SITEBLOCK_LOOT))
					set_color_easy(WHITE_ON_BLACK);
				else set_color_easy(BLACK_ON_BLACK_BRIGHT);
				mvaddstrAlt(9, 17, CONST_sitemode160);
				set_color_easy(WHITE_ON_BLACK);
				mvaddstrAlt(10, 17, CONST_sitemode161);
				set_color_easy(WHITE_ON_BLACK);
				mvaddstrAlt(9, 32, CONST_sitemode162);
				set_color_easy(WHITE_ON_BLACK);
				mvaddstrAlt(10, 32, CONST_sitemode163);
				if (!enemy || !sitealarm) set_color_easy(WHITE_ON_BLACK);
				else set_color_easy(BLACK_ON_BLACK_BRIGHT);
				mvaddstrAlt(10, 42, CONST_sitemode164);
				mvaddstrAlt(10, 1, CONST_sitemodeXRL);
				if (enemy) set_color_easy(WHITE_ON_BLACK);
				else set_color_easy(BLACK_ON_BLACK_BRIGHT);
				mvaddstrAlt(13, 42, CONST_sitemode165);
				if (talkers) set_color_easy(WHITE_ON_BLACK);
				else set_color_easy(BLACK_ON_BLACK_BRIGHT);
				mvaddstrAlt(14, 17, CONST_sitemode166);
				bool graffiti = 0;
				if (levelmap[locx][locy][locz].special != -1 &&
					levelmap[locx][locy][locz].special != SPECIAL_CLUB_BOUNCER_SECONDVISIT)set_color_easy(WHITE_ON_BLACK);
				else if (!(levelmap[locx][locy][locz].flag & (SITEBLOCK_GRAFFITI | SITEBLOCK_BLOODY2)))
				{
					if ((levelmap[locx + 1][locy][locz].flag & SITEBLOCK_BLOCK) ||
						(levelmap[locx - 1][locy][locz].flag & SITEBLOCK_BLOCK) ||
						(levelmap[locx][locy + 1][locz].flag & SITEBLOCK_BLOCK) ||
						(levelmap[locx][locy - 1][locz].flag & SITEBLOCK_BLOCK))
					{
						bool can_graffiti = false;
						for (int i = 0; i < 6 && !can_graffiti; i++)
						{
							if (!activesquad->squad[i]) i = 6;
							else can_graffiti = activesquad->squad[i]->get_weapon().can_graffiti();

						}
						if (can_graffiti) {

							set_color_easy(WHITE_ON_BLACK);
							graffiti = 1;

						}
						else set_color_easy(BLACK_ON_BLACK_BRIGHT);
					}
					else set_color_easy(BLACK_ON_BLACK_BRIGHT);
				}
				else set_color_easy(BLACK_ON_BLACK_BRIGHT);
				if (graffiti)mvaddstrAlt(11, 42, CONST_sitemode167);
				else mvaddstrAlt(11, 42, CONST_sitemode168);
				if (enemy&&sitealarm)
				{
					bool evade = false;
					set_color_easy(WHITE_ON_BLACK);
					for (int e = 0; e < ENCMAX; e++)
					{
						if (encounter[e].exists &&
							encounter[e].alive  &&
							encounter[e].cantbluff == 2)
						{
							// You can't sneak past this person; they already know you're there
							evade = true;
							break;
						}
					}
					if (!evade)
						mvaddstrAlt(12, 42, CONST_sitemode169);
					else
						mvaddstrAlt(12, 42, CONST_sitemode170);
				}
				else
				{
					set_color_easy(BLACK_ON_BLACK_BRIGHT);
					mvaddstrAlt(12, 42, CONST_sitemode171);
				}
				set_color_easy(WHITE_ON_BLACK);
				mvaddstrAlt(9, 42, CONST_sitemode172);
				if (enemy)set_color_easy(WHITE_ON_BLACK);
				else set_color_easy(BLACK_ON_BLACK_BRIGHT);
				mvaddstrAlt(14, 1, CONST_sitemode173);
				if (!LocationsPool::getInstance().isThereASiegeHere(cursite))
				{
					if (freeable && (!enemy || !sitealarm))
					{
						set_color_easy(WHITE_ON_BLACK);
						mvaddstrAlt(14, 32, CONST_sitemode174);
					}
					else
					{
						if (hostages) set_color_easy(WHITE_ON_BLACK);
						else set_color_easy(BLACK_ON_BLACK_BRIGHT);
						mvaddstrAlt(14, 32, CONST_sitemode175);
					}
				}
				else
				{
					if (libnum > 6)set_color_easy(WHITE_ON_BLACK);
					else set_color_easy(BLACK_ON_BLACK_BRIGHT);
					mvaddstrAlt(14, 32, CONST_sitemode176);
				}
			}
			else
			{
				//DESTROY ALL CARS BROUGHT ALONG WITH PARTY
				if (!LocationsPool::getInstance().isThereASiegeHere(cursite))
				{
					for (int p = 0; p < 6; p++)
					{
						if (!activesquad->squad[p]) continue;
						if (activesquad->squad[p]->carid != -1)
							deleteVehicle(id_getcar(activesquad->squad[p]->carid));
					}
				}
				for (int p = 0; p < 6; p++)
				{
					if (!activesquad->squad[p]) continue;
					activesquad->squad[p]->die();
					activesquad->squad[p]->location = -1;
					activesquad->squad[p] = NULL;
				}
				endcheck(END_BUT_NOT_END); // play the right music in case we're dead
				set_color_easy(WHITE_ON_BLACK);
				mvaddstrAlt(9, 1, CONST_sitemode177);
			}
			//PRINT SITE MAP
			printsitemap(locx, locy, locz);
			//CHECK IF YOU HAVE A SQUIRMING AMATEUR HOSTAGE
			//hostcheck SHOULD ONLY BE 1 WHEN A NEWENC IS CREATED
			if (hostcheck)
			{
				char havehostage = 0;
				//Check your whole squad
				for (int p = 0; p < 6; p++)
				{
					if (activesquad->squad[p] != NULL)
					{
						//If they're unarmed and dragging someone
						if (activesquad->squad[p]->prisoner != NULL &&
							!activesquad->squad[p]->get_weapon().can_threaten_hostages())
						{
							//And that someone is not an LCS member
							if (activesquad->squad[p]->prisoner->squadid == -1)
							{
								//They scream for help -- flag them kidnapped, cause alarm
								activesquad->squad[p]->prisoner->flag |= CREATUREFLAG_KIDNAPPED;
								if (activesquad->squad[p]->type == CREATURE_RADIOPERSONALITY)offended_amradio = 1;
								if (activesquad->squad[p]->type == CREATURE_NEWSANCHOR)offended_cablenews = 1;
								havehostage = 1;
							}
						}
					}
				}
				if (havehostage)
				{
					alienationcheck(1);
					sitecrime += 5;
					criminalizeparty(LAWFLAG_KIDNAPPING);
				}
				hostcheck = 0;
				clearmessagearea();
			}
			// check if we fought the previous loop; if so, add a blank gamelog line
			if (foughtthisround)gamelog.newline();
			foughtthisround = 0;
		}
		{
			int c;
			if (levelmap[locx][locy][locz].special == SPECIAL_CLUB_BOUNCER)
			{
				if (LocationsPool::getInstance().getRentingType(cursite) == RENTING_PERMANENT)
				{
					levelmap[locx][locy][locz].special = SPECIAL_NONE;
					c = getkeyAlt();
				}
				else
					c = 's';
			}
			else c = getkeyAlt();
			if (partyalive == 0 && c == 'c')
			{
				//END OF GAME CHECK
				if (!endcheck())
				{
					if (LocationsPool::getInstance().isThereASiegeHere(cursite))
					{
						if (LocationsPool::getInstance().isThisUnderAttack(cursite))sitestory->type = NEWSSTORY_SQUAD_KILLED_SIEGEATTACK;
						else sitestory->type = NEWSSTORY_SQUAD_KILLED_SIEGEESCAPE;
					}
					else
						if (!LocationsPool::getInstance().isThereASiegeHere(cursite))
						{
							sitestory->type = NEWSSTORY_SQUAD_KILLED_SITE;
							resolvesite();
						}
					mode = GAMEMODE_BASE;
					showcarprefs = 0;
					return;
				}
			}
			else if (partyalive > 0) {
				int olocx = locx, olocy = locy, olocz = locz;
				bool canMove = !enemy || !sitealarm;
				{
					if (c == 'v'&&enemy&&sitealarm)
					{
						char override = whichWay();
						if (override) {
							c = override;
							canMove = true;
						}

					}
				}
				switch (c) {
				case 'w':
				case KEY_UP:
					if (canMove && locy > 0 && !(levelmap[locx][locy - 1][locz].flag & SITEBLOCK_BLOCK))locy--;
					break;
				case 'a':
				case KEY_LEFT:
					if (canMove && !(levelmap[locx - 1][locy][locz].flag & SITEBLOCK_BLOCK))locx--;
					break;
				case 'd':
				case KEY_RIGHT:
					if (canMove && !(levelmap[locx + 1][locy][locz].flag & SITEBLOCK_BLOCK))locx++;
					break;
				case 'x':
				case KEY_DOWN:
					if (canMove && !(levelmap[locx][locy + 1][locz].flag & SITEBLOCK_BLOCK))locy++;
					break;
				case 'k':
					if (enemy) { kidnapattempt(); }
					break;
				case 'u':
					pressedKeyU(enemy);
					break;
				case '1':
				case '2':
				case '3':
				case '4':
				case '5':
				case '6':
					if (activesquad->squad[c - '1'] != NULL)
					{
						if (party_status == c - '1')fullstatus(party_status);
						else party_status = c - '1';
					}
					break;
				case 'e':
					mapshowing = false;
					equip(activesquad->loot, -1);
					if (enemy&&sitealarm)enemyattack();
					else if (enemy)disguisecheck(encounter_timer);
					creatureadvance();
					encounter_timer++;
					mapshowing = true;
					break;
				case 'n':
					pressedKeyN();
					break;
				case 'l':
					if ((!enemy || !sitealarm)) {
						pressedKeyL();
						encounter_timer++;
					}
					break;
				case 'j':
					if ((!enemy || !sitealarm)) {
						pressedKeyShiftL();
						encounter_timer++;
					}
					break;
				case 't':
					if (talkers) {
						pressedKeyT(enemy, encounter_timer);
					}
					break;
				case 'o':
					if (partysize > 1)orderparty();
					break;
				case '0':
					party_status = -1;
					break;
				case 'm':
					pressedKeyM();
					break;
				case 'f':
					if (enemy) { pressedKeyF(encounter_timer); }
					break;
				case 'r':
					pressedKeyR(freeable, libnum, enemy, hostages, partysize);
					break;
				case 'g':
					pressedKeyG(enemy, encounter_timer);
					break;
				}

				if (locx != olocx || locy != olocy || locz != olocz || c == 's') {

					int cbase = -1;
					if (activesquad->squad[0] != NULL)
					{
						cbase = activesquad->squad[0]->base;
					}
					//NEED TO GO BACK TO OLD LOCATION IN CASE COMBAT
					//REFRESHES THE SCREEN
					long nlocx = locx, nlocy = locy, nlocz = locz;
					locx = olocx, locy = olocy, locz = olocz;
					if (enemy) {
						enemyAttemptsFreeShots(encounter_timer);
					}
					creatureadvance();
					encounter_timer++;
					partyalive = squadalive(activesquad);
					if (partyalive) {
						//AFTER DEATH CHECK CAN MOVE BACK TO NEW LOCATION
						locx = nlocx, locy = nlocy, locz = nlocz;
						//CHECK FOR EXIT
						if ((levelmap[locx][locy][locz].flag & SITEBLOCK_EXIT) ||
							(cbase == cursite && !LocationsPool::getInstance().isThereASiegeHere(cursite) &&
								bail_on_base))
						{
							bailOnBase();
							sitealarm = 0;
							return;
						}
						if (moveOrWaitThenCheckForExit(olocx, olocy, olocz, c, encsize, hostcheck)) {
							//RESET MODE
							mode = GAMEMODE_BASE;
							return;
						}
					}
				}
			}
		}
	}
}
newsstoryst* lastNewsStory();
void mode_site(short loc)
{
	extern short postalarmtimer;
	extern short sitealarmtimer;
	extern short siteonfire;
	extern short cursite;
	extern short sitealarm;
	extern int sitecrime;
	extern short sitetype;
	extern short mode;
	extern int ccs_siege_kills;
	extern int ccs_boss_kills;
	extern squadst *activesquad;
	extern MusicClass music;
	extern int locx;
	extern int locy;
	extern int locz;
	extern short sitealienate;
	extern newsstoryst *sitestory;
	extern siteblockst levelmap[MAPX][MAPY][MAPZ];
	sitetype = LocationsPool::getInstance().getLocationType(loc);
	cursite = loc;
	sitealarm = 0;
	sitealarmtimer = -1;
	postalarmtimer = 0;
	siteonfire = 0;
	sitealienate = 0;
	sitecrime = 0;
	LocationsPool::getInstance().initSite(loc);
	sitestory = lastNewsStory();
	mode = GAMEMODE_SITE;
	if (!LocationsPool::getInstance().isThereASiegeHere(loc))
	{
		music.play(MUSIC_SITEMODE);
		ccs_siege_kills = 0;
		ccs_boss_kills = 0;
		//Low profile site action?
		if (activesquad->stance == SQUADSTANCE_ANONYMOUS)
			sitestory->claimed = 0;
		//Start at entrance to map
		locx = MAPX >> 1;
		locy = 1;
		locz = 0;
		// Second floor start of White House
		if (LocationsPool::getInstance().getLocationType(loc) == SITE_GOVERNMENT_WHITE_HOUSE && levelmap[locx][locy][locz].flag & SITEBLOCK_BLOCK)
			locz++;
		//check for sleeper infiltration or map knowledge
		if (CreaturePool::getInstance().doesAnyoneLiveHere(loc) || LocationsPool::getInstance().isLocationMapped(loc))
		{
			//make entire site known
			for (int x = 0; x < MAPX; x++)
				for (int y = 0; y < MAPY; y++)
					for (int z = 0; z < MAPZ; z++)
						levelmap[x][y][z].flag |= SITEBLOCK_KNOWN;
		}
	}
	else
	{
		music.play(MUSIC_DEFENSE);
		sitealarm = 1;
		LocationsPool::getInstance().turnOffSiege(loc);
		//PLACE YOU
		//int maxy=0;
		for (int x = 0; x < MAPX; x++)
			for (int y = 0; y < MAPY; y++)
			{
				for (int z = 0; z < MAPZ; z++)
				{
					if (!(LocationsPool::getInstance().lightsOff(loc)))levelmap[x][y][z].flag |= SITEBLOCK_KNOWN;
					levelmap[x][y][z].flag &= ~SITEBLOCK_LOCKED;
					levelmap[x][y][z].flag &= ~SITEBLOCK_LOOT;
				}
				//if(!(levelmap[x][y][0].flag & (SITEBLOCK_BLOCK|SITEBLOCK_DOOR)))maxy=y;
			}
		//Cops have tanks; firemen have fire.
		if (LocationsPool::getInstance().getSiegeType(loc) == SIEGE_FIREMEN)
		{
			int firesstarted = 0, firex, firey;
			do
			{
				firex = LCSrandom(MAPX), firey = LCSrandom(MAPY);
				firesstarted++;
				levelmap[firex][firey][0].flag |= SITEBLOCK_FIRE_START;
			} while (!(levelmap[firex][firey][0].flag&(SITEBLOCK_BLOCK | SITEBLOCK_DOOR | SITEBLOCK_EXIT)) &&
				firesstarted < 4);
		}
		do
		{
			// Some bugs with degenerate spawn outside the map are occurring
			// Unknown why, but hard-coding limits to spawn location should help
			//locx=LCSrandom(MAPX);
			//locy=maxy-LCSrandom(3);
			locx = MAPX / 2 + LCSrandom(25) - 12;
			locy = 15 - LCSrandom(3);
			//if(locy<3) locy=3;
			locz = 0;
		} while (levelmap[locx][locy][locz].flag&(SITEBLOCK_BLOCK | SITEBLOCK_DOOR |
			SITEBLOCK_FIRE_START | SITEBLOCK_FIRE_PEAK | SITEBLOCK_FIRE_END));
		//PLACE LOOT
		int lootnum = LocationsPool::getInstance().lenloot(loc);
		if (lootnum > 10) lootnum = 10;
		int lx, ly, lz;
		for (int l = 0; l < lootnum; l++)
		{
			do lx = LCSrandom(MAPX), ly = LCSrandom(MAPY), lz = 0;
			while (levelmap[lx][ly][lz].flag&(SITEBLOCK_BLOCK | SITEBLOCK_DOOR | SITEBLOCK_EXIT));
			levelmap[lx][ly][lz].flag |= SITEBLOCK_LOOT;
		}
		//PLACE TRAPS

		if (LocationsPool::getInstance().hasTraps(loc))
		{
			int trapnum = 30;
			for (int t = 0; t < trapnum; t++)
			{
				do lx = LCSrandom(MAPX), ly = LCSrandom(MAPY), lz = 0;
				while (levelmap[lx][ly][lz].flag&(SITEBLOCK_BLOCK | SITEBLOCK_DOOR | SITEBLOCK_EXIT | SITEBLOCK_LOOT));
				levelmap[lx][ly][lz].siegeflag |= SIEGEFLAG_TRAP;
			}
		}
		//PLACE UNITS
		int unitnum = 6;
		int count = 50000;
		for (int t = 0; t < unitnum; t++)
		{
			do
			{
				lx = LCSrandom(11) + (MAPX / 2) - 5;
				ly = LCSrandom(8);
				lz = 0;
				count--;
				if (count == 0) break;
			} while ((levelmap[lx][ly][lz].flag&(SITEBLOCK_BLOCK | SITEBLOCK_DOOR | SITEBLOCK_EXIT)) ||
				(levelmap[lx][ly][lz].siegeflag&(SIEGEFLAG_UNIT | SIEGEFLAG_HEAVYUNIT | SIEGEFLAG_TRAP)));
			levelmap[lx][ly][lz].siegeflag |= SIEGEFLAG_UNIT;
		}
		if (!(LocationsPool::getInstance().doWeHaveTankTraps(loc)) &&
			LocationsPool::getInstance().getSiegeType(loc) == SIEGE_POLICE &&
			LocationsPool::getInstance().getSiegeEscalationState(loc) >= 2)
		{
			levelmap[MAPX / 2][1][0].siegeflag |= SIEGEFLAG_HEAVYUNIT;
			LocationsPool::getInstance().spawnATank(loc, 1);
		}
	}
	mode_site();
}
/* prints the names of creatures you see in car chases */
void printchaseencounter()
{
	extern chaseseqst chaseseq;
	extern Creature encounter[ENCMAX];
	for (int i = 19; i <= 24; i++)
		mvaddstrAlt(i, 0, CONST_sitemode178); // 80 spaces
	if (len(chaseseq.enemycar))
	{
		int carsy[4] = { 20,20,20,20 };
		for (int v = 0; v < len(chaseseq.enemycar); v++)
		{
			set_color_easy(WHITE_ON_BLACK_BRIGHT);
			mvaddstrAlt(19, v * 20 + 1, chaseseq.enemycar[v]->fullname(true));
		}
		for (int e = 0; e < ENCMAX; e++) if (encounter[e].exists)
			for (int v = 0; v < len(chaseseq.enemycar); v++)
				if (chaseseq.enemycar[v]->id() == encounter[e].carid)
				{
					set_color_easy(RED_ON_BLACK_BRIGHT);
					mvaddstrAlt(carsy[v], v * 20 + 1, encounter[e].name);
					if (encounter[e].is_driver) addstrAlt(CONST_sitemode179);
					carsy[v]++;
				}
	}
	else printencounter();
}